<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="_testlib_8h_source" xml:lang="en-US">
<title>testlib.h</title>
<programlisting linenumbering="unnumbered">1 <emphasis role="comment">/*</emphasis>
2 <emphasis role="comment">&#32;*&#32;It&#32;is&#32;strictly&#32;recommended&#32;to&#32;include&#32;&quot;testlib.h&quot;&#32;before&#32;any&#32;other&#32;include</emphasis>
3 <emphasis role="comment">&#32;*&#32;in&#32;your&#32;code.&#32;In&#32;this&#32;case&#32;testlib&#32;overrides&#32;compiler&#32;specific&#32;&quot;random()&quot;.</emphasis>
4 <emphasis role="comment">&#32;*</emphasis>
5 <emphasis role="comment">&#32;*&#32;If&#32;you&#32;can&apos;t&#32;compile&#32;your&#32;code&#32;and&#32;compiler&#32;outputs&#32;something&#32;about</emphasis>
6 <emphasis role="comment">&#32;*&#32;ambiguous&#32;call&#32;of&#32;&quot;random_shuffle&quot;,&#32;&quot;rand&quot;&#32;or&#32;&quot;srand&quot;&#32;it&#32;means&#32;that</emphasis>
7 <emphasis role="comment">&#32;*&#32;you&#32;shouldn&apos;t&#32;use&#32;them.&#32;Use&#32;&quot;shuffle&quot;,&#32;and&#32;&quot;rnd.next()&quot;&#32;instead&#32;of&#32;them</emphasis>
8 <emphasis role="comment">&#32;*&#32;because&#32;these&#32;calls&#32;produce&#32;stable&#32;result&#32;for&#32;any&#32;C++&#32;compiler.&#32;Read</emphasis>
9 <emphasis role="comment">&#32;*&#32;sample&#32;generator&#32;sources&#32;for&#32;clarification.</emphasis>
10 <emphasis role="comment">&#32;*</emphasis>
11 <emphasis role="comment">&#32;*&#32;Please&#32;read&#32;the&#32;documentation&#32;for&#32;class&#32;&quot;random_t&quot;&#32;and&#32;use&#32;&quot;rnd&quot;&#32;instance&#32;in</emphasis>
12 <emphasis role="comment">&#32;*&#32;generators.&#32;Probably,&#32;these&#32;sample&#32;calls&#32;will&#32;be&#32;useful&#32;for&#32;you:</emphasis>
13 <emphasis role="comment">&#32;*&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;rnd.next();&#32;rnd.next(100);&#32;rnd.next(1,&#32;2);</emphasis>
14 <emphasis role="comment">&#32;*&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;rnd.next(3.14);&#32;rnd.next(&quot;[a-z]{1,100}&quot;).</emphasis>
15 <emphasis role="comment">&#32;*</emphasis>
16 <emphasis role="comment">&#32;*&#32;Also&#32;read&#32;about&#32;wnext()&#32;to&#32;generate&#32;off-center&#32;random&#32;distribution.</emphasis>
17 <emphasis role="comment">&#32;*</emphasis>
18 <emphasis role="comment">&#32;*&#32;See&#32;https://github.com/MikeMirzayanov/testlib/&#32;to&#32;get&#32;latest&#32;version&#32;or&#32;bug&#32;tracker.</emphasis>
19 <emphasis role="comment">&#32;*/</emphasis>
20 
21 <emphasis role="preprocessor">#ifndef&#32;_TESTLIB_H_</emphasis>
22 <emphasis role="preprocessor">#define&#32;_TESTLIB_H_</emphasis>
23 
24 <emphasis role="comment">/*</emphasis>
25 <emphasis role="comment">&#32;*&#32;Copyright&#32;(c)&#32;2005-2023</emphasis>
26 <emphasis role="comment">&#32;*/</emphasis>
27 
28 <emphasis role="preprocessor">#define&#32;VERSION&#32;&quot;0.9.41&quot;</emphasis>
29 
30 <emphasis role="comment">/*</emphasis>
31 <emphasis role="comment">&#32;*&#32;Mike&#32;Mirzayanov</emphasis>
32 <emphasis role="comment">&#32;*</emphasis>
33 <emphasis role="comment">&#32;*&#32;This&#32;material&#32;is&#32;provided&#32;&quot;as&#32;is&quot;,&#32;with&#32;absolutely&#32;no&#32;warranty&#32;expressed</emphasis>
34 <emphasis role="comment">&#32;*&#32;or&#32;implied.&#32;Any&#32;use&#32;is&#32;at&#32;your&#32;own&#32;risk.</emphasis>
35 <emphasis role="comment">&#32;*</emphasis>
36 <emphasis role="comment">&#32;*&#32;Permission&#32;to&#32;use&#32;or&#32;copy&#32;this&#32;software&#32;for&#32;any&#32;purpose&#32;is&#32;hereby&#32;granted</emphasis>
37 <emphasis role="comment">&#32;*&#32;without&#32;fee,&#32;provided&#32;the&#32;above&#32;notices&#32;are&#32;retained&#32;on&#32;all&#32;copies.</emphasis>
38 <emphasis role="comment">&#32;*&#32;Permission&#32;to&#32;modify&#32;the&#32;code&#32;and&#32;to&#32;distribute&#32;modified&#32;code&#32;is&#32;granted,</emphasis>
39 <emphasis role="comment">&#32;*&#32;provided&#32;the&#32;above&#32;notices&#32;are&#32;retained,&#32;and&#32;a&#32;notice&#32;that&#32;the&#32;code&#32;was</emphasis>
40 <emphasis role="comment">&#32;*&#32;modified&#32;is&#32;included&#32;with&#32;the&#32;above&#32;copyright&#32;notice.</emphasis>
41 <emphasis role="comment">&#32;*</emphasis>
42 <emphasis role="comment">&#32;*/</emphasis>
43 
44 <emphasis role="comment">/*&#32;NOTE:&#32;This&#32;file&#32;contains&#32;testlib&#32;library&#32;for&#32;C++.</emphasis>
45 <emphasis role="comment">&#32;*</emphasis>
46 <emphasis role="comment">&#32;*&#32;&#32;&#32;Check,&#32;using&#32;testlib&#32;running&#32;format:</emphasis>
47 <emphasis role="comment">&#32;*&#32;&#32;&#32;&#32;&#32;check.exe&#32;&lt;Input_File&gt;&#32;&lt;Output_File&gt;&#32;&lt;Answer_File&gt;&#32;[&lt;Result_File&gt;&#32;[-appes]],</emphasis>
48 <emphasis role="comment">&#32;*&#32;&#32;&#32;If&#32;result&#32;file&#32;is&#32;specified&#32;it&#32;will&#32;contain&#32;results.</emphasis>
49 <emphasis role="comment">&#32;*</emphasis>
50 <emphasis role="comment">&#32;*&#32;&#32;&#32;Validator,&#32;using&#32;testlib&#32;running&#32;format:</emphasis>
51 <emphasis role="comment">&#32;*&#32;&#32;&#32;&#32;&#32;validator.exe&#32;&lt;&#32;input.txt,</emphasis>
52 <emphasis role="comment">&#32;*&#32;&#32;&#32;It&#32;will&#32;return&#32;non-zero&#32;exit&#32;code&#32;and&#32;writes&#32;message&#32;to&#32;standard&#32;output.</emphasis>
53 <emphasis role="comment">&#32;*</emphasis>
54 <emphasis role="comment">&#32;*&#32;&#32;&#32;Generator,&#32;using&#32;testlib&#32;running&#32;format:</emphasis>
55 <emphasis role="comment">&#32;*&#32;&#32;&#32;&#32;&#32;gen.exe&#32;[parameter-1]&#32;[parameter-2]&#32;[...&#32;paramerter-n]</emphasis>
56 <emphasis role="comment">&#32;*&#32;&#32;&#32;You&#32;can&#32;write&#32;generated&#32;test(s)&#32;into&#32;standard&#32;output&#32;or&#32;into&#32;the&#32;file(s).</emphasis>
57 <emphasis role="comment">&#32;*</emphasis>
58 <emphasis role="comment">&#32;*&#32;&#32;&#32;Interactor,&#32;using&#32;testlib&#32;running&#32;format:</emphasis>
59 <emphasis role="comment">&#32;*&#32;&#32;&#32;&#32;&#32;interactor.exe&#32;&lt;Input_File&gt;&#32;&lt;Output_File&gt;&#32;[&lt;Answer_File&gt;&#32;[&lt;Result_File&gt;&#32;[-appes]]],</emphasis>
60 <emphasis role="comment">&#32;*&#32;&#32;&#32;Reads&#32;test&#32;from&#32;inf&#32;(mapped&#32;to&#32;args[1]),&#32;writes&#32;result&#32;to&#32;tout&#32;(mapped&#32;to&#32;argv[2],</emphasis>
61 <emphasis role="comment">&#32;*&#32;&#32;&#32;can&#32;be&#32;judged&#32;by&#32;checker&#32;later),&#32;reads&#32;program&#32;output&#32;from&#32;ouf&#32;(mapped&#32;to&#32;stdin),</emphasis>
62 <emphasis role="comment">&#32;*&#32;&#32;&#32;writes&#32;output&#32;to&#32;program&#32;via&#32;stdout&#32;(use&#32;cout,&#32;printf,&#32;etc).</emphasis>
63 <emphasis role="comment">&#32;*/</emphasis>
64 
65 <emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*latestFeatures[]&#32;=&#32;{
66 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Use&#32;setAppesModeEncoding&#32;to&#32;change&#32;xml&#32;encoding&#32;from&#32;windows-1251&#32;to&#32;other&quot;</emphasis>,
67 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;rnd.any/wany&#32;use&#32;distance/advance&#32;instead&#32;of&#32;-/+:&#32;now&#32;they&#32;support&#32;sets/multisets&quot;</emphasis>,
68 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Use&#32;syntax&#32;`int&#32;t&#32;=&#32;inf.readInt(1,&#32;3,&#32;\&quot;~t\&quot;);`&#32;to&#32;skip&#32;the&#32;lower&#32;bound&#32;check.&#32;Tildes&#32;can&#32;be&#32;used&#32;on&#32;either&#32;side&#32;or&#32;both:&#32;~t,&#32;t~,&#32;~t~&quot;</emphasis>,
69 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Supported&#32;EJUDGE&#32;support&#32;in&#32;registerTestlibCmd&quot;</emphasis>,
70 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Supported&#32;&apos;--testMarkupFileName&#32;fn&apos;&#32;and&#32;&apos;--testCase&#32;tc/--testCaseFileName&#32;fn&apos;&#32;for&#32;validators&quot;</emphasis>,
71 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Added&#32;opt&#32;defaults&#32;via&#32;opt&lt;T&gt;(key/index,&#32;default_val);&#32;check&#32;unused&#32;opts&#32;when&#32;using&#32;has_opt&#32;or&#32;default&#32;opt&#32;(turn&#32;off&#32;this&#32;check&#32;with&#32;suppressEnsureNoUnusedOpt()).&quot;</emphasis>,
72 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;For&#32;checker&#32;added&#32;--group&#32;and&#32;--testset&#32;command&#32;line&#32;params&#32;(like&#32;for&#32;validator),&#32;use&#32;checker.group()&#32;or&#32;checker.testset()&#32;to&#32;get&#32;values&quot;</emphasis>,
73 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Added&#32;quitpi(points_info,&#32;message)&#32;function&#32;to&#32;return&#32;with&#32;_points&#32;exit&#32;code&#32;7&#32;and&#32;given&#32;points_info&quot;</emphasis>,
74 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;rnd.partition(size,&#32;sum[,&#32;min_part=1])&#32;returns&#32;random&#32;(unsorted)&#32;partition&#32;which&#32;is&#32;a&#32;representation&#32;of&#32;the&#32;given&#32;`sum`&#32;as&#32;a&#32;sum&#32;of&#32;`size`&#32;positive&#32;integers&#32;(or&#32;&gt;=min_part&#32;if&#32;specified)&quot;</emphasis>,
75 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;rnd.distinct(size,&#32;n)&#32;and&#32;rnd.distinct(size,&#32;from,&#32;to)&quot;</emphasis>,
76 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;opt&lt;bool&gt;(\&quot;some_missing_key\&quot;)&#32;returns&#32;false&#32;now&quot;</emphasis>,
77 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;has_opt(key)&quot;</emphasis>,
78 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Abort&#32;validator&#32;on&#32;validator.testset()/validator.group()&#32;if&#32;registered&#32;without&#32;using&#32;command&#32;line&quot;</emphasis>,
79 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Print&#32;integer&#32;range&#32;violations&#32;in&#32;a&#32;human&#32;readable&#32;way&#32;like&#32;`violates&#32;the&#32;range&#32;[1,&#32;10^9]`&quot;</emphasis>,
80 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Opts&#32;supported:&#32;use&#32;them&#32;like&#32;n&#32;=&#32;opt&lt;int&gt;(\&quot;n\&quot;),&#32;in&#32;a&#32;command&#32;line&#32;you&#32;can&#32;use&#32;an&#32;exponential&#32;notation&quot;</emphasis>,
81 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Reformatted&quot;</emphasis>,
82 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Use&#32;setTestCase(i)&#32;or&#32;unsetTestCase()&#32;to&#32;support&#32;test&#32;cases&#32;(you&#32;can&#32;use&#32;it&#32;in&#32;any&#32;type&#32;of&#32;program:&#32;generator,&#32;interactor,&#32;validator&#32;or&#32;checker)&quot;</emphasis>,
83 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Fixed&#32;issue&#32;#87:&#32;readStrictDouble&#32;accepts&#32;\&quot;-0.00\&quot;&quot;</emphasis>,
84 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Fixed&#32;issue&#32;#83:&#32;added&#32;InStream::quitif(condition,&#32;...)&quot;</emphasis>,
85 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Fixed&#32;issue&#32;#79:&#32;fixed&#32;missed&#32;guard&#32;against&#32;repeated&#32;header&#32;include&quot;</emphasis>,
86 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Fixed&#32;issue&#32;#80:&#32;fixed&#32;UB&#32;in&#32;case&#32;of&#32;huge&#32;quitf&#32;message&quot;</emphasis>,
87 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Fixed&#32;issue&#32;#84:&#32;added&#32;readXs(size,&#32;indexBase&#32;=&#32;1)&quot;</emphasis>,
88 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Fixed&#32;stringstream&#32;repeated&#32;usage&#32;issue&quot;</emphasis>,
89 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Fixed&#32;compilation&#32;in&#32;g++&#32;(for&#32;std=c++03)&quot;</emphasis>,
90 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Batch&#32;of&#32;println&#32;functions&#32;(support&#32;collections,&#32;iterator&#32;ranges)&quot;</emphasis>,
91 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Introduced&#32;rnd.perm(size,&#32;first&#32;=&#32;0)&#32;to&#32;generate&#32;a&#32;`first`-indexed&#32;permutation&quot;</emphasis>,
92 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Allow&#32;any&#32;whitespace&#32;in&#32;readInts-like&#32;functions&#32;for&#32;non-validators&quot;</emphasis>,
93 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Ignore&#32;4+&#32;command&#32;line&#32;arguments&#32;ifdef&#32;EJUDGE&quot;</emphasis>,
94 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Speed&#32;up&#32;of&#32;vtos&quot;</emphasis>,
95 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Show&#32;line&#32;number&#32;in&#32;validators&#32;in&#32;case&#32;of&#32;incorrect&#32;format&quot;</emphasis>,
96 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Truncate&#32;huge&#32;checker/validator/interactor&#32;message&quot;</emphasis>,
97 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Fixed&#32;issue&#32;with&#32;readTokenTo&#32;of&#32;very&#32;long&#32;tokens,&#32;now&#32;aborts&#32;with&#32;_pe/_fail&#32;depending&#32;of&#32;a&#32;stream&#32;type&quot;</emphasis>,
98 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Introduced&#32;InStream::ensure/ensuref&#32;checking&#32;a&#32;condition,&#32;returns&#32;wa/fail&#32;depending&#32;of&#32;a&#32;stream&#32;type&quot;</emphasis>,
99 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Fixed&#32;compilation&#32;in&#32;VS&#32;2015+&quot;</emphasis>,
100 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Introduced&#32;space-separated&#32;read&#32;functions:&#32;readWords/readTokens,&#32;multilines&#32;read&#32;functions:&#32;readStrings/readLines&quot;</emphasis>,
101 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Introduced&#32;space-separated&#32;read&#32;functions:&#32;readInts/readIntegers/readLongs/readUnsignedLongs/readDoubles/readReals/readStrictDoubles/readStrictReals&quot;</emphasis>,
102 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Introduced&#32;split/tokenize&#32;functions&#32;to&#32;separate&#32;string&#32;by&#32;given&#32;char&quot;</emphasis>,
103 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Introduced&#32;InStream::readUnsignedLong&#32;and&#32;InStream::readLong&#32;with&#32;unsigned&#32;long&#32;long&#32;parameters&quot;</emphasis>,
104 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Supported&#32;--testOverviewLogFileName&#32;for&#32;validator:&#32;bounds&#32;hits&#32;+&#32;features&quot;</emphasis>,
105 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Fixed&#32;UB&#32;(sequence&#32;points)&#32;in&#32;random_t&quot;</emphasis>,
106 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;POINTS_EXIT_CODE&#32;returned&#32;back&#32;to&#32;7&#32;(instead&#32;of&#32;0)&quot;</emphasis>,
107 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Removed&#32;disable&#32;buffers&#32;for&#32;interactive&#32;problems,&#32;because&#32;it&#32;works&#32;unexpectedly&#32;in&#32;wine&quot;</emphasis>,
108 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;InStream&#32;over&#32;string:&#32;constructor&#32;of&#32;InStream&#32;from&#32;base&#32;InStream&#32;to&#32;inherit&#32;policies&#32;and&#32;std::string&quot;</emphasis>,
109 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Added&#32;expectedButFound&#32;quit&#32;function,&#32;examples:&#32;expectedButFound(_wa,&#32;10,&#32;20),&#32;expectedButFound(_fail,&#32;ja,&#32;pa,&#32;\&quot;[n=%d,m=%d]\&quot;,&#32;n,&#32;m)&quot;</emphasis>,
110 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Fixed&#32;incorrect&#32;interval&#32;parsing&#32;in&#32;patterns&quot;</emphasis>,
111 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Use&#32;registerGen(argc,&#32;argv,&#32;1)&#32;to&#32;develop&#32;new&#32;generator,&#32;use&#32;registerGen(argc,&#32;argv,&#32;0)&#32;to&#32;compile&#32;old&#32;generators&#32;(originally&#32;created&#32;for&#32;testlib&#32;under&#32;0.8.7)&quot;</emphasis>,
112 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Introduced&#32;disableFinalizeGuard()&#32;to&#32;switch&#32;off&#32;finalization&#32;checkings&quot;</emphasis>,
113 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Use&#32;join()&#32;functions&#32;to&#32;format&#32;a&#32;range&#32;of&#32;items&#32;as&#32;a&#32;single&#32;string&#32;(separated&#32;by&#32;spaces&#32;or&#32;other&#32;separators)&quot;</emphasis>,
114 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Use&#32;-DENABLE_UNEXPECTED_EOF&#32;to&#32;enable&#32;special&#32;exit&#32;code&#32;(by&#32;default,&#32;8)&#32;in&#32;case&#32;of&#32;unexpected&#32;eof.&#32;It&#32;is&#32;good&#32;idea&#32;to&#32;use&#32;it&#32;in&#32;interactors&quot;</emphasis>,
115 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Use&#32;-DUSE_RND_AS_BEFORE_087&#32;to&#32;compile&#32;in&#32;compatibility&#32;mode&#32;with&#32;random&#32;behavior&#32;of&#32;versions&#32;before&#32;0.8.7&quot;</emphasis>,
116 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Fixed&#32;bug&#32;with&#32;nan&#32;in&#32;stringToDouble&quot;</emphasis>,
117 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Fixed&#32;issue&#32;around&#32;overloads&#32;for&#32;size_t&#32;on&#32;x64&quot;</emphasis>,
118 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Added&#32;attribute&#32;&apos;points&apos;&#32;to&#32;the&#32;XML&#32;output&#32;in&#32;case&#32;of&#32;result=_points&quot;</emphasis>,
119 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Exit&#32;codes&#32;can&#32;be&#32;customized&#32;via&#32;macros,&#32;e.g.&#32;-DPE_EXIT_CODE=14&quot;</emphasis>,
120 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Introduced&#32;InStream&#32;function&#32;readWordTo/readTokenTo/readStringTo/readLineTo&#32;for&#32;faster&#32;reading&quot;</emphasis>,
121 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Introduced&#32;global&#32;functions:&#32;format(),&#32;englishEnding(),&#32;upperCase(),&#32;lowerCase(),&#32;compress()&quot;</emphasis>,
122 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Manual&#32;buffer&#32;in&#32;InStreams,&#32;some&#32;IO&#32;speed&#32;improvements&quot;</emphasis>,
123 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Introduced&#32;quitif(bool,&#32;const&#32;char*&#32;pattern,&#32;...)&#32;which&#32;delegates&#32;to&#32;quitf()&#32;in&#32;case&#32;of&#32;first&#32;argument&#32;is&#32;true&quot;</emphasis>,
124 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Introduced&#32;guard&#32;against&#32;missed&#32;quitf()&#32;in&#32;checker&#32;or&#32;readEof()&#32;in&#32;validators&quot;</emphasis>,
125 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Supported&#32;readStrictReal/readStrictDouble&#32;-&#32;to&#32;use&#32;in&#32;validators&#32;to&#32;check&#32;strictly&#32;float&#32;numbers&quot;</emphasis>,
126 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Supported&#32;registerInteraction(argc,&#32;argv)&quot;</emphasis>,
127 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Print&#32;checker&#32;message&#32;to&#32;the&#32;stderr&#32;instead&#32;of&#32;stdout&quot;</emphasis>,
128 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Supported&#32;TResult&#32;_points&#32;to&#32;output&#32;calculated&#32;score,&#32;use&#32;quitp(...)&#32;functions&quot;</emphasis>,
129 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Fixed&#32;to&#32;be&#32;compilable&#32;on&#32;Mac&quot;</emphasis>,
130 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;PC_BASE_EXIT_CODE=50&#32;in&#32;case&#32;of&#32;defined&#32;TESTSYS&quot;</emphasis>,
131 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Fixed&#32;issues&#32;19-21,&#32;added&#32;__attribute__&#32;format&#32;printf&quot;</emphasis>,
132 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Some&#32;bug&#32;fixes&quot;</emphasis>,
133 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;ouf.readInt(1,&#32;100)&#32;and&#32;similar&#32;calls&#32;return&#32;WA&quot;</emphasis>,
134 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Modified&#32;random_t&#32;to&#32;avoid&#32;integer&#32;overflow&quot;</emphasis>,
135 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Truncated&#32;checker&#32;output&#32;[patch&#32;by&#32;Stepan&#32;Gatilov]&quot;</emphasis>,
136 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Renamed&#32;class&#32;random&#32;-&gt;&#32;class&#32;random_t&quot;</emphasis>,
137 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Supported&#32;name&#32;parameter&#32;for&#32;read-and-validation&#32;methods,&#32;like&#32;readInt(1,&#32;2,&#32;\&quot;n\&quot;)&quot;</emphasis>,
138 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Fixed&#32;bug&#32;in&#32;readDouble()&quot;</emphasis>,
139 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Improved&#32;ensuref(),&#32;fixed&#32;nextLine&#32;to&#32;work&#32;in&#32;case&#32;of&#32;EOF,&#32;added&#32;startTest()&quot;</emphasis>,
140 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Supported&#32;\&quot;partially&#32;correct\&quot;,&#32;example:&#32;quitf(_pc(13),&#32;\&quot;result=%d\&quot;,&#32;result)&quot;</emphasis>,
141 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Added&#32;shuffle(begin,&#32;end),&#32;use&#32;it&#32;instead&#32;of&#32;random_shuffle(begin,&#32;end)&quot;</emphasis>,
142 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Added&#32;readLine(const&#32;string&amp;&#32;ptrn),&#32;fixed&#32;the&#32;logic&#32;of&#32;readLine()&#32;in&#32;the&#32;validation&#32;mode&quot;</emphasis>,
143 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Package&#32;extended&#32;with&#32;samples&#32;of&#32;generators&#32;and&#32;validators&quot;</emphasis>,
144 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Written&#32;the&#32;documentation&#32;for&#32;classes&#32;and&#32;public&#32;methods&#32;in&#32;testlib.h&quot;</emphasis>,
145 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Implemented&#32;random&#32;routine&#32;to&#32;support&#32;generators,&#32;use&#32;registerGen()&#32;to&#32;switch&#32;it&#32;on&quot;</emphasis>,
146 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Implemented&#32;strict&#32;mode&#32;to&#32;validate&#32;tests,&#32;use&#32;registerValidation()&#32;to&#32;switch&#32;it&#32;on&quot;</emphasis>,
147 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Now&#32;ncmp.cpp&#32;and&#32;wcmp.cpp&#32;are&#32;return&#32;WA&#32;if&#32;answer&#32;is&#32;suffix&#32;or&#32;prefix&#32;of&#32;the&#32;output&quot;</emphasis>,
148 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Added&#32;InStream::readLong()&#32;and&#32;removed&#32;InStream::readLongint()&quot;</emphasis>,
149 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Now&#32;no&#32;footer&#32;added&#32;to&#32;each&#32;report&#32;by&#32;default&#32;(use&#32;directive&#32;FOOTER&#32;to&#32;switch&#32;on)&quot;</emphasis>,
150 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Now&#32;every&#32;checker&#32;has&#32;a&#32;name,&#32;use&#32;setName(const&#32;char*&#32;format,&#32;...)&#32;to&#32;set&#32;it&quot;</emphasis>,
151 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Now&#32;it&#32;is&#32;compatible&#32;with&#32;TTS&#32;(by&#32;Kittens&#32;Computing)&quot;</emphasis>,
152 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Added&#32;\&apos;ensure(condition,&#32;message&#32;=&#32;\&quot;\&quot;)\&apos;&#32;feature,&#32;it&#32;works&#32;like&#32;assert()&quot;</emphasis>,
153 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Fixed&#32;compatibility&#32;with&#32;MS&#32;C++&#32;7.1&quot;</emphasis>,
154 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Added&#32;footer&#32;with&#32;exit&#32;code&#32;information&quot;</emphasis>,
155 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Added&#32;compatibility&#32;with&#32;EJUDGE&#32;(compile&#32;with&#32;EJUDGE&#32;directive)&quot;</emphasis>,
156 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Added&#32;compatibility&#32;with&#32;Contester&#32;(compile&#32;with&#32;CONTESTER&#32;directive)&quot;</emphasis>
157 };
158 
159 <emphasis role="preprocessor">#ifdef&#32;_MSC_VER</emphasis>
160 <emphasis role="preprocessor">#define&#32;_CRT_SECURE_NO_DEPRECATE</emphasis>
161 <emphasis role="preprocessor">#define&#32;_CRT_SECURE_NO_WARNINGS</emphasis>
162 <emphasis role="preprocessor">#define&#32;_CRT_NO_VA_START_VALIDATION</emphasis>
163 <emphasis role="preprocessor">#endif</emphasis>
164 
165 <emphasis role="comment">/*&#32;Overrides&#32;random()&#32;for&#32;Borland&#32;C++.&#32;*/</emphasis>
166 <emphasis role="preprocessor">#define&#32;random&#32;__random_deprecated</emphasis>
167 <emphasis role="preprocessor">#include&#32;&lt;stdlib.h&gt;</emphasis>
168 <emphasis role="preprocessor">#include&#32;&lt;cstdlib&gt;</emphasis>
169 <emphasis role="preprocessor">#include&#32;&lt;climits&gt;</emphasis>
170 <emphasis role="preprocessor">#include&#32;&lt;algorithm&gt;</emphasis>
171 <emphasis role="preprocessor">#undef&#32;random</emphasis>
172 
173 <emphasis role="preprocessor">#include&#32;&lt;cstdio&gt;</emphasis>
174 <emphasis role="preprocessor">#include&#32;&lt;cctype&gt;</emphasis>
175 <emphasis role="preprocessor">#include&#32;&lt;string&gt;</emphasis>
176 <emphasis role="preprocessor">#include&#32;&lt;vector&gt;</emphasis>
177 <emphasis role="preprocessor">#include&#32;&lt;map&gt;</emphasis>
178 <emphasis role="preprocessor">#include&#32;&lt;set&gt;</emphasis>
179 <emphasis role="preprocessor">#include&#32;&lt;cmath&gt;</emphasis>
180 <emphasis role="preprocessor">#include&#32;&lt;iterator&gt;</emphasis>
181 <emphasis role="preprocessor">#include&#32;&lt;iostream&gt;</emphasis>
182 <emphasis role="preprocessor">#include&#32;&lt;sstream&gt;</emphasis>
183 <emphasis role="preprocessor">#include&#32;&lt;fstream&gt;</emphasis>
184 <emphasis role="preprocessor">#include&#32;&lt;cstring&gt;</emphasis>
185 <emphasis role="preprocessor">#include&#32;&lt;limits&gt;</emphasis>
186 <emphasis role="preprocessor">#include&#32;&lt;stdarg.h&gt;</emphasis>
187 <emphasis role="preprocessor">#include&#32;&lt;fcntl.h&gt;</emphasis>
188 <emphasis role="preprocessor">#include&#32;&lt;functional&gt;</emphasis>
189 <emphasis role="preprocessor">#include&#32;&lt;cstdint&gt;</emphasis>
190 
191 <emphasis role="preprocessor">#ifdef&#32;TESTLIB_THROW_EXIT_EXCEPTION_INSTEAD_OF_EXIT</emphasis>
192 <emphasis role="preprocessor">#&#32;&#32;&#32;include&#32;&lt;exception&gt;</emphasis>
193 <emphasis role="preprocessor">#endif</emphasis>
194 
195 <emphasis role="preprocessor">#if&#32;(_WIN32&#32;||&#32;__WIN32__&#32;||&#32;__WIN32&#32;||&#32;_WIN64&#32;||&#32;__WIN64__&#32;||&#32;__WIN64&#32;||&#32;WINNT&#32;||&#32;__WINNT&#32;||&#32;__WINNT__&#32;||&#32;__CYGWIN__)</emphasis>
196 <emphasis role="preprocessor">#&#32;&#32;&#32;if&#32;!defined(_MSC_VER)&#32;||&#32;_MSC_VER&#32;&gt;&#32;1400</emphasis>
197 <emphasis role="preprocessor">#&#32;&#32;&#32;&#32;&#32;&#32;&#32;define&#32;NOMINMAX&#32;1</emphasis>
198 <emphasis role="preprocessor">#&#32;&#32;&#32;&#32;&#32;&#32;&#32;include&#32;&lt;windows.h&gt;</emphasis>
199 <emphasis role="preprocessor">#&#32;&#32;&#32;else</emphasis>
200 <emphasis role="preprocessor">#&#32;&#32;&#32;&#32;&#32;&#32;&#32;define&#32;WORD&#32;unsigned&#32;short</emphasis>
201 <emphasis role="preprocessor">#&#32;&#32;&#32;&#32;&#32;&#32;&#32;include&#32;&lt;unistd.h&gt;</emphasis>
202 <emphasis role="preprocessor">#&#32;&#32;&#32;endif</emphasis>
203 <emphasis role="preprocessor">#&#32;&#32;&#32;include&#32;&lt;io.h&gt;</emphasis>
204 <emphasis role="preprocessor">#&#32;&#32;&#32;define&#32;ON_WINDOWS</emphasis>
205 <emphasis role="preprocessor">#&#32;&#32;&#32;if&#32;defined(_MSC_VER)&#32;&amp;&amp;&#32;_MSC_VER&#32;&gt;&#32;1400</emphasis>
206 <emphasis role="preprocessor">#&#32;&#32;&#32;&#32;&#32;&#32;&#32;pragma&#32;warning(&#32;disable&#32;:&#32;4127&#32;)</emphasis>
207 <emphasis role="preprocessor">#&#32;&#32;&#32;&#32;&#32;&#32;&#32;pragma&#32;warning(&#32;disable&#32;:&#32;4146&#32;)</emphasis>
208 <emphasis role="preprocessor">#&#32;&#32;&#32;&#32;&#32;&#32;&#32;pragma&#32;warning(&#32;disable&#32;:&#32;4458&#32;)</emphasis>
209 <emphasis role="preprocessor">#&#32;&#32;&#32;endif</emphasis>
210 <emphasis role="preprocessor">#else</emphasis>
211 <emphasis role="preprocessor">#&#32;&#32;&#32;define&#32;WORD&#32;unsigned&#32;short</emphasis>
212 <emphasis role="preprocessor">#&#32;&#32;&#32;include&#32;&lt;unistd.h&gt;</emphasis>
213 <emphasis role="preprocessor">#endif</emphasis>
214 
215 <emphasis role="preprocessor">#if&#32;defined(FOR_WINDOWS)&#32;&amp;&amp;&#32;defined(FOR_LINUX)</emphasis>
216 <emphasis role="preprocessor">#error&#32;Only&#32;one&#32;target&#32;system&#32;is&#32;allowed</emphasis>
217 <emphasis role="preprocessor">#endif</emphasis>
218 
219 <emphasis role="preprocessor">#ifndef&#32;LLONG_MIN</emphasis>
220 <emphasis role="preprocessor">#define&#32;LLONG_MIN&#32;&#32;&#32;(-9223372036854775807LL&#32;-&#32;1)</emphasis>
221 <emphasis role="preprocessor">#endif</emphasis>
222 
223 <emphasis role="preprocessor">#ifndef&#32;ULLONG_MAX</emphasis>
224 <emphasis role="preprocessor">#define&#32;ULLONG_MAX&#32;&#32;&#32;(18446744073709551615)</emphasis>
225 <emphasis role="preprocessor">#endif</emphasis>
226 
227 <emphasis role="preprocessor">#define&#32;LF&#32;((char)10)</emphasis>
228 <emphasis role="preprocessor">#define&#32;CR&#32;((char)13)</emphasis>
229 <emphasis role="preprocessor">#define&#32;TAB&#32;((char)9)</emphasis>
230 <emphasis role="preprocessor">#define&#32;SPACE&#32;((char)&apos;&#32;&apos;)</emphasis>
231 <emphasis role="preprocessor">#define&#32;EOFC&#32;(255)</emphasis>
232 
233 <emphasis role="preprocessor">#ifndef&#32;OK_EXIT_CODE</emphasis>
234 <emphasis role="preprocessor">#&#32;&#32;&#32;ifdef&#32;CONTESTER</emphasis>
235 <emphasis role="preprocessor">#&#32;&#32;&#32;&#32;&#32;&#32;&#32;define&#32;OK_EXIT_CODE&#32;0xAC</emphasis>
236 <emphasis role="preprocessor">#&#32;&#32;&#32;else</emphasis>
237 <emphasis role="preprocessor">#&#32;&#32;&#32;&#32;&#32;&#32;&#32;define&#32;OK_EXIT_CODE&#32;0</emphasis>
238 <emphasis role="preprocessor">#&#32;&#32;&#32;endif</emphasis>
239 <emphasis role="preprocessor">#endif</emphasis>
240 
241 <emphasis role="preprocessor">#ifndef&#32;WA_EXIT_CODE</emphasis>
242 <emphasis role="preprocessor">#&#32;&#32;&#32;ifdef&#32;EJUDGE</emphasis>
243 <emphasis role="preprocessor">#&#32;&#32;&#32;&#32;&#32;&#32;&#32;define&#32;WA_EXIT_CODE&#32;5</emphasis>
244 <emphasis role="preprocessor">#&#32;&#32;&#32;elif&#32;defined(CONTESTER)</emphasis>
245 <emphasis role="preprocessor">#&#32;&#32;&#32;&#32;&#32;&#32;&#32;define&#32;WA_EXIT_CODE&#32;0xAB</emphasis>
246 <emphasis role="preprocessor">#&#32;&#32;&#32;else</emphasis>
247 <emphasis role="preprocessor">#&#32;&#32;&#32;&#32;&#32;&#32;&#32;define&#32;WA_EXIT_CODE&#32;1</emphasis>
248 <emphasis role="preprocessor">#&#32;&#32;&#32;endif</emphasis>
249 <emphasis role="preprocessor">#endif</emphasis>
250 
251 <emphasis role="preprocessor">#ifndef&#32;PE_EXIT_CODE</emphasis>
252 <emphasis role="preprocessor">#&#32;&#32;&#32;ifdef&#32;EJUDGE</emphasis>
253 <emphasis role="preprocessor">#&#32;&#32;&#32;&#32;&#32;&#32;&#32;define&#32;PE_EXIT_CODE&#32;4</emphasis>
254 <emphasis role="preprocessor">#&#32;&#32;&#32;elif&#32;defined(CONTESTER)</emphasis>
255 <emphasis role="preprocessor">#&#32;&#32;&#32;&#32;&#32;&#32;&#32;define&#32;PE_EXIT_CODE&#32;0xAA</emphasis>
256 <emphasis role="preprocessor">#&#32;&#32;&#32;else</emphasis>
257 <emphasis role="preprocessor">#&#32;&#32;&#32;&#32;&#32;&#32;&#32;define&#32;PE_EXIT_CODE&#32;2</emphasis>
258 <emphasis role="preprocessor">#&#32;&#32;&#32;endif</emphasis>
259 <emphasis role="preprocessor">#endif</emphasis>
260 
261 <emphasis role="preprocessor">#ifndef&#32;FAIL_EXIT_CODE</emphasis>
262 <emphasis role="preprocessor">#&#32;&#32;&#32;ifdef&#32;EJUDGE</emphasis>
263 <emphasis role="preprocessor">#&#32;&#32;&#32;&#32;&#32;&#32;&#32;define&#32;FAIL_EXIT_CODE&#32;6</emphasis>
264 <emphasis role="preprocessor">#&#32;&#32;&#32;elif&#32;defined(CONTESTER)</emphasis>
265 <emphasis role="preprocessor">#&#32;&#32;&#32;&#32;&#32;&#32;&#32;define&#32;FAIL_EXIT_CODE&#32;0xA3</emphasis>
266 <emphasis role="preprocessor">#&#32;&#32;&#32;else</emphasis>
267 <emphasis role="preprocessor">#&#32;&#32;&#32;&#32;&#32;&#32;&#32;define&#32;FAIL_EXIT_CODE&#32;3</emphasis>
268 <emphasis role="preprocessor">#&#32;&#32;&#32;endif</emphasis>
269 <emphasis role="preprocessor">#endif</emphasis>
270 
271 <emphasis role="preprocessor">#ifndef&#32;DIRT_EXIT_CODE</emphasis>
272 <emphasis role="preprocessor">#&#32;&#32;&#32;ifdef&#32;EJUDGE</emphasis>
273 <emphasis role="preprocessor">#&#32;&#32;&#32;&#32;&#32;&#32;&#32;define&#32;DIRT_EXIT_CODE&#32;6</emphasis>
274 <emphasis role="preprocessor">#&#32;&#32;&#32;else</emphasis>
275 <emphasis role="preprocessor">#&#32;&#32;&#32;&#32;&#32;&#32;&#32;define&#32;DIRT_EXIT_CODE&#32;4</emphasis>
276 <emphasis role="preprocessor">#&#32;&#32;&#32;endif</emphasis>
277 <emphasis role="preprocessor">#endif</emphasis>
278 
279 <emphasis role="preprocessor">#ifndef&#32;POINTS_EXIT_CODE</emphasis>
280 <emphasis role="preprocessor">#&#32;&#32;&#32;define&#32;POINTS_EXIT_CODE&#32;7</emphasis>
281 <emphasis role="preprocessor">#endif</emphasis>
282 
283 <emphasis role="preprocessor">#ifndef&#32;UNEXPECTED_EOF_EXIT_CODE</emphasis>
284 <emphasis role="preprocessor">#&#32;&#32;&#32;define&#32;UNEXPECTED_EOF_EXIT_CODE&#32;8</emphasis>
285 <emphasis role="preprocessor">#endif</emphasis>
286 
287 <emphasis role="preprocessor">#ifndef&#32;PC_BASE_EXIT_CODE</emphasis>
288 <emphasis role="preprocessor">#&#32;&#32;&#32;ifdef&#32;TESTSYS</emphasis>
289 <emphasis role="preprocessor">#&#32;&#32;&#32;&#32;&#32;&#32;&#32;define&#32;PC_BASE_EXIT_CODE&#32;50</emphasis>
290 <emphasis role="preprocessor">#&#32;&#32;&#32;else</emphasis>
291 <emphasis role="preprocessor">#&#32;&#32;&#32;&#32;&#32;&#32;&#32;define&#32;PC_BASE_EXIT_CODE&#32;0</emphasis>
292 <emphasis role="preprocessor">#&#32;&#32;&#32;endif</emphasis>
293 <emphasis role="preprocessor">#endif</emphasis>
294 
295 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
296 <emphasis role="preprocessor">#&#32;&#32;&#32;&#32;define&#32;__TESTLIB_STATIC_ASSERT(condition)&#32;typedef&#32;void*&#32;__testlib_static_assert_type[(condition)&#32;?&#32;1&#32;:&#32;-1]&#32;__attribute__((unused))</emphasis>
297 <emphasis role="preprocessor">#else</emphasis>
298 <emphasis role="preprocessor">#&#32;&#32;&#32;&#32;define&#32;__TESTLIB_STATIC_ASSERT(condition)&#32;typedef&#32;void*&#32;__testlib_static_assert_type[(condition)&#32;?&#32;1&#32;:&#32;-1]</emphasis>
299 <emphasis role="preprocessor">#endif</emphasis>
300 
301 <emphasis role="preprocessor">#ifdef&#32;ON_WINDOWS</emphasis>
302 <emphasis role="preprocessor">#define&#32;I64&#32;&quot;%I64d&quot;</emphasis>
303 <emphasis role="preprocessor">#define&#32;U64&#32;&quot;%I64u&quot;</emphasis>
304 <emphasis role="preprocessor">#else</emphasis>
305 <emphasis role="preprocessor">#define&#32;I64&#32;&quot;%lld&quot;</emphasis>
306 <emphasis role="preprocessor">#define&#32;U64&#32;&quot;%llu&quot;</emphasis>
307 <emphasis role="preprocessor">#endif</emphasis>
308 
309 <emphasis role="preprocessor">#ifdef&#32;_MSC_VER</emphasis>
310 <emphasis role="preprocessor">#&#32;&#32;&#32;define&#32;NORETURN&#32;__declspec(noreturn)</emphasis>
311 <emphasis role="preprocessor">#elif&#32;defined&#32;__GNUC__</emphasis>
312 <emphasis role="preprocessor">#&#32;&#32;&#32;define&#32;NORETURN&#32;__attribute__&#32;((noreturn))</emphasis>
313 <emphasis role="preprocessor">#else</emphasis>
314 <emphasis role="preprocessor">#&#32;&#32;&#32;define&#32;NORETURN</emphasis>
315 <emphasis role="preprocessor">#endif</emphasis>
316 
317 <emphasis role="keyword">static</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;__testlib_format_buffer[16777216];
318 <emphasis role="keyword">static</emphasis>&#32;<emphasis role="keywordtype">int</emphasis>&#32;__testlib_format_buffer_usage_count&#32;=&#32;0;
319 
320 <emphasis role="preprocessor">#define&#32;FMT_TO_RESULT(fmt,&#32;cstr,&#32;result)&#32;&#32;std::string&#32;result;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;\</emphasis>
321 <emphasis role="preprocessor">&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;if&#32;(__testlib_format_buffer_usage_count&#32;!=&#32;0)&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;\</emphasis>
322 <emphasis role="preprocessor">&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(&quot;FMT_TO_RESULT::__testlib_format_buffer_usage_count&#32;!=&#32;0&quot;);&#32;\</emphasis>
323 <emphasis role="preprocessor">&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_format_buffer_usage_count++;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;\</emphasis>
324 <emphasis role="preprocessor">&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;va_list&#32;ap;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;\</emphasis>
325 <emphasis role="preprocessor">&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;va_start(ap,&#32;fmt);&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;\</emphasis>
326 <emphasis role="preprocessor">&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;vsnprintf(__testlib_format_buffer,&#32;sizeof(__testlib_format_buffer),&#32;cstr,&#32;ap);&#32;\</emphasis>
327 <emphasis role="preprocessor">&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;va_end(ap);&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;\</emphasis>
328 <emphasis role="preprocessor">&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_format_buffer[sizeof(__testlib_format_buffer)&#32;-&#32;1]&#32;=&#32;0;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;\</emphasis>
329 <emphasis role="preprocessor">&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result&#32;=&#32;std::string(__testlib_format_buffer);&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;\</emphasis>
330 <emphasis role="preprocessor">&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_format_buffer_usage_count--;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;\</emphasis>
331 <emphasis role="preprocessor"></emphasis>
332 <emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;__TESTLIB_LONGLONG_MAX&#32;=&#32;9223372036854775807LL;
333 <emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">int</emphasis>&#32;__TESTLIB_MAX_TEST_CASE&#32;=&#32;1073741823;
334 
335 <emphasis role="keywordtype">int</emphasis>&#32;__testlib_exitCode;
336 
337 <emphasis role="keywordtype">bool</emphasis>&#32;__testlib_hasTestCase;
338 <emphasis role="keywordtype">int</emphasis>&#32;__testlib_testCase&#32;=&#32;-1;
339 
340 <emphasis role="keywordtype">void</emphasis>&#32;setTestCase(<emphasis role="keywordtype">int</emphasis>&#32;testCase);
341 
342 <emphasis role="keywordtype">void</emphasis>&#32;unsetTestCase()&#32;{
343 &#32;&#32;&#32;&#32;__testlib_hasTestCase&#32;=&#32;<emphasis role="keyword">false</emphasis>;
344 &#32;&#32;&#32;&#32;__testlib_testCase&#32;=&#32;-1;
345 }
346 
347 NORETURN&#32;<emphasis role="keyword">static</emphasis>&#32;<emphasis role="keywordtype">void</emphasis>&#32;__testlib_fail(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;message);
348 
349 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Tp&gt;
350 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
351 __attribute__((<emphasis role="keyword">const</emphasis>))
352 <emphasis role="preprocessor">#endif</emphasis>
353 <emphasis role="keyword">static</emphasis>&#32;<emphasis role="keyword">inline</emphasis>&#32;_Tp&#32;__testlib_abs(<emphasis role="keyword">const</emphasis>&#32;_Tp&#32;&amp;x)&#32;{
354 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;x&#32;&gt;&#32;0&#32;?&#32;x&#32;:&#32;-x;
355 }
356 
357 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Tp&gt;
358 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
359 __attribute__((<emphasis role="keyword">const</emphasis>))
360 <emphasis role="preprocessor">#endif</emphasis>
361 <emphasis role="keyword">static</emphasis>&#32;<emphasis role="keyword">inline</emphasis>&#32;_Tp&#32;__testlib_min(<emphasis role="keyword">const</emphasis>&#32;_Tp&#32;&amp;a,&#32;<emphasis role="keyword">const</emphasis>&#32;_Tp&#32;&amp;b)&#32;{
362 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;a&#32;&lt;&#32;b&#32;?&#32;a&#32;:&#32;b;
363 }
364 
365 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Tp&gt;
366 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
367 __attribute__((<emphasis role="keyword">const</emphasis>))
368 <emphasis role="preprocessor">#endif</emphasis>
369 <emphasis role="keyword">static</emphasis>&#32;<emphasis role="keyword">inline</emphasis>&#32;_Tp&#32;__testlib_max(<emphasis role="keyword">const</emphasis>&#32;_Tp&#32;&amp;a,&#32;<emphasis role="keyword">const</emphasis>&#32;_Tp&#32;&amp;b)&#32;{
370 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;a&#32;&gt;&#32;b&#32;?&#32;a&#32;:&#32;b;
371 }
372 
373 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Tp&gt;
374 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
375 __attribute__((<emphasis role="keyword">const</emphasis>))
376 <emphasis role="preprocessor">#endif</emphasis>
377 <emphasis role="keyword">static</emphasis>&#32;<emphasis role="keyword">inline</emphasis>&#32;_Tp&#32;__testlib_crop(_Tp&#32;value,&#32;_Tp&#32;a,&#32;_Tp&#32;b)&#32;{
378 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__testlib_min(__testlib_max(value,&#32;a),&#32;--b);
379 }
380 
381 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
382 __attribute__((<emphasis role="keyword">const</emphasis>))
383 <emphasis role="preprocessor">#endif</emphasis>
384 <emphasis role="keyword">static</emphasis>&#32;<emphasis role="keyword">inline</emphasis>&#32;<emphasis role="keywordtype">double</emphasis>&#32;__testlib_crop(<emphasis role="keywordtype">double</emphasis>&#32;value,&#32;<emphasis role="keywordtype">double</emphasis>&#32;a,&#32;<emphasis role="keywordtype">double</emphasis>&#32;b)&#32;{
385 &#32;&#32;&#32;&#32;value&#32;=&#32;__testlib_min(__testlib_max(value,&#32;a),&#32;b);
386 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(value&#32;&gt;=&#32;b)
387 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;value&#32;=&#32;std::nexttoward(b,&#32;a);
388 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;value;
389 }
390 
391 <emphasis role="keyword">static</emphasis>&#32;<emphasis role="keywordtype">bool</emphasis>&#32;__testlib_prelimIsNaN(<emphasis role="keywordtype">double</emphasis>&#32;r)&#32;{
392 &#32;&#32;&#32;&#32;<emphasis role="keyword">volatile</emphasis>&#32;<emphasis role="keywordtype">double</emphasis>&#32;ra&#32;=&#32;r;
393 <emphasis role="preprocessor">#ifndef&#32;__BORLANDC__</emphasis>
394 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;((ra&#32;!=&#32;ra)&#32;==&#32;<emphasis role="keyword">true</emphasis>)&#32;&amp;&amp;&#32;((ra&#32;==&#32;ra)&#32;==&#32;<emphasis role="keyword">false</emphasis>)&#32;&amp;&amp;&#32;((1.0&#32;&gt;&#32;ra)&#32;==&#32;<emphasis role="keyword">false</emphasis>)&#32;&amp;&amp;&#32;((1.0&#32;&lt;&#32;ra)&#32;==&#32;<emphasis role="keyword">false</emphasis>);
395 <emphasis role="preprocessor">#else</emphasis>
396 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;std::_isnan(ra);
397 <emphasis role="preprocessor">#endif</emphasis>
398 }
399 
400 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
401 __attribute__((<emphasis role="keyword">const</emphasis>))
402 <emphasis role="preprocessor">#endif</emphasis>
403 <emphasis role="keyword">static</emphasis>&#32;std::string&#32;removeDoubleTrailingZeroes(std::string&#32;value)&#32;{
404 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">while</emphasis>&#32;(!value.empty()&#32;&amp;&amp;&#32;value[value.length()&#32;-&#32;1]&#32;==&#32;<emphasis role="charliteral">&apos;0&apos;</emphasis>&#32;&amp;&amp;&#32;value.find(<emphasis role="charliteral">&apos;.&apos;</emphasis>)&#32;!=&#32;std::string::npos)
405 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;value&#32;=&#32;value.substr(0,&#32;value.length()&#32;-&#32;1);
406 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!value.empty()&#32;&amp;&amp;&#32;value[value.length()&#32;-&#32;1]&#32;==&#32;<emphasis role="charliteral">&apos;.&apos;</emphasis>)
407 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;value&#32;+&#32;<emphasis role="charliteral">&apos;0&apos;</emphasis>;
408 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
409 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;value;
410 }
411 
412 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
413 __attribute__((<emphasis role="keyword">const</emphasis>))
414 <emphasis role="preprocessor">#endif</emphasis>
415 <emphasis role="keyword">inline</emphasis>&#32;std::string&#32;upperCase(std::string&#32;s)&#32;{
416 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">size_t</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;s.length();&#32;i++)
417 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(<emphasis role="charliteral">&apos;a&apos;</emphasis>&#32;&lt;=&#32;s[i]&#32;&amp;&amp;&#32;s[i]&#32;&lt;=&#32;<emphasis role="charliteral">&apos;z&apos;</emphasis>)
418 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;s[i]&#32;=&#32;char(s[i]&#32;-&#32;<emphasis role="charliteral">&apos;a&apos;</emphasis>&#32;+&#32;<emphasis role="charliteral">&apos;A&apos;</emphasis>);
419 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;s;
420 }
421 
422 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
423 __attribute__((<emphasis role="keyword">const</emphasis>))
424 <emphasis role="preprocessor">#endif</emphasis>
425 <emphasis role="keyword">inline</emphasis>&#32;std::string&#32;lowerCase(std::string&#32;s)&#32;{
426 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">size_t</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;s.length();&#32;i++)
427 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(<emphasis role="charliteral">&apos;A&apos;</emphasis>&#32;&lt;=&#32;s[i]&#32;&amp;&amp;&#32;s[i]&#32;&lt;=&#32;<emphasis role="charliteral">&apos;Z&apos;</emphasis>)
428 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;s[i]&#32;=&#32;char(s[i]&#32;-&#32;<emphasis role="charliteral">&apos;A&apos;</emphasis>&#32;+&#32;<emphasis role="charliteral">&apos;a&apos;</emphasis>);
429 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;s;
430 }
431 
432 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
433 __attribute__&#32;((format&#32;(printf,&#32;1,&#32;2)))
434 <emphasis role="preprocessor">#endif</emphasis>
435 std::string&#32;format(<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*fmt,&#32;...)&#32;{
436 &#32;&#32;&#32;&#32;FMT_TO_RESULT(fmt,&#32;fmt,&#32;result);
437 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;result;
438 }
439 
440 std::string&#32;format(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;fmt,&#32;...)&#32;{
441 &#32;&#32;&#32;&#32;FMT_TO_RESULT(fmt,&#32;fmt.c_str(),&#32;result);
442 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;result;
443 }
444 
445 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
446 __attribute__((<emphasis role="keyword">const</emphasis>))
447 <emphasis role="preprocessor">#endif</emphasis>
448 <emphasis role="keyword">static</emphasis>&#32;std::string&#32;__testlib_part(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;s);
449 
450 <emphasis role="keyword">static</emphasis>&#32;<emphasis role="keywordtype">bool</emphasis>&#32;__testlib_isNaN(<emphasis role="keywordtype">double</emphasis>&#32;r)&#32;{
451 &#32;&#32;&#32;&#32;__TESTLIB_STATIC_ASSERT(<emphasis role="keyword">sizeof</emphasis>(<emphasis role="keywordtype">double</emphasis>)&#32;==&#32;<emphasis role="keyword">sizeof</emphasis>(<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>));
452 &#32;&#32;&#32;&#32;<emphasis role="keyword">volatile</emphasis>&#32;<emphasis role="keywordtype">double</emphasis>&#32;ra&#32;=&#32;r;
453 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;llr1,&#32;llr2;
454 &#32;&#32;&#32;&#32;std::memcpy((<emphasis role="keywordtype">void</emphasis>&#32;*)&#32;&amp;llr1,&#32;(<emphasis role="keywordtype">void</emphasis>&#32;*)&#32;&amp;ra,&#32;<emphasis role="keyword">sizeof</emphasis>(<emphasis role="keywordtype">double</emphasis>));
455 &#32;&#32;&#32;&#32;ra&#32;=&#32;-ra;
456 &#32;&#32;&#32;&#32;std::memcpy((<emphasis role="keywordtype">void</emphasis>&#32;*)&#32;&amp;llr2,&#32;(<emphasis role="keywordtype">void</emphasis>&#32;*)&#32;&amp;ra,&#32;<emphasis role="keyword">sizeof</emphasis>(<emphasis role="keywordtype">double</emphasis>));
457 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;llnan&#32;=&#32;0xFFF8000000000000LL;
458 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__testlib_prelimIsNaN(r)&#32;||&#32;llnan&#32;==&#32;llr1&#32;||&#32;llnan&#32;==&#32;llr2;
459 }
460 
461 <emphasis role="keyword">static</emphasis>&#32;<emphasis role="keywordtype">double</emphasis>&#32;__testlib_nan()&#32;{
462 &#32;&#32;&#32;&#32;__TESTLIB_STATIC_ASSERT(<emphasis role="keyword">sizeof</emphasis>(<emphasis role="keywordtype">double</emphasis>)&#32;==&#32;<emphasis role="keyword">sizeof</emphasis>(<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>));
463 <emphasis role="preprocessor">#ifndef&#32;NAN</emphasis>
464 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;llnan&#32;=&#32;0xFFF8000000000000LL;
465 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">double</emphasis>&#32;nan;
466 &#32;&#32;&#32;&#32;std::memcpy(&amp;nan,&#32;&amp;llnan,&#32;<emphasis role="keyword">sizeof</emphasis>(<emphasis role="keywordtype">double</emphasis>));
467 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;nan;
468 <emphasis role="preprocessor">#else</emphasis>
469 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;NAN;
470 <emphasis role="preprocessor">#endif</emphasis>
471 }
472 
473 <emphasis role="keyword">static</emphasis>&#32;<emphasis role="keywordtype">bool</emphasis>&#32;__testlib_isInfinite(<emphasis role="keywordtype">double</emphasis>&#32;r)&#32;{
474 &#32;&#32;&#32;&#32;<emphasis role="keyword">volatile</emphasis>&#32;<emphasis role="keywordtype">double</emphasis>&#32;ra&#32;=&#32;r;
475 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;(ra&#32;&gt;&#32;1E300&#32;||&#32;ra&#32;&lt;&#32;-1E300);
476 }
477 
478 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
479 __attribute__((<emphasis role="keyword">const</emphasis>))
480 <emphasis role="preprocessor">#endif</emphasis>
481 <emphasis role="keyword">inline</emphasis>&#32;<emphasis role="keywordtype">bool</emphasis>&#32;doubleCompare(<emphasis role="keywordtype">double</emphasis>&#32;expected,&#32;<emphasis role="keywordtype">double</emphasis>&#32;result,&#32;<emphasis role="keywordtype">double</emphasis>&#32;MAX_DOUBLE_ERROR)&#32;{
482 &#32;&#32;&#32;&#32;MAX_DOUBLE_ERROR&#32;+=&#32;1E-15;
483 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__testlib_isNaN(expected))&#32;{
484 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__testlib_isNaN(result);
485 &#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__testlib_isInfinite(expected))&#32;{
486 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(expected&#32;&gt;&#32;0)&#32;{
487 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;result&#32;&gt;&#32;0&#32;&amp;&amp;&#32;__testlib_isInfinite(result);
488 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
489 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;result&#32;&lt;&#32;0&#32;&amp;&amp;&#32;__testlib_isInfinite(result);
490 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
491 &#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__testlib_isNaN(result)&#32;||&#32;__testlib_isInfinite(result))&#32;{
492 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
493 &#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__testlib_abs(result&#32;-&#32;expected)&#32;&lt;=&#32;MAX_DOUBLE_ERROR)&#32;{
494 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">true</emphasis>;
495 &#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
496 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">double</emphasis>&#32;minv&#32;=&#32;__testlib_min(expected&#32;*&#32;(1.0&#32;-&#32;MAX_DOUBLE_ERROR),
497 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;expected&#32;*&#32;(1.0&#32;+&#32;MAX_DOUBLE_ERROR));
498 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">double</emphasis>&#32;maxv&#32;=&#32;__testlib_max(expected&#32;*&#32;(1.0&#32;-&#32;MAX_DOUBLE_ERROR),
499 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;expected&#32;*&#32;(1.0&#32;+&#32;MAX_DOUBLE_ERROR));
500 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;result&#32;&gt;=&#32;minv&#32;&amp;&amp;&#32;result&#32;&lt;=&#32;maxv;
501 &#32;&#32;&#32;&#32;}
502 }
503 
504 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
505 __attribute__((<emphasis role="keyword">const</emphasis>))
506 <emphasis role="preprocessor">#endif</emphasis>
507 <emphasis role="keyword">inline</emphasis>&#32;<emphasis role="keywordtype">double</emphasis>&#32;doubleDelta(<emphasis role="keywordtype">double</emphasis>&#32;expected,&#32;<emphasis role="keywordtype">double</emphasis>&#32;result)&#32;{
508 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">double</emphasis>&#32;absolute&#32;=&#32;__testlib_abs(result&#32;-&#32;expected);
509 
510 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__testlib_abs(expected)&#32;&gt;&#32;1E-9)&#32;{
511 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">double</emphasis>&#32;relative&#32;=&#32;__testlib_abs(absolute&#32;/&#32;expected);
512 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__testlib_min(absolute,&#32;relative);
513 &#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>
514 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;absolute;
515 }
516 
518 <emphasis role="keyword">static</emphasis>&#32;<emphasis role="keywordtype">void</emphasis>&#32;__testlib_set_binary(std::FILE&#32;*file)&#32;{
519 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(NULL&#32;!=&#32;file)&#32;{
520 <emphasis role="preprocessor">#ifdef&#32;ON_WINDOWS</emphasis>
521 <emphasis role="preprocessor">#&#32;&#32;&#32;ifdef&#32;_O_BINARY</emphasis>
522 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(stdin&#32;==&#32;file)
523 <emphasis role="preprocessor">#&#32;&#32;&#32;&#32;&#32;&#32;&#32;ifdef&#32;STDIN_FILENO</emphasis>
524 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;void(_setmode(STDIN_FILENO,&#32;_O_BINARY));
525 <emphasis role="preprocessor">#&#32;&#32;&#32;&#32;&#32;&#32;&#32;else</emphasis>
526 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;void(_setmode(_fileno(stdin),&#32;_O_BINARY));
527 <emphasis role="preprocessor">#&#32;&#32;&#32;&#32;&#32;&#32;&#32;endif</emphasis>
528 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(stdout&#32;==&#32;file)
529 <emphasis role="preprocessor">#&#32;&#32;&#32;&#32;&#32;&#32;&#32;ifdef&#32;STDOUT_FILENO</emphasis>
530 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;void(_setmode(STDOUT_FILENO,&#32;_O_BINARY));
531 <emphasis role="preprocessor">#&#32;&#32;&#32;&#32;&#32;&#32;&#32;else</emphasis>
532 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;void(_setmode(_fileno(stdout),&#32;_O_BINARY));
533 <emphasis role="preprocessor">#&#32;&#32;&#32;&#32;&#32;&#32;&#32;endif</emphasis>
534 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(stderr&#32;==&#32;file)
535 <emphasis role="preprocessor">#&#32;&#32;&#32;&#32;&#32;&#32;&#32;ifdef&#32;STDERR_FILENO</emphasis>
536 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;void(_setmode(STDERR_FILENO,&#32;_O_BINARY));
537 <emphasis role="preprocessor">#&#32;&#32;&#32;&#32;&#32;&#32;&#32;else</emphasis>
538 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;void(_setmode(_fileno(stderr),&#32;_O_BINARY));
539 <emphasis role="preprocessor">#&#32;&#32;&#32;&#32;&#32;&#32;&#32;endif</emphasis>
540 <emphasis role="preprocessor">#&#32;&#32;&#32;elif&#32;O_BINARY</emphasis>
541 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(stdin&#32;==&#32;file)
542 <emphasis role="preprocessor">#&#32;&#32;&#32;&#32;&#32;&#32;&#32;ifdef&#32;STDIN_FILENO</emphasis>
543 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;void(setmode(STDIN_FILENO,&#32;O_BINARY));
544 <emphasis role="preprocessor">#&#32;&#32;&#32;&#32;&#32;&#32;&#32;else</emphasis>
545 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;void(setmode(fileno(stdin),&#32;O_BINARY));
546 <emphasis role="preprocessor">#&#32;&#32;&#32;&#32;&#32;&#32;&#32;endif</emphasis>
547 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(stdout&#32;==&#32;file)
548 <emphasis role="preprocessor">#&#32;&#32;&#32;&#32;&#32;&#32;&#32;ifdef&#32;STDOUT_FILENO</emphasis>
549 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;void(setmode(STDOUT_FILENO,&#32;O_BINARY));
550 <emphasis role="preprocessor">#&#32;&#32;&#32;&#32;&#32;&#32;&#32;else</emphasis>
551 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;void(setmode(fileno(stdout),&#32;O_BINARY));
552 <emphasis role="preprocessor">#&#32;&#32;&#32;&#32;&#32;&#32;&#32;endif</emphasis>
553 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(stderr&#32;==&#32;file)
554 <emphasis role="preprocessor">#&#32;&#32;&#32;&#32;&#32;&#32;&#32;ifdef&#32;STDERR_FILENO</emphasis>
555 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;void(setmode(STDERR_FILENO,&#32;O_BINARY));
556 <emphasis role="preprocessor">#&#32;&#32;&#32;&#32;&#32;&#32;&#32;else</emphasis>
557 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;void(setmode(fileno(stderr),&#32;O_BINARY));
558 <emphasis role="preprocessor">#&#32;&#32;&#32;&#32;&#32;&#32;&#32;endif</emphasis>
559 <emphasis role="preprocessor">#&#32;&#32;&#32;endif</emphasis>
560 <emphasis role="preprocessor">#endif</emphasis>
561 &#32;&#32;&#32;&#32;}
562 }
563 
564 <emphasis role="preprocessor">#if&#32;__cplusplus&#32;&gt;&#32;199711L&#32;||&#32;defined(_MSC_VER)</emphasis>
565 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Tp&gt;
566 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
567 __attribute__((<emphasis role="keyword">const</emphasis>))
568 <emphasis role="preprocessor">#endif</emphasis>
569 <emphasis role="keyword">static</emphasis>&#32;std::string&#32;vtos(<emphasis role="keyword">const</emphasis>&#32;_Tp&#32;&amp;t,&#32;std::true_type)&#32;{
570 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(t&#32;==&#32;0)
571 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="stringliteral">&quot;0&quot;</emphasis>;
572 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
573 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Tp&#32;n(t);
574 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;negative&#32;=&#32;n&#32;&lt;&#32;0;
575 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::string&#32;s;
576 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">while</emphasis>&#32;(n&#32;!=&#32;0)&#32;{
577 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Tp&#32;digit&#32;=&#32;n&#32;%&#32;10;
578 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(digit&#32;&lt;&#32;0)
579 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;digit&#32;=&#32;-digit;
580 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;s&#32;+=&#32;char(<emphasis role="charliteral">&apos;0&apos;</emphasis>&#32;+&#32;digit);
581 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;n&#32;/=&#32;10;
582 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
583 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::reverse(s.begin(),&#32;s.end());
584 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;negative&#32;?&#32;<emphasis role="stringliteral">&quot;-&quot;</emphasis>&#32;+&#32;s&#32;:&#32;s;
585 &#32;&#32;&#32;&#32;}
586 }
587 
588 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Tp&gt;
589 <emphasis role="keyword">static</emphasis>&#32;std::string&#32;vtos(<emphasis role="keyword">const</emphasis>&#32;_Tp&#32;&amp;t,&#32;std::false_type)&#32;{
590 &#32;&#32;&#32;&#32;std::string&#32;s;
591 &#32;&#32;&#32;&#32;<emphasis role="keyword">static</emphasis>&#32;std::stringstream&#32;ss;
592 &#32;&#32;&#32;&#32;ss.str(std::string());
593 &#32;&#32;&#32;&#32;ss.clear();
594 &#32;&#32;&#32;&#32;ss&#32;&lt;&lt;&#32;t;
595 &#32;&#32;&#32;&#32;ss&#32;&gt;&gt;&#32;s;
596 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;s;
597 }
598 
599 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Tp&gt;
600 <emphasis role="keyword">static</emphasis>&#32;std::string&#32;vtos(<emphasis role="keyword">const</emphasis>&#32;_Tp&#32;&amp;t)&#32;{
601 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;vtos(t,&#32;std::is_integral&lt;_Tp&gt;());
602 }
603 
604 <emphasis role="comment">/*&#32;signed&#32;case.&#32;*/</emphasis>
605 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Tp&gt;
606 <emphasis role="keyword">static</emphasis>&#32;std::string&#32;toHumanReadableString(<emphasis role="keyword">const</emphasis>&#32;_Tp&#32;&amp;n,&#32;std::false_type)&#32;{
607 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(n&#32;==&#32;0)
608 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;vtos(n);
609 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;trailingZeroCount&#32;=&#32;0;
610 &#32;&#32;&#32;&#32;_Tp&#32;n_&#32;=&#32;n;
611 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">while</emphasis>&#32;(n_&#32;%&#32;10&#32;==&#32;0)
612 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;n_&#32;/=&#32;10,&#32;trailingZeroCount++;
613 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(trailingZeroCount&#32;&gt;=&#32;7)&#32;{
614 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(n_&#32;==&#32;1)
615 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="stringliteral">&quot;10^&quot;</emphasis>&#32;+&#32;vtos(trailingZeroCount);
616 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="keywordflow">if</emphasis>&#32;(n_&#32;==&#32;-1)
617 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="stringliteral">&quot;-10^&quot;</emphasis>&#32;+&#32;vtos(trailingZeroCount);
618 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
619 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;vtos(n_)&#32;+&#32;<emphasis role="stringliteral">&quot;*10^&quot;</emphasis>&#32;+&#32;vtos(trailingZeroCount);
620 &#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>
621 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;vtos(n);
622 }
623 
624 <emphasis role="comment">/*&#32;unsigned&#32;case.&#32;*/</emphasis>
625 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Tp&gt;
626 <emphasis role="keyword">static</emphasis>&#32;std::string&#32;toHumanReadableString(<emphasis role="keyword">const</emphasis>&#32;_Tp&#32;&amp;n,&#32;std::true_type)&#32;{
627 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(n&#32;==&#32;0)
628 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;vtos(n);
629 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;trailingZeroCount&#32;=&#32;0;
630 &#32;&#32;&#32;&#32;_Tp&#32;n_&#32;=&#32;n;
631 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">while</emphasis>&#32;(n_&#32;%&#32;10&#32;==&#32;0)
632 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;n_&#32;/=&#32;10,&#32;trailingZeroCount++;
633 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(trailingZeroCount&#32;&gt;=&#32;7)&#32;{
634 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(n_&#32;==&#32;1)
635 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="stringliteral">&quot;10^&quot;</emphasis>&#32;+&#32;vtos(trailingZeroCount);
636 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
637 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;vtos(n_)&#32;+&#32;<emphasis role="stringliteral">&quot;*10^&quot;</emphasis>&#32;+&#32;vtos(trailingZeroCount);
638 &#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>
639 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;vtos(n);
640 }
641 
642 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Tp&gt;
643 <emphasis role="keyword">static</emphasis>&#32;std::string&#32;toHumanReadableString(<emphasis role="keyword">const</emphasis>&#32;_Tp&#32;&amp;n)&#32;{
644 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;toHumanReadableString(n,&#32;std::is_unsigned&lt;_Tp&gt;());
645 }
646 <emphasis role="preprocessor">#else</emphasis>
647 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;T&gt;
648 <emphasis role="keyword">static</emphasis>&#32;std::string&#32;vtos(<emphasis role="keyword">const</emphasis>&#32;T&amp;&#32;t)
649 {
650 &#32;&#32;&#32;&#32;std::string&#32;s;
651 &#32;&#32;&#32;&#32;<emphasis role="keyword">static</emphasis>&#32;std::stringstream&#32;ss;
652 &#32;&#32;&#32;&#32;ss.str(std::string());
653 &#32;&#32;&#32;&#32;ss.clear();
654 &#32;&#32;&#32;&#32;ss&#32;&lt;&lt;&#32;t;
655 &#32;&#32;&#32;&#32;ss&#32;&gt;&gt;&#32;s;
656 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;s;
657 }
658 
659 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;T&gt;
660 <emphasis role="keyword">static</emphasis>&#32;std::string&#32;toHumanReadableString(<emphasis role="keyword">const</emphasis>&#32;T&#32;&amp;n)&#32;{
661 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;vtos(n);
662 }
663 <emphasis role="preprocessor">#endif</emphasis>
664 
665 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Tp&gt;
666 <emphasis role="keyword">static</emphasis>&#32;std::string&#32;toString(<emphasis role="keyword">const</emphasis>&#32;_Tp&#32;&amp;t)&#32;{
667 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;vtos(t);
668 }
669 
670 <emphasis role="preprocessor">#if&#32;__cplusplus&#32;&gt;&#32;199711L&#32;||&#32;defined(_MSC_VER)</emphasis>
671 <emphasis role="comment">/*&#32;opts&#32;*/</emphasis>
672 <emphasis role="keywordtype">void</emphasis>&#32;prepareOpts(<emphasis role="keywordtype">int</emphasis>&#32;argc,&#32;<emphasis role="keywordtype">char</emphasis>*&#32;argv[]);
673 <emphasis role="preprocessor">#endif</emphasis>
674 
675 <emphasis role="comment">/*</emphasis>
676 <emphasis role="comment">&#32;*&#32;Very&#32;simple&#32;regex-like&#32;pattern.</emphasis>
677 <emphasis role="comment">&#32;*&#32;It&#32;used&#32;for&#32;two&#32;purposes:&#32;validation&#32;and&#32;generation.</emphasis>
678 <emphasis role="comment">&#32;*</emphasis>
679 <emphasis role="comment">&#32;*&#32;For&#32;example,&#32;pattern(&quot;[a-z]{1,5}&quot;).next(rnd)&#32;will&#32;return</emphasis>
680 <emphasis role="comment">&#32;*&#32;random&#32;string&#32;from&#32;lowercase&#32;latin&#32;letters&#32;with&#32;length</emphasis>
681 <emphasis role="comment">&#32;*&#32;from&#32;1&#32;to&#32;5.&#32;It&#32;is&#32;easier&#32;to&#32;call&#32;rnd.next(&quot;[a-z]{1,5}&quot;)</emphasis>
682 <emphasis role="comment">&#32;*&#32;for&#32;the&#32;same&#32;effect.</emphasis>
683 <emphasis role="comment">&#32;*</emphasis>
684 <emphasis role="comment">&#32;*&#32;Another&#32;samples:</emphasis>
685 <emphasis role="comment">&#32;*&#32;&quot;mike|john&quot;&#32;will&#32;generate&#32;(match)&#32;&quot;mike&quot;&#32;or&#32;&quot;john&quot;;</emphasis>
686 <emphasis role="comment">&#32;*&#32;&quot;-?[1-9][0-9]{0,3}&quot;&#32;will&#32;generate&#32;(match)&#32;non-zero&#32;integers&#32;from&#32;-9999&#32;to&#32;9999;</emphasis>
687 <emphasis role="comment">&#32;*&#32;&quot;id-([ac]|b{2})&quot;&#32;will&#32;generate&#32;(match)&#32;&quot;id-a&quot;,&#32;&quot;id-bb&quot;,&#32;&quot;id-c&quot;;</emphasis>
688 <emphasis role="comment">&#32;*&#32;&quot;[^0-9]*&quot;&#32;will&#32;match&#32;sequences&#32;(empty&#32;or&#32;non-empty)&#32;without&#32;digits,&#32;you&#32;can&apos;t</emphasis>
689 <emphasis role="comment">&#32;*&#32;use&#32;it&#32;for&#32;generations.</emphasis>
690 <emphasis role="comment">&#32;*</emphasis>
691 <emphasis role="comment">&#32;*&#32;You&#32;can&apos;t&#32;use&#32;pattern&#32;for&#32;generation&#32;if&#32;it&#32;contains&#32;meta-symbol&#32;&apos;*&apos;.&#32;Also&#32;it</emphasis>
692 <emphasis role="comment">&#32;*&#32;is&#32;not&#32;recommended&#32;to&#32;use&#32;it&#32;for&#32;char-sets&#32;with&#32;meta-symbol&#32;&apos;^&apos;&#32;like&#32;[^a-z].</emphasis>
693 <emphasis role="comment">&#32;*</emphasis>
694 <emphasis role="comment">&#32;*&#32;For&#32;matching&#32;very&#32;simple&#32;greedy&#32;algorithm&#32;is&#32;used.&#32;For&#32;example,&#32;pattern</emphasis>
695 <emphasis role="comment">&#32;*&#32;&quot;[0-9]?1&quot;&#32;will&#32;not&#32;match&#32;&quot;1&quot;,&#32;because&#32;of&#32;greedy&#32;nature&#32;of&#32;matching.</emphasis>
696 <emphasis role="comment">&#32;*&#32;Alternations&#32;(meta-symbols&#32;&quot;|&quot;)&#32;are&#32;processed&#32;with&#32;brute-force&#32;algorithm,&#32;so</emphasis>
697 <emphasis role="comment">&#32;*&#32;do&#32;not&#32;use&#32;many&#32;alternations&#32;in&#32;one&#32;expression.</emphasis>
698 <emphasis role="comment">&#32;*</emphasis>
699 <emphasis role="comment">&#32;*&#32;If&#32;you&#32;want&#32;to&#32;use&#32;one&#32;expression&#32;many&#32;times&#32;it&#32;is&#32;better&#32;to&#32;compile&#32;it&#32;into</emphasis>
700 <emphasis role="comment">&#32;*&#32;a&#32;single&#32;pattern&#32;like&#32;&quot;pattern&#32;p(&quot;[a-z]+&quot;)&quot;.&#32;Later&#32;you&#32;can&#32;use</emphasis>
701 <emphasis role="comment">&#32;*&#32;&quot;p.matches(std::string&#32;s)&quot;&#32;or&#32;&quot;p.next(random_t&amp;&#32;rd)&quot;&#32;to&#32;check&#32;matching&#32;or&#32;generate</emphasis>
702 <emphasis role="comment">&#32;*&#32;new&#32;string&#32;by&#32;pattern.</emphasis>
703 <emphasis role="comment">&#32;*</emphasis>
704 <emphasis role="comment">&#32;*&#32;Simpler&#32;way&#32;to&#32;read&#32;token&#32;and&#32;check&#32;it&#32;for&#32;pattern&#32;matching&#32;is&#32;&quot;inf.readToken(&quot;[a-z]+&quot;)&quot;.</emphasis>
705 <emphasis role="comment">&#32;*</emphasis>
706 <emphasis role="comment">&#32;*&#32;All&#32;spaces&#32;are&#32;ignored&#32;in&#32;regex,&#32;unless&#32;escaped&#32;with&#32;\.&#32;For&#32;example,&#32;ouf.readLine(&quot;NO&#32;SOLUTION&quot;)</emphasis>
707 <emphasis role="comment">&#32;*&#32;will&#32;expect&#32;&quot;NOSOLUTION&quot;,&#32;the&#32;correct&#32;call&#32;should&#32;be&#32;ouf.readLine(&quot;NO\\&#32;SOLUTION&quot;)&#32;or</emphasis>
708 <emphasis role="comment">&#32;*&#32;ouf.readLine(R&quot;(NO\&#32;SOLUTION)&quot;)&#32;if&#32;you&#32;prefer&#32;raw&#32;string&#32;literals&#32;from&#32;C++11.</emphasis>
709 <emphasis role="comment">&#32;*/</emphasis>
710 <emphasis role="keyword">class&#32;</emphasis><link linkend="_classrandom__t">random_t</link>;
711 
712 <emphasis role="keyword">class&#32;</emphasis><link linkend="_classpattern">pattern</link>&#32;{
713 <emphasis role="keyword">public</emphasis>:
714 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Create&#32;pattern&#32;instance&#32;by&#32;string.&#32;*/</emphasis>
715 &#32;&#32;&#32;&#32;<link linkend="_classpattern">pattern</link>(std::string&#32;s);
716 
717 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Generate&#32;new&#32;string&#32;by&#32;pattern&#32;and&#32;given&#32;random_t.&#32;*/</emphasis>
718 &#32;&#32;&#32;&#32;std::string&#32;next(<link linkend="_classrandom__t">random_t</link>&#32;&amp;rnd)&#32;<emphasis role="keyword">const</emphasis>;
719 
720 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Checks&#32;if&#32;given&#32;string&#32;match&#32;the&#32;pattern.&#32;*/</emphasis>
721 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;matches(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;s)&#32;<emphasis role="keyword">const</emphasis>;
722 
723 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Returns&#32;source&#32;string&#32;of&#32;the&#32;pattern.&#32;*/</emphasis>
724 &#32;&#32;&#32;&#32;std::string&#32;src()&#32;<emphasis role="keyword">const</emphasis>;
725 
726 <emphasis role="keyword">private</emphasis>:
727 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;matches(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;s,&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;pos)&#32;<emphasis role="keyword">const</emphasis>;
728 
729 &#32;&#32;&#32;&#32;std::string&#32;s;
730 &#32;&#32;&#32;&#32;std::vector&lt;pattern&gt;&#32;children;
731 &#32;&#32;&#32;&#32;std::vector&lt;char&gt;&#32;chars;
732 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;from;
733 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;to;
734 };
735 
736 <emphasis role="comment">/*</emphasis>
737 <emphasis role="comment">&#32;*&#32;Use&#32;random_t&#32;instances&#32;to&#32;generate&#32;random&#32;values.&#32;It&#32;is&#32;preferred</emphasis>
738 <emphasis role="comment">&#32;*&#32;way&#32;to&#32;use&#32;randoms&#32;instead&#32;of&#32;rand()&#32;function&#32;or&#32;self-written</emphasis>
739 <emphasis role="comment">&#32;*&#32;randoms.</emphasis>
740 <emphasis role="comment">&#32;*</emphasis>
741 <emphasis role="comment">&#32;*&#32;Testlib&#32;defines&#32;global&#32;variable&#32;&quot;rnd&quot;&#32;of&#32;random_t&#32;class.</emphasis>
742 <emphasis role="comment">&#32;*&#32;Use&#32;registerGen(argc,&#32;argv,&#32;1)&#32;to&#32;setup&#32;random_t&#32;seed&#32;be&#32;command</emphasis>
743 <emphasis role="comment">&#32;*&#32;line&#32;(to&#32;use&#32;latest&#32;random&#32;generator&#32;version).</emphasis>
744 <emphasis role="comment">&#32;*</emphasis>
745 <emphasis role="comment">&#32;*&#32;Random&#32;generates&#32;uniformly&#32;distributed&#32;values&#32;if&#32;another&#32;strategy&#32;is</emphasis>
746 <emphasis role="comment">&#32;*&#32;not&#32;specified&#32;explicitly.</emphasis>
747 <emphasis role="comment">&#32;*/</emphasis>
748 <emphasis role="keyword">class&#32;</emphasis><link linkend="_classrandom__t">random_t</link>&#32;{
749 <emphasis role="keyword">private</emphasis>:
750 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;seed;
751 &#32;&#32;&#32;&#32;<emphasis role="keyword">static</emphasis>&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;multiplier;
752 &#32;&#32;&#32;&#32;<emphasis role="keyword">static</emphasis>&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;addend;
753 &#32;&#32;&#32;&#32;<emphasis role="keyword">static</emphasis>&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;mask;
754 &#32;&#32;&#32;&#32;<emphasis role="keyword">static</emphasis>&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">int</emphasis>&#32;lim;
755 
756 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;nextBits(<emphasis role="keywordtype">int</emphasis>&#32;bits)&#32;{
757 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(bits&#32;&lt;=&#32;48)&#32;{
758 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;seed&#32;=&#32;(seed&#32;*&#32;multiplier&#32;+&#32;addend)&#32;&amp;&#32;mask;
759 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;(<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>)&#32;(seed&#32;&gt;&gt;&#32;(48&#32;-&#32;bits));
760 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
761 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(bits&#32;&gt;&#32;63)
762 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;random_t::nextBits(int&#32;bits):&#32;n&#32;must&#32;be&#32;less&#32;than&#32;64&quot;</emphasis>);
763 
764 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;lowerBitCount&#32;=&#32;(random_t::version&#32;==&#32;0&#32;?&#32;31&#32;:&#32;32);
765 
766 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;left&#32;=&#32;(nextBits(31)&#32;&lt;&lt;&#32;32);
767 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;right&#32;=&#32;nextBits(lowerBitCount);
768 
769 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;left&#32;^&#32;right;
770 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
771 &#32;&#32;&#32;&#32;}
772 
773 <emphasis role="keyword">public</emphasis>:
774 &#32;&#32;&#32;&#32;<emphasis role="keyword">static</emphasis>&#32;<emphasis role="keywordtype">int</emphasis>&#32;version;
775 
776 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;New&#32;random_t&#32;with&#32;fixed&#32;seed.&#32;*/</emphasis>
777 &#32;&#32;&#32;&#32;<link linkend="_classrandom__t">random_t</link>()
778 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;:&#32;seed(3905348978240129619LL)&#32;{
779 &#32;&#32;&#32;&#32;}
780 
781 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Sets&#32;seed&#32;by&#32;command&#32;line.&#32;*/</emphasis>
782 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;setSeed(<emphasis role="keywordtype">int</emphasis>&#32;argc,&#32;<emphasis role="keywordtype">char</emphasis>&#32;*argv[])&#32;{
783 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<link linkend="_classrandom__t">random_t</link>&#32;p;
784 
785 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;seed&#32;=&#32;3905348978240129619LL;
786 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">int</emphasis>&#32;i&#32;=&#32;1;&#32;i&#32;&lt;&#32;argc;&#32;i++)&#32;{
787 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::size_t&#32;le&#32;=&#32;std::strlen(argv[i]);
788 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(std::size_t&#32;j&#32;=&#32;0;&#32;j&#32;&lt;&#32;le;&#32;j++)
789 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;seed&#32;=&#32;seed&#32;*&#32;multiplier&#32;+&#32;(<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">int</emphasis>)&#32;(argv[i][j])&#32;+&#32;addend;
790 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;seed&#32;+=&#32;multiplier&#32;/&#32;addend;
791 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
792 
793 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;seed&#32;=&#32;seed&#32;&amp;&#32;mask;
794 &#32;&#32;&#32;&#32;}
795 
796 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Sets&#32;seed&#32;by&#32;given&#32;value.&#32;*/</emphasis>
797 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;setSeed(<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;_seed)&#32;{
798 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;seed&#32;=&#32;(<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;long)&#32;_seed;
799 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;seed&#32;=&#32;(seed&#32;^&#32;multiplier)&#32;&amp;&#32;mask;
800 &#32;&#32;&#32;&#32;}
801 
802 <emphasis role="preprocessor">#ifndef&#32;__BORLANDC__</emphasis>
803 
804 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Random&#32;string&#32;value&#32;by&#32;given&#32;pattern&#32;(see&#32;pattern&#32;documentation).&#32;*/</emphasis>
805 &#32;&#32;&#32;&#32;std::string&#32;next(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;ptrn)&#32;{
806 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<link linkend="_classpattern">pattern</link>&#32;p(ptrn);
807 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;p.next(*<emphasis role="keyword">this</emphasis>);
808 &#32;&#32;&#32;&#32;}
809 
810 <emphasis role="preprocessor">#else</emphasis>
811 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Random&#32;string&#32;value&#32;by&#32;given&#32;pattern&#32;(see&#32;pattern&#32;documentation).&#32;*/</emphasis>
812 &#32;&#32;&#32;&#32;std::string&#32;next(std::string&#32;ptrn)
813 &#32;&#32;&#32;&#32;{
814 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<link linkend="_classpattern">pattern</link>&#32;p(ptrn);
815 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;p.next(*<emphasis role="keyword">this</emphasis>);
816 &#32;&#32;&#32;&#32;}
817 <emphasis role="preprocessor">#endif</emphasis>
818 
819 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Random&#32;value&#32;in&#32;range&#32;[0,&#32;n-1].&#32;*/</emphasis>
820 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;next(<emphasis role="keywordtype">int</emphasis>&#32;n)&#32;{
821 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(n&#32;&lt;=&#32;0)
822 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;random_t::next(int&#32;n):&#32;n&#32;must&#32;be&#32;positive&quot;</emphasis>);
823 
824 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;((n&#32;&amp;&#32;-n)&#32;==&#32;n)&#32;&#32;<emphasis role="comment">//&#32;n&#32;is&#32;a&#32;power&#32;of&#32;2</emphasis>
825 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;(<emphasis role="keywordtype">int</emphasis>)&#32;((n&#32;*&#32;(<emphasis role="keywordtype">long</emphasis>&#32;long)&#32;nextBits(31))&#32;&gt;&gt;&#32;31);
826 
827 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;limit&#32;=&#32;INT_MAX&#32;/&#32;n&#32;*&#32;n;
828 
829 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;bits;
830 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">do</emphasis>&#32;{
831 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;bits&#32;=&#32;nextBits(31);
832 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">while</emphasis>&#32;(bits&#32;&gt;=&#32;limit);
833 
834 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;int(bits&#32;%&#32;n);
835 &#32;&#32;&#32;&#32;}
836 
837 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Random&#32;value&#32;in&#32;range&#32;[0,&#32;n-1].&#32;*/</emphasis>
838 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">int</emphasis>&#32;next(<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">int</emphasis>&#32;n)&#32;{
839 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(n&#32;&gt;=&#32;INT_MAX)
840 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;random_t::next(unsigned&#32;int&#32;n):&#32;n&#32;must&#32;be&#32;less&#32;INT_MAX&quot;</emphasis>);
841 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;(<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">int</emphasis>)&#32;next(<emphasis role="keywordtype">int</emphasis>(n));
842 &#32;&#32;&#32;&#32;}
843 
844 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Random&#32;value&#32;in&#32;range&#32;[0,&#32;n-1].&#32;*/</emphasis>
845 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;next(<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;n)&#32;{
846 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(n&#32;&lt;=&#32;0)
847 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;random_t::next(long&#32;long&#32;n):&#32;n&#32;must&#32;be&#32;positive&quot;</emphasis>);
848 
849 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;limit&#32;=&#32;__TESTLIB_LONGLONG_MAX&#32;/&#32;n&#32;*&#32;n;
850 
851 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;bits;
852 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">do</emphasis>&#32;{
853 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;bits&#32;=&#32;nextBits(63);
854 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">while</emphasis>&#32;(bits&#32;&gt;=&#32;limit);
855 
856 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;bits&#32;%&#32;n;
857 &#32;&#32;&#32;&#32;}
858 
859 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Random&#32;value&#32;in&#32;range&#32;[0,&#32;n-1].&#32;*/</emphasis>
860 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;next(<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;n)&#32;{
861 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(n&#32;&gt;=&#32;(<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>)&#32;(__TESTLIB_LONGLONG_MAX))
862 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;random_t::next(unsigned&#32;long&#32;long&#32;n):&#32;n&#32;must&#32;be&#32;less&#32;LONGLONG_MAX&quot;</emphasis>);
863 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;(<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>)&#32;next((<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>)&#32;(n));
864 &#32;&#32;&#32;&#32;}
865 
866 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Random&#32;value&#32;in&#32;range&#32;[0,&#32;n-1].&#32;*/</emphasis>
867 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">long</emphasis>&#32;next(<emphasis role="keywordtype">long</emphasis>&#32;n)&#32;{
868 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;(<emphasis role="keywordtype">long</emphasis>)&#32;next((<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>)&#32;(n));
869 &#32;&#32;&#32;&#32;}
870 
871 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Random&#32;value&#32;in&#32;range&#32;[0,&#32;n-1].&#32;*/</emphasis>
872 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;next(<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;n)&#32;{
873 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(n&#32;&gt;=&#32;(<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>)&#32;(LONG_MAX))
874 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;random_t::next(unsigned&#32;long&#32;n):&#32;n&#32;must&#32;be&#32;less&#32;LONG_MAX&quot;</emphasis>);
875 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;(<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>)&#32;next((<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>)&#32;(n));
876 &#32;&#32;&#32;&#32;}
877 
878 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Returns&#32;random&#32;value&#32;in&#32;range&#32;[from,to].&#32;*/</emphasis>
879 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;next(<emphasis role="keywordtype">int</emphasis>&#32;from,&#32;<emphasis role="keywordtype">int</emphasis>&#32;to)&#32;{
880 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;int(next((<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>)&#32;to&#32;-&#32;from&#32;+&#32;1)&#32;+&#32;from);
881 &#32;&#32;&#32;&#32;}
882 
883 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Returns&#32;random&#32;value&#32;in&#32;range&#32;[from,to].&#32;*/</emphasis>
884 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">int</emphasis>&#32;next(<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">int</emphasis>&#32;from,&#32;<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">int</emphasis>&#32;to)&#32;{
885 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;(<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">int</emphasis>)&#32;(next((<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>)&#32;to&#32;-&#32;from&#32;+&#32;1)&#32;+&#32;from);
886 &#32;&#32;&#32;&#32;}
887 
888 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Returns&#32;random&#32;value&#32;in&#32;range&#32;[from,to].&#32;*/</emphasis>
889 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;next(<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;from,&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;to)&#32;{
890 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;next(to&#32;-&#32;from&#32;+&#32;1)&#32;+&#32;from;
891 &#32;&#32;&#32;&#32;}
892 
893 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Returns&#32;random&#32;value&#32;in&#32;range&#32;[from,to].&#32;*/</emphasis>
894 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;next(<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;from,&#32;<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;to)&#32;{
895 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(from&#32;&gt;&#32;to)
896 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;random_t::next(unsigned&#32;long&#32;long&#32;from,&#32;unsigned&#32;long&#32;long&#32;to):&#32;from&#32;can&apos;t&#32;not&#32;exceed&#32;to&quot;</emphasis>);
897 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;next(to&#32;-&#32;from&#32;+&#32;1)&#32;+&#32;from;
898 &#32;&#32;&#32;&#32;}
899 
900 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Returns&#32;random&#32;value&#32;in&#32;range&#32;[from,to].&#32;*/</emphasis>
901 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">long</emphasis>&#32;next(<emphasis role="keywordtype">long</emphasis>&#32;from,&#32;<emphasis role="keywordtype">long</emphasis>&#32;to)&#32;{
902 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;next(to&#32;-&#32;from&#32;+&#32;1)&#32;+&#32;from;
903 &#32;&#32;&#32;&#32;}
904 
905 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Returns&#32;random&#32;value&#32;in&#32;range&#32;[from,to].&#32;*/</emphasis>
906 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;next(<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;from,&#32;<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;to)&#32;{
907 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(from&#32;&gt;&#32;to)
908 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;random_t::next(unsigned&#32;long&#32;from,&#32;unsigned&#32;long&#32;to):&#32;from&#32;can&apos;t&#32;not&#32;exceed&#32;to&quot;</emphasis>);
909 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;next(to&#32;-&#32;from&#32;+&#32;1)&#32;+&#32;from;
910 &#32;&#32;&#32;&#32;}
911 
912 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Random&#32;double&#32;value&#32;in&#32;range&#32;[0,&#32;1).&#32;*/</emphasis>
913 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">double</emphasis>&#32;next()&#32;{
914 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;left&#32;=&#32;((<emphasis role="keywordtype">long</emphasis>&#32;long)&#32;(nextBits(26))&#32;&lt;&lt;&#32;27);
915 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;right&#32;=&#32;nextBits(27);
916 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__testlib_crop((<emphasis role="keywordtype">double</emphasis>)&#32;(left&#32;+&#32;right)&#32;/&#32;(<emphasis role="keywordtype">double</emphasis>)&#32;(1LL&#32;&lt;&lt;&#32;53),&#32;0.0,&#32;1.0);
917 &#32;&#32;&#32;&#32;}
918 
919 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Random&#32;double&#32;value&#32;in&#32;range&#32;[0,&#32;n).&#32;*/</emphasis>
920 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">double</emphasis>&#32;next(<emphasis role="keywordtype">double</emphasis>&#32;n)&#32;{
921 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(n&#32;&lt;=&#32;0.0)
922 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;random_t::next(double):&#32;n&#32;should&#32;be&#32;positive&quot;</emphasis>);
923 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__testlib_crop(n&#32;*&#32;next(),&#32;0.0,&#32;n);
924 &#32;&#32;&#32;&#32;}
925 
926 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Random&#32;double&#32;value&#32;in&#32;range&#32;[from,&#32;to).&#32;*/</emphasis>
927 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">double</emphasis>&#32;next(<emphasis role="keywordtype">double</emphasis>&#32;from,&#32;<emphasis role="keywordtype">double</emphasis>&#32;to)&#32;{
928 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(from&#32;&gt;=&#32;to)
929 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;random_t::next(double&#32;from,&#32;double&#32;to):&#32;from&#32;should&#32;be&#32;strictly&#32;less&#32;than&#32;to&quot;</emphasis>);
930 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;next(to&#32;-&#32;from)&#32;+&#32;from;
931 &#32;&#32;&#32;&#32;}
932 
933 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Returns&#32;random&#32;element&#32;from&#32;container.&#32;*/</emphasis>
934 &#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;Container&gt;
935 &#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;Container::value_type&#32;any(<emphasis role="keyword">const</emphasis>&#32;Container&#32;&amp;c)&#32;{
936 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;size&#32;=&#32;int(c.size());
937 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(size&#32;&lt;=&#32;0)
938 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;random_t::any(const&#32;Container&amp;&#32;c):&#32;c.size()&#32;must&#32;be&#32;positive&quot;</emphasis>);
939 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;Container::const_iterator&#32;it&#32;=&#32;c.begin();
940 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::advance(it,&#32;next(size));
941 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;*it;
942 &#32;&#32;&#32;&#32;}
943 
944 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Returns&#32;random&#32;element&#32;from&#32;iterator&#32;range.&#32;*/</emphasis>
945 &#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;Iter&gt;
946 &#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;Iter::value_type&#32;any(<emphasis role="keyword">const</emphasis>&#32;Iter&#32;&amp;begin,&#32;<emphasis role="keyword">const</emphasis>&#32;Iter&#32;&amp;end)&#32;{
947 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;size&#32;=&#32;<emphasis role="keyword">static_cast&lt;</emphasis><emphasis role="keywordtype">int</emphasis><emphasis role="keyword">&gt;</emphasis>(std::distance(begin,&#32;end));
948 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(size&#32;&lt;=&#32;0)
949 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;random_t::any(const&#32;Iter&amp;&#32;begin,&#32;const&#32;Iter&amp;&#32;end):&#32;range&#32;must&#32;have&#32;positive&#32;length&quot;</emphasis>);
950 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;Iter&#32;it&#32;=&#32;begin;
951 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::advance(it,&#32;next(size));
952 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;*it;
953 &#32;&#32;&#32;&#32;}
954 
955 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Random&#32;string&#32;value&#32;by&#32;given&#32;pattern&#32;(see&#32;pattern&#32;documentation).&#32;*/</emphasis>
956 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
957 &#32;&#32;&#32;&#32;__attribute__&#32;((format&#32;(printf,&#32;2,&#32;3)))
958 <emphasis role="preprocessor">#endif</emphasis>
959 &#32;&#32;&#32;&#32;std::string&#32;next(<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*format,&#32;...)&#32;{
960 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;FMT_TO_RESULT(format,&#32;format,&#32;ptrn);
961 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;next(ptrn);
962 &#32;&#32;&#32;&#32;}
963 
964 &#32;&#32;&#32;&#32;<emphasis role="comment">/*</emphasis>
965 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*&#32;Weighted&#32;next.&#32;If&#32;type&#32;==&#32;0&#32;than&#32;it&#32;is&#32;usual&#32;&quot;next()&quot;.</emphasis>
966 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*</emphasis>
967 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*&#32;If&#32;type&#32;=&#32;1,&#32;than&#32;it&#32;returns&#32;&quot;max(next(),&#32;next())&quot;</emphasis>
968 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*&#32;(the&#32;number&#32;of&#32;&quot;max&quot;&#32;functions&#32;equals&#32;to&#32;&quot;type&quot;).</emphasis>
969 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*</emphasis>
970 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*&#32;If&#32;type&#32;&lt;&#32;0,&#32;than&#32;&quot;max&quot;&#32;function&#32;replaces&#32;with&#32;&quot;min&quot;.</emphasis>
971 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*/</emphasis>
972 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;wnext(<emphasis role="keywordtype">int</emphasis>&#32;n,&#32;<emphasis role="keywordtype">int</emphasis>&#32;type)&#32;{
973 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(n&#32;&lt;=&#32;0)
974 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;random_t::wnext(int&#32;n,&#32;int&#32;type):&#32;n&#32;must&#32;be&#32;positive&quot;</emphasis>);
975 
976 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(abs(type)&#32;&lt;&#32;random_t::lim)&#32;{
977 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;result&#32;=&#32;next(n);
978 
979 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">int</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;+type;&#32;i++)
980 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result&#32;=&#32;__testlib_max(result,&#32;next(n));
981 
982 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">int</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;-type;&#32;i++)
983 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result&#32;=&#32;__testlib_min(result,&#32;next(n));
984 
985 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;result;
986 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
987 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">double</emphasis>&#32;p;
988 
989 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(type&#32;&gt;&#32;0)
990 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;p&#32;=&#32;std::pow(next()&#32;+&#32;0.0,&#32;1.0&#32;/&#32;(type&#32;+&#32;1));
991 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
992 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;p&#32;=&#32;1&#32;-&#32;std::pow(next()&#32;+&#32;0.0,&#32;1.0&#32;/&#32;(-type&#32;+&#32;1));
993 
994 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__testlib_crop((<emphasis role="keywordtype">int</emphasis>)&#32;(<emphasis role="keywordtype">double</emphasis>(n)&#32;*&#32;p),&#32;0,&#32;n);
995 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
996 &#32;&#32;&#32;&#32;}
997 
998 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;See&#32;wnext(int,&#32;int).&#32;It&#32;uses&#32;the&#32;same&#32;algorithms.&#32;*/</emphasis>
999 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;wnext(<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;n,&#32;<emphasis role="keywordtype">int</emphasis>&#32;type)&#32;{
1000 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(n&#32;&lt;=&#32;0)
1001 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;random_t::wnext(long&#32;long&#32;n,&#32;int&#32;type):&#32;n&#32;must&#32;be&#32;positive&quot;</emphasis>);
1002 
1003 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(abs(type)&#32;&lt;&#32;random_t::lim)&#32;{
1004 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;result&#32;=&#32;next(n);
1005 
1006 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">int</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;+type;&#32;i++)
1007 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result&#32;=&#32;__testlib_max(result,&#32;next(n));
1008 
1009 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">int</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;-type;&#32;i++)
1010 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result&#32;=&#32;__testlib_min(result,&#32;next(n));
1011 
1012 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;result;
1013 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
1014 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">double</emphasis>&#32;p;
1015 
1016 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(type&#32;&gt;&#32;0)
1017 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;p&#32;=&#32;std::pow(next()&#32;+&#32;0.0,&#32;1.0&#32;/&#32;(type&#32;+&#32;1));
1018 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
1019 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;p&#32;=&#32;1&#32;-&#32;std::pow(next()&#32;+&#32;0.0,&#32;1.0&#32;/&#32;(-type&#32;+&#32;1));
1020 
1021 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__testlib_crop((<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>)&#32;(<emphasis role="keywordtype">double</emphasis>(n)&#32;*&#32;p),&#32;0LL,&#32;n);
1022 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1023 &#32;&#32;&#32;&#32;}
1024 
1025 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Returns&#32;value&#32;in&#32;[0,&#32;n).&#32;See&#32;wnext(int,&#32;int).&#32;It&#32;uses&#32;the&#32;same&#32;algorithms.&#32;*/</emphasis>
1026 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">double</emphasis>&#32;wnext(<emphasis role="keywordtype">double</emphasis>&#32;n,&#32;<emphasis role="keywordtype">int</emphasis>&#32;type)&#32;{
1027 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(n&#32;&lt;=&#32;0)
1028 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;random_t::wnext(double&#32;n,&#32;int&#32;type):&#32;n&#32;must&#32;be&#32;positive&quot;</emphasis>);
1029 
1030 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(abs(type)&#32;&lt;&#32;random_t::lim)&#32;{
1031 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">double</emphasis>&#32;result&#32;=&#32;next();
1032 
1033 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">int</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;+type;&#32;i++)
1034 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result&#32;=&#32;__testlib_max(result,&#32;next());
1035 
1036 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">int</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;-type;&#32;i++)
1037 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result&#32;=&#32;__testlib_min(result,&#32;next());
1038 
1039 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;n&#32;*&#32;result;
1040 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
1041 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">double</emphasis>&#32;p;
1042 
1043 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(type&#32;&gt;&#32;0)
1044 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;p&#32;=&#32;std::pow(next()&#32;+&#32;0.0,&#32;1.0&#32;/&#32;(type&#32;+&#32;1));
1045 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
1046 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;p&#32;=&#32;1&#32;-&#32;std::pow(next()&#32;+&#32;0.0,&#32;1.0&#32;/&#32;(-type&#32;+&#32;1));
1047 
1048 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__testlib_crop(n&#32;*&#32;p,&#32;0.0,&#32;n);
1049 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1050 &#32;&#32;&#32;&#32;}
1051 
1052 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Returns&#32;value&#32;in&#32;[0,&#32;1).&#32;See&#32;wnext(int,&#32;int).&#32;It&#32;uses&#32;the&#32;same&#32;algorithms.&#32;*/</emphasis>
1053 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">double</emphasis>&#32;wnext(<emphasis role="keywordtype">int</emphasis>&#32;type)&#32;{
1054 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;wnext(1.0,&#32;type);
1055 &#32;&#32;&#32;&#32;}
1056 
1057 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;See&#32;wnext(int,&#32;int).&#32;It&#32;uses&#32;the&#32;same&#32;algorithms.&#32;*/</emphasis>
1058 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">int</emphasis>&#32;wnext(<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">int</emphasis>&#32;n,&#32;<emphasis role="keywordtype">int</emphasis>&#32;type)&#32;{
1059 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(n&#32;&gt;=&#32;INT_MAX)
1060 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;random_t::wnext(unsigned&#32;int&#32;n,&#32;int&#32;type):&#32;n&#32;must&#32;be&#32;less&#32;INT_MAX&quot;</emphasis>);
1061 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;(<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">int</emphasis>)&#32;wnext(<emphasis role="keywordtype">int</emphasis>(n),&#32;type);
1062 &#32;&#32;&#32;&#32;}
1063 
1064 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;See&#32;wnext(int,&#32;int).&#32;It&#32;uses&#32;the&#32;same&#32;algorithms.&#32;*/</emphasis>
1065 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;wnext(<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;n,&#32;<emphasis role="keywordtype">int</emphasis>&#32;type)&#32;{
1066 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(n&#32;&gt;=&#32;(<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>)&#32;(__TESTLIB_LONGLONG_MAX))
1067 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;random_t::wnext(unsigned&#32;long&#32;long&#32;n,&#32;int&#32;type):&#32;n&#32;must&#32;be&#32;less&#32;LONGLONG_MAX&quot;</emphasis>);
1068 
1069 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;(<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>)&#32;wnext((<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>)&#32;(n),&#32;type);
1070 &#32;&#32;&#32;&#32;}
1071 
1072 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;See&#32;wnext(int,&#32;int).&#32;It&#32;uses&#32;the&#32;same&#32;algorithms.&#32;*/</emphasis>
1073 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">long</emphasis>&#32;wnext(<emphasis role="keywordtype">long</emphasis>&#32;n,&#32;<emphasis role="keywordtype">int</emphasis>&#32;type)&#32;{
1074 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;(<emphasis role="keywordtype">long</emphasis>)&#32;wnext((<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>)&#32;(n),&#32;type);
1075 &#32;&#32;&#32;&#32;}
1076 
1077 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;See&#32;wnext(int,&#32;int).&#32;It&#32;uses&#32;the&#32;same&#32;algorithms.&#32;*/</emphasis>
1078 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;wnext(<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;n,&#32;<emphasis role="keywordtype">int</emphasis>&#32;type)&#32;{
1079 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(n&#32;&gt;=&#32;(<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>)&#32;(LONG_MAX))
1080 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;random_t::wnext(unsigned&#32;long&#32;n,&#32;int&#32;type):&#32;n&#32;must&#32;be&#32;less&#32;LONG_MAX&quot;</emphasis>);
1081 
1082 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;(<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>)&#32;wnext((<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>)&#32;(n),&#32;type);
1083 &#32;&#32;&#32;&#32;}
1084 
1085 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Returns&#32;weighted&#32;random&#32;value&#32;in&#32;range&#32;[from,&#32;to].&#32;*/</emphasis>
1086 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;wnext(<emphasis role="keywordtype">int</emphasis>&#32;from,&#32;<emphasis role="keywordtype">int</emphasis>&#32;to,&#32;<emphasis role="keywordtype">int</emphasis>&#32;type)&#32;{
1087 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(from&#32;&gt;&#32;to)
1088 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;random_t::wnext(int&#32;from,&#32;int&#32;to,&#32;int&#32;type):&#32;from&#32;can&apos;t&#32;not&#32;exceed&#32;to&quot;</emphasis>);
1089 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;wnext(to&#32;-&#32;from&#32;+&#32;1,&#32;type)&#32;+&#32;from;
1090 &#32;&#32;&#32;&#32;}
1091 
1092 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Returns&#32;weighted&#32;random&#32;value&#32;in&#32;range&#32;[from,&#32;to].&#32;*/</emphasis>
1093 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;wnext(<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">int</emphasis>&#32;from,&#32;<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">int</emphasis>&#32;to,&#32;<emphasis role="keywordtype">int</emphasis>&#32;type)&#32;{
1094 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(from&#32;&gt;&#32;to)
1095 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;random_t::wnext(unsigned&#32;int&#32;from,&#32;unsigned&#32;int&#32;to,&#32;int&#32;type):&#32;from&#32;can&apos;t&#32;not&#32;exceed&#32;to&quot;</emphasis>);
1096 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;int(wnext(to&#32;-&#32;from&#32;+&#32;1,&#32;type)&#32;+&#32;from);
1097 &#32;&#32;&#32;&#32;}
1098 
1099 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Returns&#32;weighted&#32;random&#32;value&#32;in&#32;range&#32;[from,&#32;to].&#32;*/</emphasis>
1100 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;wnext(<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;from,&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;to,&#32;<emphasis role="keywordtype">int</emphasis>&#32;type)&#32;{
1101 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(from&#32;&gt;&#32;to)
1102 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;random_t::wnext(long&#32;long&#32;from,&#32;long&#32;long&#32;to,&#32;int&#32;type):&#32;from&#32;can&apos;t&#32;not&#32;exceed&#32;to&quot;</emphasis>);
1103 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;wnext(to&#32;-&#32;from&#32;+&#32;1,&#32;type)&#32;+&#32;from;
1104 &#32;&#32;&#32;&#32;}
1105 
1106 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Returns&#32;weighted&#32;random&#32;value&#32;in&#32;range&#32;[from,&#32;to].&#32;*/</emphasis>
1107 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;wnext(<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;from,&#32;<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;to,&#32;<emphasis role="keywordtype">int</emphasis>&#32;type)&#32;{
1108 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(from&#32;&gt;&#32;to)
1109 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(
1110 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;random_t::wnext(unsigned&#32;long&#32;long&#32;from,&#32;unsigned&#32;long&#32;long&#32;to,&#32;int&#32;type):&#32;from&#32;can&apos;t&#32;not&#32;exceed&#32;to&quot;</emphasis>);
1111 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;wnext(to&#32;-&#32;from&#32;+&#32;1,&#32;type)&#32;+&#32;from;
1112 &#32;&#32;&#32;&#32;}
1113 
1114 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Returns&#32;weighted&#32;random&#32;value&#32;in&#32;range&#32;[from,&#32;to].&#32;*/</emphasis>
1115 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">long</emphasis>&#32;wnext(<emphasis role="keywordtype">long</emphasis>&#32;from,&#32;<emphasis role="keywordtype">long</emphasis>&#32;to,&#32;<emphasis role="keywordtype">int</emphasis>&#32;type)&#32;{
1116 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(from&#32;&gt;&#32;to)
1117 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;random_t::wnext(long&#32;from,&#32;long&#32;to,&#32;int&#32;type):&#32;from&#32;can&apos;t&#32;not&#32;exceed&#32;to&quot;</emphasis>);
1118 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;wnext(to&#32;-&#32;from&#32;+&#32;1,&#32;type)&#32;+&#32;from;
1119 &#32;&#32;&#32;&#32;}
1120 
1121 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Returns&#32;weighted&#32;random&#32;value&#32;in&#32;range&#32;[from,&#32;to].&#32;*/</emphasis>
1122 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;wnext(<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;from,&#32;<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;to,&#32;<emphasis role="keywordtype">int</emphasis>&#32;type)&#32;{
1123 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(from&#32;&gt;&#32;to)
1124 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;random_t::wnext(unsigned&#32;long&#32;from,&#32;unsigned&#32;long&#32;to,&#32;int&#32;type):&#32;from&#32;can&apos;t&#32;not&#32;exceed&#32;to&quot;</emphasis>);
1125 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;wnext(to&#32;-&#32;from&#32;+&#32;1,&#32;type)&#32;+&#32;from;
1126 &#32;&#32;&#32;&#32;}
1127 
1128 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Returns&#32;weighted&#32;random&#32;double&#32;value&#32;in&#32;range&#32;[from,&#32;to).&#32;*/</emphasis>
1129 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">double</emphasis>&#32;wnext(<emphasis role="keywordtype">double</emphasis>&#32;from,&#32;<emphasis role="keywordtype">double</emphasis>&#32;to,&#32;<emphasis role="keywordtype">int</emphasis>&#32;type)&#32;{
1130 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(from&#32;&gt;=&#32;to)
1131 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;random_t::wnext(double&#32;from,&#32;double&#32;to,&#32;int&#32;type):&#32;from&#32;should&#32;be&#32;strictly&#32;less&#32;than&#32;to&quot;</emphasis>);
1132 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;wnext(to&#32;-&#32;from,&#32;type)&#32;+&#32;from;
1133 &#32;&#32;&#32;&#32;}
1134 
1135 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Returns&#32;weighted&#32;random&#32;element&#32;from&#32;container.&#32;*/</emphasis>
1136 &#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;Container&gt;
1137 &#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;Container::value_type&#32;wany(<emphasis role="keyword">const</emphasis>&#32;Container&#32;&amp;c,&#32;<emphasis role="keywordtype">int</emphasis>&#32;type)&#32;{
1138 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;size&#32;=&#32;int(c.size());
1139 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(size&#32;&lt;=&#32;0)
1140 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;random_t::wany(const&#32;Container&amp;&#32;c,&#32;int&#32;type):&#32;c.size()&#32;must&#32;be&#32;positive&quot;</emphasis>);
1141 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;Container::const_iterator&#32;it&#32;=&#32;c.begin();
1142 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::advance(it,&#32;wnext(size,&#32;type));
1143 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;*it;
1144 &#32;&#32;&#32;&#32;}
1145 
1146 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Returns&#32;weighted&#32;random&#32;element&#32;from&#32;iterator&#32;range.&#32;*/</emphasis>
1147 &#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;Iter&gt;
1148 &#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;Iter::value_type&#32;wany(<emphasis role="keyword">const</emphasis>&#32;Iter&#32;&amp;begin,&#32;<emphasis role="keyword">const</emphasis>&#32;Iter&#32;&amp;end,&#32;<emphasis role="keywordtype">int</emphasis>&#32;type)&#32;{
1149 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;size&#32;=&#32;<emphasis role="keyword">static_cast&lt;</emphasis><emphasis role="keywordtype">int</emphasis><emphasis role="keyword">&gt;</emphasis>(std::distance(begin,&#32;end));
1150 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(size&#32;&lt;=&#32;0)
1151 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(
1152 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;random_t::any(const&#32;Iter&amp;&#32;begin,&#32;const&#32;Iter&amp;&#32;end,&#32;int&#32;type):&#32;range&#32;must&#32;have&#32;positive&#32;length&quot;</emphasis>);
1153 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;Iter&#32;it&#32;=&#32;begin;
1154 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::advance(it,&#32;wnext(size,&#32;type));
1155 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;*it;
1156 &#32;&#32;&#32;&#32;}
1157 
1158 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Returns&#32;random&#32;permutation&#32;of&#32;the&#32;given&#32;size&#32;(values&#32;are&#32;between&#32;`first`&#32;and&#32;`first`+size-1)*/</emphasis>
1159 &#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Tp,&#32;<emphasis role="keyword">typename</emphasis>&#32;E&gt;
1160 &#32;&#32;&#32;&#32;std::vector&lt;E&gt;&#32;perm(_Tp&#32;size,&#32;E&#32;first)&#32;{
1161 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(size&#32;&lt;&#32;0)
1162 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;random_t::perm(T&#32;size,&#32;E&#32;first&#32;=&#32;0):&#32;size&#32;must&#32;non-negative&quot;</emphasis>);
1163 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="keywordflow">if</emphasis>&#32;(size&#32;==&#32;0)
1164 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;std::vector&lt;E&gt;();
1165 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::vector&lt;E&gt;&#32;p(size);
1166 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;E&#32;current&#32;=&#32;first;
1167 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(_Tp&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;size;&#32;i++)
1168 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;p[i]&#32;=&#32;current++;
1169 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(size&#32;&gt;&#32;1)
1170 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(_Tp&#32;i&#32;=&#32;1;&#32;i&#32;&lt;&#32;size;&#32;i++)
1171 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::swap(p[i],&#32;p[next(i&#32;+&#32;1)]);
1172 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;p;
1173 &#32;&#32;&#32;&#32;}
1174 
1175 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Returns&#32;random&#32;permutation&#32;of&#32;the&#32;given&#32;size&#32;(values&#32;are&#32;between&#32;0&#32;and&#32;size-1)*/</emphasis>
1176 &#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Tp&gt;
1177 &#32;&#32;&#32;&#32;std::vector&lt;_Tp&gt;&#32;perm(_Tp&#32;size)&#32;{
1178 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;perm(size,&#32;_Tp(0));
1179 &#32;&#32;&#32;&#32;}
1180 
1181 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Returns&#32;`size`&#32;unordered&#32;(unsorted)&#32;distinct&#32;numbers&#32;between&#32;`from`&#32;and&#32;`to`.&#32;*/</emphasis>
1182 &#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Tp&gt;
1183 &#32;&#32;&#32;&#32;std::vector&lt;_Tp&gt;&#32;distinct(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;_Tp&#32;from,&#32;_Tp&#32;to)&#32;{
1184 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::vector&lt;_Tp&gt;&#32;result;
1185 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(size&#32;==&#32;0)
1186 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;result;
1187 
1188 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(from&#32;&gt;&#32;to)
1189 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;random_t::distinct&#32;expected&#32;from&#32;&lt;=&#32;to&quot;</emphasis>);
1190 
1191 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(size&#32;&lt;&#32;0)
1192 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;random_t::distinct&#32;expected&#32;size&#32;&gt;=&#32;0&quot;</emphasis>);
1193 
1194 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;uint64_t&#32;n&#32;=&#32;to&#32;-&#32;from&#32;+&#32;1;
1195 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(uint64_t(size)&#32;&gt;&#32;n)
1196 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;random_t::distinct&#32;expected&#32;size&#32;&lt;=&#32;to&#32;-&#32;from&#32;+&#32;1&quot;</emphasis>);
1197 
1198 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">double</emphasis>&#32;expected&#32;=&#32;0.0;
1199 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">int</emphasis>&#32;i&#32;=&#32;1;&#32;i&#32;&lt;=&#32;size;&#32;i++)
1200 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;expected&#32;+=&#32;<emphasis role="keywordtype">double</emphasis>(n)&#32;/&#32;double(n&#32;-&#32;i&#32;+&#32;1);
1201 
1202 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(expected&#32;&lt;&#32;<emphasis role="keywordtype">double</emphasis>(n))&#32;{
1203 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::set&lt;_Tp&gt;&#32;vals;
1204 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">while</emphasis>&#32;(<emphasis role="keywordtype">int</emphasis>(vals.size())&#32;&lt;&#32;size)&#32;{
1205 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Tp&#32;x&#32;=&#32;_Tp(next(from,&#32;to));
1206 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(vals.insert(x).second)
1207 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result.push_back(x);
1208 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1209 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
1210 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(n&#32;&gt;&#32;1000000000)
1211 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;random_t::distinct&#32;here&#32;expected&#32;to&#32;-&#32;from&#32;+&#32;1&#32;&lt;=&#32;1000000000&quot;</emphasis>);
1212 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::vector&lt;_Tp&gt;&#32;p(perm(<emphasis role="keywordtype">int</emphasis>(n),&#32;from));
1213 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result.insert(result.end(),&#32;p.begin(),&#32;p.begin()&#32;+&#32;size);
1214 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1215 
1216 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;result;
1217 &#32;&#32;&#32;&#32;}
1218 
1219 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Returns&#32;`size`&#32;unordered&#32;(unsorted)&#32;distinct&#32;numbers&#32;between&#32;`0`&#32;and&#32;`upper`-1.&#32;*/</emphasis>
1220 &#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Tp&gt;
1221 &#32;&#32;&#32;&#32;std::vector&lt;_Tp&gt;&#32;distinct(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;_Tp&#32;upper)&#32;{
1222 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(size&#32;&lt;&#32;0)
1223 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;random_t::distinct&#32;expected&#32;size&#32;&gt;=&#32;0&quot;</emphasis>);
1224 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(size&#32;==&#32;0)
1225 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;std::vector&lt;_Tp&gt;();
1226 
1227 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(upper&#32;&lt;=&#32;0)
1228 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;random_t::distinct&#32;expected&#32;upper&#32;&gt;&#32;0&quot;</emphasis>);
1229 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(size&#32;&gt;&#32;upper)
1230 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;random_t::distinct&#32;expected&#32;size&#32;&lt;=&#32;upper&quot;</emphasis>);
1231 
1232 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;distinct(size,&#32;_Tp(0),&#32;upper&#32;-&#32;1);
1233 &#32;&#32;&#32;&#32;}
1234 
1235 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Returns&#32;random&#32;(unsorted)&#32;partition&#32;which&#32;is&#32;a&#32;representation&#32;of&#32;sum&#32;as&#32;a&#32;sum&#32;of&#32;integers&#32;not&#32;less&#32;than&#32;min_part.&#32;*/</emphasis>
1236 &#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Tp&gt;
1237 &#32;&#32;&#32;&#32;std::vector&lt;_Tp&gt;&#32;partition(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;_Tp&#32;sum,&#32;_Tp&#32;min_part)&#32;{
1238 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(size&#32;&lt;&#32;0)
1239 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;random_t::partition:&#32;size&#32;&lt;&#32;0&quot;</emphasis>);
1240 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(size&#32;==&#32;0&#32;&amp;&amp;&#32;sum&#32;!=&#32;0)
1241 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;random_t::partition:&#32;size&#32;==&#32;0&#32;&amp;&amp;&#32;sum&#32;!=&#32;0&quot;</emphasis>);
1242 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(min_part&#32;*&#32;size&#32;&gt;&#32;sum)
1243 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;random_t::partition:&#32;min_part&#32;*&#32;size&#32;&gt;&#32;sum&quot;</emphasis>);
1244 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(size&#32;==&#32;0&#32;&amp;&amp;&#32;sum&#32;==&#32;0)
1245 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;std::vector&lt;_Tp&gt;();
1246 
1247 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Tp&#32;sum_&#32;=&#32;sum;
1248 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;sum&#32;-=&#32;min_part&#32;*&#32;size;
1249 
1250 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::vector&lt;_Tp&gt;&#32;septums(size);
1251 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::vector&lt;_Tp&gt;&#32;d&#32;=&#32;distinct(size&#32;-&#32;1,&#32;_Tp(1),&#32;_Tp(sum&#32;+&#32;size&#32;-&#32;1));
1252 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">int</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;+&#32;1&#32;&lt;&#32;size;&#32;i++)
1253 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;septums[i&#32;+&#32;1]&#32;=&#32;d[i];
1254 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;sort(septums.begin(),&#32;septums.end());
1255 
1256 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::vector&lt;_Tp&gt;&#32;result(size);
1257 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">int</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;+&#32;1&#32;&lt;&#32;size;&#32;i++)
1258 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result[i]&#32;=&#32;septums[i&#32;+&#32;1]&#32;-&#32;septums[i]&#32;-&#32;1;
1259 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result[size&#32;-&#32;1]&#32;=&#32;sum&#32;+&#32;size&#32;-&#32;1&#32;-&#32;septums.back();
1260 
1261 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(std::size_t&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;result.size();&#32;i++)
1262 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result[i]&#32;+=&#32;min_part;
1263 
1264 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Tp&#32;result_sum&#32;=&#32;0;
1265 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(std::size_t&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;result.size();&#32;i++)
1266 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result_sum&#32;+=&#32;result[i];
1267 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(result_sum&#32;!=&#32;sum_)
1268 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;random_t::partition:&#32;partition&#32;sum&#32;is&#32;expected&#32;to&#32;be&#32;the&#32;given&#32;sum&quot;</emphasis>);
1269 
1270 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(*std::min_element(result.begin(),&#32;result.end())&#32;&lt;&#32;min_part)
1271 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;random_t::partition:&#32;partition&#32;min&#32;is&#32;expected&#32;to&#32;be&#32;no&#32;less&#32;than&#32;the&#32;given&#32;min_part&quot;</emphasis>);
1272 
1273 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(<emphasis role="keywordtype">int</emphasis>(result.size())&#32;!=&#32;size&#32;||&#32;result.size()&#32;!=&#32;(<emphasis role="keywordtype">size_t</emphasis>)&#32;size)
1274 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;random_t::partition:&#32;partition&#32;size&#32;is&#32;expected&#32;to&#32;be&#32;equal&#32;to&#32;the&#32;given&#32;size&quot;</emphasis>);
1275 
1276 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;result;
1277 &#32;&#32;&#32;&#32;}
1278 
1279 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Returns&#32;random&#32;(unsorted)&#32;partition&#32;which&#32;is&#32;a&#32;representation&#32;of&#32;sum&#32;as&#32;a&#32;sum&#32;of&#32;positive&#32;integers.&#32;*/</emphasis>
1280 &#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Tp&gt;
1281 &#32;&#32;&#32;&#32;std::vector&lt;_Tp&gt;&#32;partition(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;_Tp&#32;sum)&#32;{
1282 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;partition(size,&#32;sum,&#32;_Tp(1));
1283 &#32;&#32;&#32;&#32;}
1284 };
1285 
1286 <emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">int</emphasis>&#32;random_t::lim&#32;=&#32;25;
1287 <emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;random_t::multiplier&#32;=&#32;0x5DEECE66DLL;
1288 <emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;random_t::addend&#32;=&#32;0xBLL;
1289 <emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;random_t::mask&#32;=&#32;(1LL&#32;&lt;&lt;&#32;48)&#32;-&#32;1;
1290 <emphasis role="keywordtype">int</emphasis>&#32;random_t::version&#32;=&#32;-1;
1291 
1292 <emphasis role="comment">/*&#32;Pattern&#32;implementation&#32;*/</emphasis>
1293 <emphasis role="keywordtype">bool</emphasis>&#32;pattern::matches(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;s)<emphasis role="keyword">&#32;const&#32;</emphasis>{
1294 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;matches(s,&#32;0);
1295 }
1296 
1297 <emphasis role="keyword">static</emphasis>&#32;<emphasis role="keywordtype">bool</emphasis>&#32;__pattern_isSlash(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;s,&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;pos)&#32;{
1298 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;s[pos]&#32;==&#32;<emphasis role="charliteral">&apos;\\&apos;</emphasis>;
1299 }
1300 
1301 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
1302 __attribute__((pure))
1303 <emphasis role="preprocessor">#endif</emphasis>
1304 <emphasis role="keyword">static</emphasis>&#32;<emphasis role="keywordtype">bool</emphasis>&#32;__pattern_isCommandChar(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;s,&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;pos,&#32;<emphasis role="keywordtype">char</emphasis>&#32;value)&#32;{
1305 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(pos&#32;&gt;=&#32;s.length())
1306 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
1307 
1308 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;slashes&#32;=&#32;0;
1309 
1310 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;before&#32;=&#32;int(pos)&#32;-&#32;1;
1311 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">while</emphasis>&#32;(before&#32;&gt;=&#32;0&#32;&amp;&amp;&#32;s[before]&#32;==&#32;<emphasis role="charliteral">&apos;\\&apos;</emphasis>)
1312 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;before--,&#32;slashes++;
1313 
1314 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;slashes&#32;%&#32;2&#32;==&#32;0&#32;&amp;&amp;&#32;s[pos]&#32;==&#32;value;
1315 }
1316 
1317 <emphasis role="keyword">static</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;__pattern_getChar(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;s,&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;&amp;pos)&#32;{
1318 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__pattern_isSlash(s,&#32;pos))
1319 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;pos&#32;+=&#32;2;
1320 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
1321 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;pos++;
1322 
1323 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;s[pos&#32;-&#32;1];
1324 }
1325 
1326 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
1327 __attribute__((pure))
1328 <emphasis role="preprocessor">#endif</emphasis>
1329 <emphasis role="keyword">static</emphasis>&#32;<emphasis role="keywordtype">int</emphasis>&#32;__pattern_greedyMatch(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;s,&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;pos,&#32;<emphasis role="keyword">const</emphasis>&#32;std::vector&lt;char&gt;&#32;chars)&#32;{
1330 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;result&#32;=&#32;0;
1331 
1332 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">while</emphasis>&#32;(pos&#32;&lt;&#32;s.length())&#32;{
1333 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">char</emphasis>&#32;c&#32;=&#32;s[pos++];
1334 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!std::binary_search(chars.begin(),&#32;chars.end(),&#32;c))
1335 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">break</emphasis>;
1336 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
1337 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result++;
1338 &#32;&#32;&#32;&#32;}
1339 
1340 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;result;
1341 }
1342 
1343 std::string&#32;pattern::src()<emphasis role="keyword">&#32;const&#32;</emphasis>{
1344 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;s;
1345 }
1346 
1347 <emphasis role="keywordtype">bool</emphasis>&#32;pattern::matches(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;s,&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;pos)<emphasis role="keyword">&#32;const&#32;</emphasis>{
1348 &#32;&#32;&#32;&#32;std::string&#32;result;
1349 
1350 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(to&#32;&gt;&#32;0)&#32;{
1351 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;size&#32;=&#32;__pattern_greedyMatch(s,&#32;pos,&#32;chars);
1352 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(size&#32;&lt;&#32;from)
1353 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
1354 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(size&#32;&gt;&#32;to)
1355 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;size&#32;=&#32;to;
1356 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;pos&#32;+=&#32;size;
1357 &#32;&#32;&#32;&#32;}
1358 
1359 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(children.size()&#32;&gt;&#32;0)&#32;{
1360 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">size_t</emphasis>&#32;child&#32;=&#32;0;&#32;child&#32;&lt;&#32;children.size();&#32;child++)
1361 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(children[child].matches(s,&#32;pos))
1362 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">true</emphasis>;
1363 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
1364 &#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>
1365 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;pos&#32;==&#32;s.length();
1366 }
1367 
1368 std::string&#32;pattern::next(<link linkend="_classrandom__t">random_t</link>&#32;&amp;rnd)<emphasis role="keyword">&#32;const&#32;</emphasis>{
1369 &#32;&#32;&#32;&#32;std::string&#32;result;
1370 &#32;&#32;&#32;&#32;result.reserve(20);
1371 
1372 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(to&#32;==&#32;INT_MAX)
1373 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;pattern::next(random_t&amp;&#32;rnd):&#32;can&apos;t&#32;process&#32;character&#32;&apos;*&apos;&#32;for&#32;generation&quot;</emphasis>);
1374 
1375 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(to&#32;&gt;&#32;0)&#32;{
1376 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;count&#32;=&#32;rnd.next(to&#32;-&#32;from&#32;+&#32;1)&#32;+&#32;from;
1377 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">int</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;count;&#32;i++)
1378 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result&#32;+=&#32;chars[rnd.next(<emphasis role="keywordtype">int</emphasis>(chars.size()))];
1379 &#32;&#32;&#32;&#32;}
1380 
1381 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(children.size()&#32;&gt;&#32;0)&#32;{
1382 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;child&#32;=&#32;rnd.next(<emphasis role="keywordtype">int</emphasis>(children.size()));
1383 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result&#32;+=&#32;children[child].next(rnd);
1384 &#32;&#32;&#32;&#32;}
1385 
1386 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;result;
1387 }
1388 
1389 <emphasis role="keyword">static</emphasis>&#32;<emphasis role="keywordtype">void</emphasis>&#32;__pattern_scanCounts(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;s,&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;&amp;pos,&#32;<emphasis role="keywordtype">int</emphasis>&#32;&amp;from,&#32;<emphasis role="keywordtype">int</emphasis>&#32;&amp;to)&#32;{
1390 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(pos&#32;&gt;=&#32;s.length())&#32;{
1391 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;from&#32;=&#32;to&#32;=&#32;1;
1392 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>;
1393 &#32;&#32;&#32;&#32;}
1394 
1395 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__pattern_isCommandChar(s,&#32;pos,&#32;<emphasis role="charliteral">&apos;{&apos;</emphasis>))&#32;{
1396 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::vector&lt;std::string&gt;&#32;parts;
1397 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::string&#32;part;
1398 
1399 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;pos++;
1400 
1401 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">while</emphasis>&#32;(pos&#32;&lt;&#32;s.length()&#32;&amp;&amp;&#32;!__pattern_isCommandChar(s,&#32;pos,&#32;<emphasis role="charliteral">&apos;}&apos;</emphasis>))&#32;{
1402 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__pattern_isCommandChar(s,&#32;pos,&#32;<emphasis role="charliteral">&apos;,&apos;</emphasis>))
1403 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;parts.push_back(part),&#32;part&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>,&#32;pos++;
1404 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
1405 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;part&#32;+=&#32;__pattern_getChar(s,&#32;pos);
1406 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1407 
1408 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(part&#32;!=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>)
1409 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;parts.push_back(part);
1410 
1411 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!__pattern_isCommandChar(s,&#32;pos,&#32;<emphasis role="charliteral">&apos;}&apos;</emphasis>))
1412 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;pattern:&#32;Illegal&#32;pattern&#32;(or&#32;part)&#32;\&quot;&quot;</emphasis>&#32;+&#32;s&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&quot;</emphasis>);
1413 
1414 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;pos++;
1415 
1416 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(parts.size()&#32;&lt;&#32;1&#32;||&#32;parts.size()&#32;&gt;&#32;2)
1417 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;pattern:&#32;Illegal&#32;pattern&#32;(or&#32;part)&#32;\&quot;&quot;</emphasis>&#32;+&#32;s&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&quot;</emphasis>);
1418 
1419 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::vector&lt;int&gt;&#32;numbers;
1420 
1421 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">size_t</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;parts.size();&#32;i++)&#32;{
1422 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(parts[i].length()&#32;==&#32;0)
1423 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;pattern:&#32;Illegal&#32;pattern&#32;(or&#32;part)&#32;\&quot;&quot;</emphasis>&#32;+&#32;s&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&quot;</emphasis>);
1424 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;number;
1425 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(std::sscanf(parts[i].c_str(),&#32;<emphasis role="stringliteral">&quot;%d&quot;</emphasis>,&#32;&amp;number)&#32;!=&#32;1)
1426 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;pattern:&#32;Illegal&#32;pattern&#32;(or&#32;part)&#32;\&quot;&quot;</emphasis>&#32;+&#32;s&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&quot;</emphasis>);
1427 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;numbers.push_back(number);
1428 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1429 
1430 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(numbers.size()&#32;==&#32;1)
1431 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;from&#32;=&#32;to&#32;=&#32;numbers[0];
1432 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
1433 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;from&#32;=&#32;numbers[0],&#32;to&#32;=&#32;numbers[1];
1434 
1435 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(from&#32;&gt;&#32;to)
1436 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;pattern:&#32;Illegal&#32;pattern&#32;(or&#32;part)&#32;\&quot;&quot;</emphasis>&#32;+&#32;s&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&quot;</emphasis>);
1437 &#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
1438 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__pattern_isCommandChar(s,&#32;pos,&#32;<emphasis role="charliteral">&apos;?&apos;</emphasis>))&#32;{
1439 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;from&#32;=&#32;0,&#32;to&#32;=&#32;1,&#32;pos++;
1440 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>;
1441 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1442 
1443 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__pattern_isCommandChar(s,&#32;pos,&#32;<emphasis role="charliteral">&apos;*&apos;</emphasis>))&#32;{
1444 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;from&#32;=&#32;0,&#32;to&#32;=&#32;INT_MAX,&#32;pos++;
1445 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>;
1446 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1447 
1448 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__pattern_isCommandChar(s,&#32;pos,&#32;<emphasis role="charliteral">&apos;+&apos;</emphasis>))&#32;{
1449 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;from&#32;=&#32;1,&#32;to&#32;=&#32;INT_MAX,&#32;pos++;
1450 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>;
1451 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1452 
1453 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;from&#32;=&#32;to&#32;=&#32;1;
1454 &#32;&#32;&#32;&#32;}
1455 }
1456 
1457 <emphasis role="keyword">static</emphasis>&#32;std::vector&lt;char&gt;&#32;__pattern_scanCharSet(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;s,&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;&amp;pos)&#32;{
1458 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(pos&#32;&gt;=&#32;s.length())
1459 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;pattern:&#32;Illegal&#32;pattern&#32;(or&#32;part)&#32;\&quot;&quot;</emphasis>&#32;+&#32;s&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&quot;</emphasis>);
1460 
1461 &#32;&#32;&#32;&#32;std::vector&lt;char&gt;&#32;result;
1462 
1463 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__pattern_isCommandChar(s,&#32;pos,&#32;<emphasis role="charliteral">&apos;[&apos;</emphasis>))&#32;{
1464 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;pos++;
1465 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;negative&#32;=&#32;__pattern_isCommandChar(s,&#32;pos,&#32;<emphasis role="charliteral">&apos;^&apos;</emphasis>);
1466 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(negative)
1467 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;pos++;
1468 
1469 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">char</emphasis>&#32;prev&#32;=&#32;0;
1470 
1471 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">while</emphasis>&#32;(pos&#32;&lt;&#32;s.length()&#32;&amp;&amp;&#32;!__pattern_isCommandChar(s,&#32;pos,&#32;<emphasis role="charliteral">&apos;]&apos;</emphasis>))&#32;{
1472 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__pattern_isCommandChar(s,&#32;pos,&#32;<emphasis role="charliteral">&apos;-&apos;</emphasis>)&#32;&amp;&amp;&#32;prev&#32;!=&#32;0)&#32;{
1473 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;pos++;
1474 
1475 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(pos&#32;+&#32;1&#32;==&#32;s.length()&#32;||&#32;__pattern_isCommandChar(s,&#32;pos,&#32;<emphasis role="charliteral">&apos;]&apos;</emphasis>))&#32;{
1476 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result.push_back(prev);
1477 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;prev&#32;=&#32;<emphasis role="charliteral">&apos;-&apos;</emphasis>;
1478 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">continue</emphasis>;
1479 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1480 
1481 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">char</emphasis>&#32;next&#32;=&#32;__pattern_getChar(s,&#32;pos);
1482 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(prev&#32;&gt;&#32;next)
1483 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;pattern:&#32;Illegal&#32;pattern&#32;(or&#32;part)&#32;\&quot;&quot;</emphasis>&#32;+&#32;s&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&quot;</emphasis>);
1484 
1485 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">char</emphasis>&#32;c&#32;=&#32;prev;&#32;c&#32;!=&#32;next;&#32;c++)
1486 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result.push_back(c);
1487 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result.push_back(next);
1488 
1489 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;prev&#32;=&#32;0;
1490 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
1491 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(prev&#32;!=&#32;0)
1492 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result.push_back(prev);
1493 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;prev&#32;=&#32;__pattern_getChar(s,&#32;pos);
1494 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1495 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1496 
1497 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(prev&#32;!=&#32;0)
1498 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result.push_back(prev);
1499 
1500 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!__pattern_isCommandChar(s,&#32;pos,&#32;<emphasis role="charliteral">&apos;]&apos;</emphasis>))
1501 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;pattern:&#32;Illegal&#32;pattern&#32;(or&#32;part)&#32;\&quot;&quot;</emphasis>&#32;+&#32;s&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&quot;</emphasis>);
1502 
1503 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;pos++;
1504 
1505 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(negative)&#32;{
1506 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::sort(result.begin(),&#32;result.end());
1507 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::vector&lt;char&gt;&#32;actuals;
1508 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">int</emphasis>&#32;code&#32;=&#32;0;&#32;code&#32;&lt;&#32;255;&#32;code++)&#32;{
1509 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">char</emphasis>&#32;c&#32;=&#32;char(code);
1510 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!std::binary_search(result.begin(),&#32;result.end(),&#32;c))
1511 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;actuals.push_back(c);
1512 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1513 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result&#32;=&#32;actuals;
1514 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1515 
1516 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::sort(result.begin(),&#32;result.end());
1517 &#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>
1518 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result.push_back(__pattern_getChar(s,&#32;pos));
1519 
1520 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;result;
1521 }
1522 
1523 pattern::pattern(std::string&#32;s)&#32;:&#32;s(s),&#32;from(0),&#32;to(0)&#32;{
1524 &#32;&#32;&#32;&#32;std::string&#32;t;
1525 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">size_t</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;s.length();&#32;i++)
1526 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!__pattern_isCommandChar(s,&#32;i,&#32;<emphasis role="charliteral">&apos;&#32;&apos;</emphasis>))
1527 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;t&#32;+=&#32;s[i];
1528 &#32;&#32;&#32;&#32;s&#32;=&#32;t;
1529 
1530 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;opened&#32;=&#32;0;
1531 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;firstClose&#32;=&#32;-1;
1532 &#32;&#32;&#32;&#32;std::vector&lt;int&gt;&#32;seps;
1533 
1534 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">size_t</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;s.length();&#32;i++)&#32;{
1535 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__pattern_isCommandChar(s,&#32;i,&#32;<emphasis role="charliteral">&apos;(&apos;</emphasis>))&#32;{
1536 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;opened++;
1537 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">continue</emphasis>;
1538 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1539 
1540 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__pattern_isCommandChar(s,&#32;i,&#32;<emphasis role="charliteral">&apos;)&apos;</emphasis>))&#32;{
1541 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;opened--;
1542 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(opened&#32;==&#32;0&#32;&amp;&amp;&#32;firstClose&#32;==&#32;-1)
1543 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;firstClose&#32;=&#32;int(i);
1544 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">continue</emphasis>;
1545 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1546 
1547 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(opened&#32;&lt;&#32;0)
1548 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;pattern:&#32;Illegal&#32;pattern&#32;(or&#32;part)&#32;\&quot;&quot;</emphasis>&#32;+&#32;s&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&quot;</emphasis>);
1549 
1550 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__pattern_isCommandChar(s,&#32;i,&#32;<emphasis role="charliteral">&apos;|&apos;</emphasis>)&#32;&amp;&amp;&#32;opened&#32;==&#32;0)
1551 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;seps.push_back(<emphasis role="keywordtype">int</emphasis>(i));
1552 &#32;&#32;&#32;&#32;}
1553 
1554 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(opened&#32;!=&#32;0)
1555 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;pattern:&#32;Illegal&#32;pattern&#32;(or&#32;part)&#32;\&quot;&quot;</emphasis>&#32;+&#32;s&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&quot;</emphasis>);
1556 
1557 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(seps.size()&#32;==&#32;0&#32;&amp;&amp;&#32;firstClose&#32;+&#32;1&#32;==&#32;(<emphasis role="keywordtype">int</emphasis>)&#32;s.length()
1558 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&amp;&amp;&#32;__pattern_isCommandChar(s,&#32;0,&#32;<emphasis role="charliteral">&apos;(&apos;</emphasis>)&#32;&amp;&amp;&#32;__pattern_isCommandChar(s,&#32;s.length()&#32;-&#32;1,&#32;<emphasis role="charliteral">&apos;)&apos;</emphasis>))&#32;{
1559 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;children.push_back(<link linkend="_classpattern">pattern</link>(s.substr(1,&#32;s.length()&#32;-&#32;2)));
1560 &#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
1561 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(seps.size()&#32;&gt;&#32;0)&#32;{
1562 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;seps.push_back(<emphasis role="keywordtype">int</emphasis>(s.length()));
1563 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;last&#32;=&#32;0;
1564 
1565 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">size_t</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;seps.size();&#32;i++)&#32;{
1566 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;children.push_back(<link linkend="_classpattern">pattern</link>(s.substr(last,&#32;seps[i]&#32;-&#32;last)));
1567 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;last&#32;=&#32;seps[i]&#32;+&#32;1;
1568 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1569 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
1570 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;pos&#32;=&#32;0;
1571 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;chars&#32;=&#32;__pattern_scanCharSet(s,&#32;pos);
1572 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__pattern_scanCounts(s,&#32;pos,&#32;from,&#32;to);
1573 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(pos&#32;&lt;&#32;s.length())
1574 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;children.push_back(<link linkend="_classpattern">pattern</link>(s.substr(pos)));
1575 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1576 &#32;&#32;&#32;&#32;}
1577 }
1578 
1579 <emphasis role="comment">/*&#32;End&#32;of&#32;pattern&#32;implementation&#32;*/</emphasis>
1580 
1581 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;C&gt;
1582 <emphasis role="keyword">inline</emphasis>&#32;<emphasis role="keywordtype">bool</emphasis>&#32;isEof(C&#32;c)&#32;{
1583 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;c&#32;==&#32;EOFC;
1584 }
1585 
1586 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;C&gt;
1587 <emphasis role="keyword">inline</emphasis>&#32;<emphasis role="keywordtype">bool</emphasis>&#32;isEoln(C&#32;c)&#32;{
1588 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;(c&#32;==&#32;LF&#32;||&#32;c&#32;==&#32;CR);
1589 }
1590 
1591 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;C&gt;
1592 <emphasis role="keyword">inline</emphasis>&#32;<emphasis role="keywordtype">bool</emphasis>&#32;isBlanks(C&#32;c)&#32;{
1593 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;(c&#32;==&#32;LF&#32;||&#32;c&#32;==&#32;CR&#32;||&#32;c&#32;==&#32;SPACE&#32;||&#32;c&#32;==&#32;TAB);
1594 }
1595 
1596 <emphasis role="keyword">inline</emphasis>&#32;std::string&#32;trim(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;s)&#32;{
1597 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(s.empty())
1598 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;s;
1599 
1600 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;left&#32;=&#32;0;
1601 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">while</emphasis>&#32;(left&#32;&lt;&#32;<emphasis role="keywordtype">int</emphasis>(s.length())&#32;&amp;&amp;&#32;isBlanks(s[left]))
1602 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;left++;
1603 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(left&#32;&gt;=&#32;<emphasis role="keywordtype">int</emphasis>(s.length()))
1604 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>;
1605 
1606 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;right&#32;=&#32;int(s.length())&#32;-&#32;1;
1607 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">while</emphasis>&#32;(right&#32;&gt;=&#32;0&#32;&amp;&amp;&#32;isBlanks(s[right]))
1608 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;right--;
1609 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(right&#32;&lt;&#32;0)
1610 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>;
1611 
1612 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;s.substr(left,&#32;right&#32;-&#32;left&#32;+&#32;1);
1613 }
1614 
1615 <emphasis role="keyword">enum</emphasis>&#32;TMode&#32;{
1616 &#32;&#32;&#32;&#32;_input,&#32;_output,&#32;_answer
1617 };
1618 
1619 <emphasis role="comment">/*&#32;Outcomes&#32;6-15&#32;are&#32;reserved&#32;for&#32;future&#32;use.&#32;*/</emphasis>
1620 <emphasis role="keyword">enum</emphasis>&#32;TResult&#32;{
1621 &#32;&#32;&#32;&#32;_ok&#32;=&#32;0,
1622 &#32;&#32;&#32;&#32;_wa&#32;=&#32;1,
1623 &#32;&#32;&#32;&#32;_pe&#32;=&#32;2,
1624 &#32;&#32;&#32;&#32;_fail&#32;=&#32;3,
1625 &#32;&#32;&#32;&#32;_dirt&#32;=&#32;4,
1626 &#32;&#32;&#32;&#32;_points&#32;=&#32;5,
1627 &#32;&#32;&#32;&#32;_unexpected_eof&#32;=&#32;8,
1628 &#32;&#32;&#32;&#32;_partially&#32;=&#32;16
1629 };
1630 
1631 <emphasis role="keyword">enum</emphasis>&#32;TTestlibMode&#32;{
1632 &#32;&#32;&#32;&#32;_unknown,&#32;_checker,&#32;_validator,&#32;_generator,&#32;_interactor,&#32;_scorer
1633 };
1634 
1635 <emphasis role="preprocessor">#define&#32;_pc(exitCode)&#32;(TResult(_partially&#32;+&#32;(exitCode)))</emphasis>
1636 
1637 <emphasis role="comment">/*&#32;Outcomes&#32;6-15&#32;are&#32;reserved&#32;for&#32;future&#32;use.&#32;*/</emphasis>
1638 <emphasis role="keyword">const</emphasis>&#32;std::string&#32;outcomes[]&#32;=&#32;{
1639 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;accepted&quot;</emphasis>,
1640 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;wrong-answer&quot;</emphasis>,
1641 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;presentation-error&quot;</emphasis>,
1642 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;fail&quot;</emphasis>,
1643 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;fail&quot;</emphasis>,
1644 <emphasis role="preprocessor">#ifndef&#32;PCMS2</emphasis>
1645 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;points&quot;</emphasis>,
1646 <emphasis role="preprocessor">#else</emphasis>
1647 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;relative-scoring&quot;</emphasis>,
1648 <emphasis role="preprocessor">#endif</emphasis>
1649 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;reserved&quot;</emphasis>,
1650 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;reserved&quot;</emphasis>,
1651 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;unexpected-eof&quot;</emphasis>,
1652 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;reserved&quot;</emphasis>,
1653 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;reserved&quot;</emphasis>,
1654 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;reserved&quot;</emphasis>,
1655 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;reserved&quot;</emphasis>,
1656 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;reserved&quot;</emphasis>,
1657 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;reserved&quot;</emphasis>,
1658 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;reserved&quot;</emphasis>,
1659 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;partially-correct&quot;</emphasis>
1660 };
1661 
1662 <emphasis role="keyword">class&#32;</emphasis><link linkend="_class_input_stream_reader">InputStreamReader</link>&#32;{
1663 <emphasis role="keyword">public</emphasis>:
1664 &#32;&#32;&#32;&#32;<emphasis role="keyword">virtual</emphasis>&#32;<emphasis role="keywordtype">void</emphasis>&#32;setTestCase(<emphasis role="keywordtype">int</emphasis>&#32;testCase)&#32;=&#32;0;
1665 
1666 &#32;&#32;&#32;&#32;<emphasis role="keyword">virtual</emphasis>&#32;std::vector&lt;int&gt;&#32;getReadChars()&#32;=&#32;0;
1667 &#32;&#32;&#32;&#32;
1668 &#32;&#32;&#32;&#32;<emphasis role="keyword">virtual</emphasis>&#32;<emphasis role="keywordtype">int</emphasis>&#32;curChar()&#32;=&#32;0;
1669 
1670 &#32;&#32;&#32;&#32;<emphasis role="keyword">virtual</emphasis>&#32;<emphasis role="keywordtype">int</emphasis>&#32;nextChar()&#32;=&#32;0;
1671 
1672 &#32;&#32;&#32;&#32;<emphasis role="keyword">virtual</emphasis>&#32;<emphasis role="keywordtype">void</emphasis>&#32;skipChar()&#32;=&#32;0;
1673 
1674 &#32;&#32;&#32;&#32;<emphasis role="keyword">virtual</emphasis>&#32;<emphasis role="keywordtype">void</emphasis>&#32;unreadChar(<emphasis role="keywordtype">int</emphasis>&#32;c)&#32;=&#32;0;
1675 
1676 &#32;&#32;&#32;&#32;<emphasis role="keyword">virtual</emphasis>&#32;std::string&#32;getName()&#32;=&#32;0;
1677 
1678 &#32;&#32;&#32;&#32;<emphasis role="keyword">virtual</emphasis>&#32;<emphasis role="keywordtype">bool</emphasis>&#32;eof()&#32;=&#32;0;
1679 
1680 &#32;&#32;&#32;&#32;<emphasis role="keyword">virtual</emphasis>&#32;<emphasis role="keywordtype">void</emphasis>&#32;close()&#32;=&#32;0;
1681 
1682 &#32;&#32;&#32;&#32;<emphasis role="keyword">virtual</emphasis>&#32;<emphasis role="keywordtype">int</emphasis>&#32;getLine()&#32;=&#32;0;
1683 
1684 &#32;&#32;&#32;&#32;<emphasis role="keyword">virtual</emphasis>&#32;<link linkend="_class_input_stream_reader">~InputStreamReader</link>()&#32;=&#32;0;
1685 };
1686 
1687 InputStreamReader::~InputStreamReader()&#32;{
1688 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;No&#32;operations.</emphasis>
1689 }
1690 
1691 <emphasis role="keyword">class&#32;</emphasis><link linkend="_class_string_input_stream_reader">StringInputStreamReader</link>&#32;:&#32;<emphasis role="keyword">public</emphasis>&#32;<link linkend="_class_input_stream_reader">InputStreamReader</link>&#32;{
1692 <emphasis role="keyword">private</emphasis>:
1693 &#32;&#32;&#32;&#32;std::string&#32;s;
1694 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;pos;
1695 
1696 <emphasis role="keyword">public</emphasis>:
1697 &#32;&#32;&#32;&#32;<link linkend="_class_string_input_stream_reader">StringInputStreamReader</link>(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;content)&#32;:&#32;s(content),&#32;pos(0)&#32;{
1698 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;No&#32;operations.</emphasis>
1699 &#32;&#32;&#32;&#32;}
1700 
1701 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;setTestCase(<emphasis role="keywordtype">int</emphasis>)&#32;{
1702 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;setTestCase&#32;not&#32;implemented&#32;in&#32;StringInputStreamReader&quot;</emphasis>);
1703 &#32;&#32;&#32;&#32;}
1704 
1705 &#32;&#32;&#32;&#32;std::vector&lt;int&gt;&#32;getReadChars()&#32;{
1706 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;getReadChars&#32;not&#32;implemented&#32;in&#32;StringInputStreamReader&quot;</emphasis>);
1707 &#32;&#32;&#32;&#32;}
1708 &#32;&#32;&#32;&#32;
1709 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;curChar()&#32;{
1710 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(pos&#32;&gt;=&#32;s.length())
1711 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;EOFC;
1712 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
1713 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;s[pos];
1714 &#32;&#32;&#32;&#32;}
1715 
1716 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;nextChar()&#32;{
1717 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(pos&#32;&gt;=&#32;s.length())&#32;{
1718 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;pos++;
1719 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;EOFC;
1720 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>
1721 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;s[pos++];
1722 &#32;&#32;&#32;&#32;}
1723 
1724 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;skipChar()&#32;{
1725 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;pos++;
1726 &#32;&#32;&#32;&#32;}
1727 
1728 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;unreadChar(<emphasis role="keywordtype">int</emphasis>&#32;c)&#32;{
1729 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(pos&#32;==&#32;0)
1730 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;StringInputStreamReader::unreadChar(int):&#32;pos&#32;==&#32;0.&quot;</emphasis>);
1731 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;pos--;
1732 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(pos&#32;&lt;&#32;s.length())
1733 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;s[pos]&#32;=&#32;char(c);
1734 &#32;&#32;&#32;&#32;}
1735 
1736 &#32;&#32;&#32;&#32;std::string&#32;getName()&#32;{
1737 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__testlib_part(s);
1738 &#32;&#32;&#32;&#32;}
1739 
1740 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;getLine()&#32;{
1741 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;-1;
1742 &#32;&#32;&#32;&#32;}
1743 
1744 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;eof()&#32;{
1745 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;pos&#32;&gt;=&#32;s.length();
1746 &#32;&#32;&#32;&#32;}
1747 
1748 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;close()&#32;{
1749 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;No&#32;operations.</emphasis>
1750 &#32;&#32;&#32;&#32;}
1751 };
1752 
1753 <emphasis role="keyword">class&#32;</emphasis><link linkend="_class_file_input_stream_reader">FileInputStreamReader</link>&#32;:&#32;<emphasis role="keyword">public</emphasis>&#32;<link linkend="_class_input_stream_reader">InputStreamReader</link>&#32;{
1754 <emphasis role="keyword">private</emphasis>:
1755 &#32;&#32;&#32;&#32;std::FILE&#32;*file;
1756 &#32;&#32;&#32;&#32;std::string&#32;name;
1757 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;line;
1758 &#32;&#32;&#32;&#32;std::vector&lt;int&gt;&#32;undoChars;
1759 &#32;&#32;&#32;&#32;std::vector&lt;int&gt;&#32;readChars;
1760 &#32;&#32;&#32;&#32;std::vector&lt;int&gt;&#32;undoReadChars;
1761 
1762 &#32;&#32;&#32;&#32;<emphasis role="keyword">inline</emphasis>&#32;<emphasis role="keywordtype">int</emphasis>&#32;postprocessGetc(<emphasis role="keywordtype">int</emphasis>&#32;getcResult)&#32;{
1763 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(getcResult&#32;!=&#32;EOF)
1764 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;getcResult;
1765 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
1766 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;EOFC;
1767 &#32;&#32;&#32;&#32;}
1768 
1769 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;getc(FILE&#32;*file)&#32;{
1770 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;c;
1771 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;rc;
1772 
1773 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(undoChars.empty())&#32;{
1774 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;c&#32;=&#32;rc&#32;=&#32;::getc(file);
1775 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
1776 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;c&#32;=&#32;undoChars.back();
1777 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;undoChars.pop_back();
1778 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;rc&#32;=&#32;undoReadChars.back();
1779 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;undoReadChars.pop_back();
1780 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1781 
1782 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(c&#32;==&#32;LF)
1783 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;line++;
1784 
1785 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;readChars.push_back(rc);
1786 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;c;
1787 &#32;&#32;&#32;&#32;}
1788 
1789 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;ungetc(<emphasis role="keywordtype">int</emphasis>&#32;c<emphasis role="comment">/*,&#32;FILE*&#32;file*/</emphasis>)&#32;{
1790 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!readChars.empty())&#32;{
1791 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;undoReadChars.push_back(readChars.back());
1792 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;readChars.pop_back();
1793 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1794 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(c&#32;==&#32;LF)
1795 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;line--;
1796 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;undoChars.push_back(c);
1797 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;c;
1798 &#32;&#32;&#32;&#32;}
1799 
1800 <emphasis role="keyword">public</emphasis>:
1801 &#32;&#32;&#32;&#32;<link linkend="_class_file_input_stream_reader">FileInputStreamReader</link>(std::FILE&#32;*file,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;name)&#32;:&#32;file(file),&#32;name(name),&#32;line(1)&#32;{
1802 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;No&#32;operations.</emphasis>
1803 &#32;&#32;&#32;&#32;}
1804 
1805 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;setTestCase(<emphasis role="keywordtype">int</emphasis>&#32;testCase)&#32;{
1806 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(testCase&#32;&lt;&#32;0&#32;||&#32;testCase&#32;&gt;&#32;__TESTLIB_MAX_TEST_CASE)
1807 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(format(<emphasis role="stringliteral">&quot;testCase&#32;expected&#32;fit&#32;in&#32;[1,%d],&#32;but&#32;%d&#32;doesn&apos;t&quot;</emphasis>,&#32;__TESTLIB_MAX_TEST_CASE,&#32;testCase));
1808 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;readChars.push_back(testCase&#32;+&#32;256);
1809 &#32;&#32;&#32;&#32;}
1810 
1811 &#32;&#32;&#32;&#32;std::vector&lt;int&gt;&#32;getReadChars()&#32;{
1812 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;readChars;
1813 &#32;&#32;&#32;&#32;}
1814 
1815 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;curChar()&#32;{
1816 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(feof(file))
1817 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;EOFC;
1818 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
1819 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;c&#32;=&#32;getc(file);
1820 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;ungetc(c<emphasis role="comment">/*,&#32;file*/</emphasis>);
1821 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;postprocessGetc(c);
1822 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1823 &#32;&#32;&#32;&#32;}
1824 
1825 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;nextChar()&#32;{
1826 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(feof(file))
1827 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;EOFC;
1828 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
1829 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;postprocessGetc(getc(file));
1830 &#32;&#32;&#32;&#32;}
1831 
1832 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;skipChar()&#32;{
1833 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;getc(file);
1834 &#32;&#32;&#32;&#32;}
1835 
1836 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;unreadChar(<emphasis role="keywordtype">int</emphasis>&#32;c)&#32;{
1837 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;ungetc(c<emphasis role="comment">/*,&#32;file*/</emphasis>);
1838 &#32;&#32;&#32;&#32;}
1839 
1840 &#32;&#32;&#32;&#32;std::string&#32;getName()&#32;{
1841 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;name;
1842 &#32;&#32;&#32;&#32;}
1843 
1844 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;getLine()&#32;{
1845 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;line;
1846 &#32;&#32;&#32;&#32;}
1847 
1848 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;eof()&#32;{
1849 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(NULL&#32;==&#32;file&#32;||&#32;feof(file))
1850 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">true</emphasis>;
1851 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
1852 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;c&#32;=&#32;nextChar();
1853 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(c&#32;==&#32;EOFC&#32;||&#32;(c&#32;==&#32;EOF&#32;&amp;&amp;&#32;feof(file)))
1854 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">true</emphasis>;
1855 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;unreadChar(c);
1856 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
1857 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1858 &#32;&#32;&#32;&#32;}
1859 
1860 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;close()&#32;{
1861 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(NULL&#32;!=&#32;file)&#32;{
1862 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;fclose(file);
1863 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;file&#32;=&#32;NULL;
1864 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1865 &#32;&#32;&#32;&#32;}
1866 };
1867 
1868 <emphasis role="keyword">class&#32;</emphasis><link linkend="_class_buffered_file_input_stream_reader">BufferedFileInputStreamReader</link>&#32;:&#32;<emphasis role="keyword">public</emphasis>&#32;<link linkend="_class_input_stream_reader">InputStreamReader</link>&#32;{
1869 <emphasis role="keyword">private</emphasis>:
1870 &#32;&#32;&#32;&#32;<emphasis role="keyword">static</emphasis>&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;BUFFER_SIZE;
1871 &#32;&#32;&#32;&#32;<emphasis role="keyword">static</emphasis>&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;MAX_UNREAD_COUNT;
1872 
1873 &#32;&#32;&#32;&#32;std::FILE&#32;*file;
1874 &#32;&#32;&#32;&#32;std::string&#32;name;
1875 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;line;
1876 
1877 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">char</emphasis>&#32;*buffer;
1878 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;*isEof;
1879 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;bufferPos;
1880 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;bufferSize;
1881 
1882 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;refill()&#32;{
1883 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(NULL&#32;==&#32;file)
1884 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;BufferedFileInputStreamReader:&#32;file&#32;==&#32;NULL&#32;(&quot;</emphasis>&#32;+&#32;getName()&#32;+&#32;<emphasis role="stringliteral">&quot;)&quot;</emphasis>);
1885 
1886 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(bufferPos&#32;&gt;=&#32;<emphasis role="keywordtype">int</emphasis>(bufferSize))&#32;{
1887 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;readSize&#32;=&#32;fread(
1888 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;buffer&#32;+&#32;MAX_UNREAD_COUNT,
1889 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;1,
1890 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;BUFFER_SIZE&#32;-&#32;MAX_UNREAD_COUNT,
1891 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;file
1892 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;);
1893 
1894 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(readSize&#32;&lt;&#32;BUFFER_SIZE&#32;-&#32;MAX_UNREAD_COUNT
1895 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&amp;&amp;&#32;ferror(file))
1896 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;BufferedFileInputStreamReader:&#32;unable&#32;to&#32;read&#32;(&quot;</emphasis>&#32;+&#32;getName()&#32;+&#32;<emphasis role="stringliteral">&quot;)&quot;</emphasis>);
1897 
1898 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;bufferSize&#32;=&#32;MAX_UNREAD_COUNT&#32;+&#32;readSize;
1899 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;bufferPos&#32;=&#32;int(MAX_UNREAD_COUNT);
1900 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::memset(isEof&#32;+&#32;MAX_UNREAD_COUNT,&#32;0,&#32;<emphasis role="keyword">sizeof</emphasis>(isEof[0])&#32;*&#32;readSize);
1901 
1902 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;readSize&#32;&gt;&#32;0;
1903 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>
1904 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">true</emphasis>;
1905 &#32;&#32;&#32;&#32;}
1906 
1907 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">char</emphasis>&#32;increment()&#32;{
1908 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">char</emphasis>&#32;c;
1909 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;((c&#32;=&#32;buffer[bufferPos++])&#32;==&#32;LF)
1910 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;line++;
1911 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;c;
1912 &#32;&#32;&#32;&#32;}
1913 
1914 <emphasis role="keyword">public</emphasis>:
1915 &#32;&#32;&#32;&#32;<link linkend="_class_buffered_file_input_stream_reader">BufferedFileInputStreamReader</link>(std::FILE&#32;*file,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;name)&#32;:&#32;file(file),&#32;name(name),&#32;line(1)&#32;{
1916 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;buffer&#32;=&#32;<emphasis role="keyword">new</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>[BUFFER_SIZE];
1917 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;isEof&#32;=&#32;<emphasis role="keyword">new</emphasis>&#32;<emphasis role="keywordtype">bool</emphasis>[BUFFER_SIZE];
1918 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;bufferSize&#32;=&#32;MAX_UNREAD_COUNT;
1919 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;bufferPos&#32;=&#32;int(MAX_UNREAD_COUNT);
1920 &#32;&#32;&#32;&#32;}
1921 
1922 &#32;&#32;&#32;&#32;<link linkend="_class_buffered_file_input_stream_reader">~BufferedFileInputStreamReader</link>()&#32;{
1923 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(NULL&#32;!=&#32;buffer)&#32;{
1924 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">delete</emphasis>[]&#32;buffer;
1925 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;buffer&#32;=&#32;NULL;
1926 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1927 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(NULL&#32;!=&#32;isEof)&#32;{
1928 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">delete</emphasis>[]&#32;isEof;
1929 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;isEof&#32;=&#32;NULL;
1930 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1931 &#32;&#32;&#32;&#32;}
1932 
1933 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;setTestCase(<emphasis role="keywordtype">int</emphasis>)&#32;{
1934 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;setTestCase&#32;not&#32;implemented&#32;in&#32;BufferedFileInputStreamReader&quot;</emphasis>);
1935 &#32;&#32;&#32;&#32;}
1936 
1937 &#32;&#32;&#32;&#32;std::vector&lt;int&gt;&#32;getReadChars()&#32;{
1938 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;getReadChars&#32;not&#32;implemented&#32;in&#32;BufferedFileInputStreamReader&quot;</emphasis>);
1939 &#32;&#32;&#32;&#32;}
1940 &#32;&#32;&#32;&#32;
1941 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;curChar()&#32;{
1942 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!refill())
1943 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;EOFC;
1944 
1945 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;isEof[bufferPos]&#32;?&#32;EOFC&#32;:&#32;buffer[bufferPos];
1946 &#32;&#32;&#32;&#32;}
1947 
1948 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;nextChar()&#32;{
1949 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!refill())
1950 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;EOFC;
1951 
1952 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;isEof[bufferPos]&#32;?&#32;EOFC&#32;:&#32;increment();
1953 &#32;&#32;&#32;&#32;}
1954 
1955 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;skipChar()&#32;{
1956 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;increment();
1957 &#32;&#32;&#32;&#32;}
1958 
1959 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;unreadChar(<emphasis role="keywordtype">int</emphasis>&#32;c)&#32;{
1960 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;bufferPos--;
1961 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(bufferPos&#32;&lt;&#32;0)
1962 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;BufferedFileInputStreamReader::unreadChar(int):&#32;bufferPos&#32;&lt;&#32;0&quot;</emphasis>);
1963 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;isEof[bufferPos]&#32;=&#32;(c&#32;==&#32;EOFC);
1964 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;buffer[bufferPos]&#32;=&#32;char(c);
1965 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(c&#32;==&#32;LF)
1966 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;line--;
1967 &#32;&#32;&#32;&#32;}
1968 
1969 &#32;&#32;&#32;&#32;std::string&#32;getName()&#32;{
1970 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;name;
1971 &#32;&#32;&#32;&#32;}
1972 
1973 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;getLine()&#32;{
1974 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;line;
1975 &#32;&#32;&#32;&#32;}
1976 
1977 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;eof()&#32;{
1978 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;!refill()&#32;||&#32;EOFC&#32;==&#32;curChar();
1979 &#32;&#32;&#32;&#32;}
1980 
1981 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;close()&#32;{
1982 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(NULL&#32;!=&#32;file)&#32;{
1983 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;fclose(file);
1984 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;file&#32;=&#32;NULL;
1985 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1986 &#32;&#32;&#32;&#32;}
1987 };
1988 
1989 <emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;BufferedFileInputStreamReader::BUFFER_SIZE&#32;=&#32;2000000;
1990 <emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;BufferedFileInputStreamReader::MAX_UNREAD_COUNT&#32;=&#32;BufferedFileInputStreamReader::BUFFER_SIZE&#32;/&#32;2;
1991 
1992 <emphasis role="comment">/*</emphasis>
1993 <emphasis role="comment">&#32;*&#32;Streams&#32;to&#32;be&#32;used&#32;for&#32;reading&#32;data&#32;in&#32;checkers&#32;or&#32;validators.</emphasis>
1994 <emphasis role="comment">&#32;*&#32;Each&#32;read*()&#32;method&#32;moves&#32;pointer&#32;to&#32;the&#32;next&#32;character&#32;after&#32;the</emphasis>
1995 <emphasis role="comment">&#32;*&#32;read&#32;value.</emphasis>
1996 <emphasis role="comment">&#32;*/</emphasis>
1997 <emphasis role="keyword">struct&#32;</emphasis><link linkend="_struct_in_stream">InStream</link>&#32;{
1998 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Do&#32;not&#32;use&#32;them.&#32;*/</emphasis>
1999 &#32;&#32;&#32;&#32;<link linkend="_struct_in_stream">InStream</link>();
2000 
2001 &#32;&#32;&#32;&#32;<link linkend="_struct_in_stream">~InStream</link>();
2002 
2003 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Wrap&#32;std::string&#32;with&#32;InStream.&#32;*/</emphasis>
2004 &#32;&#32;&#32;&#32;<link linkend="_struct_in_stream">InStream</link>(<emphasis role="keyword">const</emphasis>&#32;<link linkend="_struct_in_stream">InStream</link>&#32;&amp;baseStream,&#32;std::string&#32;content);
2005 
2006 &#32;&#32;&#32;&#32;<link linkend="_class_input_stream_reader">InputStreamReader</link>&#32;*reader;
2007 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;lastLine;
2008 
2009 &#32;&#32;&#32;&#32;std::string&#32;name;
2010 &#32;&#32;&#32;&#32;TMode&#32;mode;
2011 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;opened;
2012 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;stdfile;
2013 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;strict;
2014 
2015 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;wordReserveSize;
2016 &#32;&#32;&#32;&#32;std::string&#32;_tmpReadToken;
2017 
2018 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;readManyIteration;
2019 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;maxFileSize;
2020 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;maxTokenLength;
2021 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;maxMessageLength;
2022 
2023 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;init(std::string&#32;fileName,&#32;TMode&#32;mode);
2024 
2025 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;init(std::FILE&#32;*f,&#32;TMode&#32;mode);
2026 
2027 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;setTestCase(<emphasis role="keywordtype">int</emphasis>&#32;testCase);
2028 &#32;&#32;&#32;&#32;std::vector&lt;int&gt;&#32;getReadChars();
2029 
2030 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Moves&#32;stream&#32;pointer&#32;to&#32;the&#32;first&#32;non-white-space&#32;character&#32;or&#32;EOF.&#32;*/</emphasis>
2031 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;skipBlanks();
2032 
2033 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Returns&#32;current&#32;character&#32;in&#32;the&#32;stream.&#32;Doesn&apos;t&#32;remove&#32;it&#32;from&#32;stream.&#32;*/</emphasis>
2034 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">char</emphasis>&#32;curChar();
2035 
2036 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Moves&#32;stream&#32;pointer&#32;one&#32;character&#32;forward.&#32;*/</emphasis>
2037 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;skipChar();
2038 
2039 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Returns&#32;current&#32;character&#32;and&#32;moves&#32;pointer&#32;one&#32;character&#32;forward.&#32;*/</emphasis>
2040 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">char</emphasis>&#32;nextChar();
2041 
2042 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Returns&#32;current&#32;character&#32;and&#32;moves&#32;pointer&#32;one&#32;character&#32;forward.&#32;*/</emphasis>
2043 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">char</emphasis>&#32;readChar();
2044 
2045 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;As&#32;&quot;readChar()&quot;&#32;but&#32;ensures&#32;that&#32;the&#32;result&#32;is&#32;equal&#32;to&#32;given&#32;parameter.&#32;*/</emphasis>
2046 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">char</emphasis>&#32;readChar(<emphasis role="keywordtype">char</emphasis>&#32;c);
2047 
2048 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;As&#32;&quot;readChar()&quot;&#32;but&#32;ensures&#32;that&#32;the&#32;result&#32;is&#32;equal&#32;to&#32;the&#32;space&#32;(code=32).&#32;*/</emphasis>
2049 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">char</emphasis>&#32;readSpace();
2050 
2051 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Puts&#32;back&#32;the&#32;character&#32;into&#32;the&#32;stream.&#32;*/</emphasis>
2052 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;unreadChar(<emphasis role="keywordtype">char</emphasis>&#32;c);
2053 
2054 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Reopens&#32;stream,&#32;you&#32;should&#32;not&#32;use&#32;it.&#32;*/</emphasis>
2055 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;reset(std::FILE&#32;*file&#32;=&#32;NULL);
2056 
2057 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Checks&#32;that&#32;current&#32;position&#32;is&#32;EOF.&#32;If&#32;not&#32;it&#32;doesn&apos;t&#32;move&#32;stream&#32;pointer.&#32;*/</emphasis>
2058 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;eof();
2059 
2060 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Moves&#32;pointer&#32;to&#32;the&#32;first&#32;non-white-space&#32;character&#32;and&#32;calls&#32;&quot;eof()&quot;.&#32;*/</emphasis>
2061 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;seekEof();
2062 
2063 &#32;&#32;&#32;&#32;<emphasis role="comment">/*</emphasis>
2064 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*&#32;Checks&#32;that&#32;current&#32;position&#32;contains&#32;EOLN.</emphasis>
2065 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*&#32;If&#32;not&#32;it&#32;doesn&apos;t&#32;move&#32;stream&#32;pointer.</emphasis>
2066 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*&#32;In&#32;strict&#32;mode&#32;expects&#32;&quot;#13#10&quot;&#32;for&#32;windows&#32;or&#32;&quot;#10&quot;&#32;for&#32;other&#32;platforms.</emphasis>
2067 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*/</emphasis>
2068 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;eoln();
2069 
2070 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Moves&#32;pointer&#32;to&#32;the&#32;first&#32;non-space&#32;and&#32;non-tab&#32;character&#32;and&#32;calls&#32;&quot;eoln()&quot;.&#32;*/</emphasis>
2071 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;seekEoln();
2072 
2073 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Moves&#32;stream&#32;pointer&#32;to&#32;the&#32;first&#32;character&#32;of&#32;the&#32;next&#32;line&#32;(if&#32;exists).&#32;*/</emphasis>
2074 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;nextLine();
2075 
2076 &#32;&#32;&#32;&#32;<emphasis role="comment">/*</emphasis>
2077 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*&#32;Reads&#32;new&#32;token.&#32;Ignores&#32;white-spaces&#32;into&#32;the&#32;non-strict&#32;mode</emphasis>
2078 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*&#32;(strict&#32;mode&#32;is&#32;used&#32;in&#32;validators&#32;usually).</emphasis>
2079 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*/</emphasis>
2080 &#32;&#32;&#32;&#32;std::string&#32;readWord();
2081 
2082 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;The&#32;same&#32;as&#32;&quot;readWord()&quot;,&#32;it&#32;is&#32;preferred&#32;to&#32;use&#32;&quot;readToken()&quot;.&#32;*/</emphasis>
2083 &#32;&#32;&#32;&#32;std::string&#32;readToken();
2084 
2085 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;The&#32;same&#32;as&#32;&quot;readWord()&quot;,&#32;but&#32;ensures&#32;that&#32;token&#32;matches&#32;to&#32;given&#32;pattern.&#32;*/</emphasis>
2086 &#32;&#32;&#32;&#32;std::string&#32;readWord(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;ptrn,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>);
2087 
2088 &#32;&#32;&#32;&#32;std::string&#32;readWord(<emphasis role="keyword">const</emphasis>&#32;<link linkend="_classpattern">pattern</link>&#32;&amp;p,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>);
2089 
2090 &#32;&#32;&#32;&#32;std::vector&lt;std::string&gt;
2091 &#32;&#32;&#32;&#32;readWords(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;ptrn,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variablesName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase&#32;=&#32;1);
2092 
2093 &#32;&#32;&#32;&#32;std::vector&lt;std::string&gt;
2094 &#32;&#32;&#32;&#32;readWords(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keyword">const</emphasis>&#32;<link linkend="_classpattern">pattern</link>&#32;&amp;p,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variablesName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase&#32;=&#32;1);
2095 
2096 &#32;&#32;&#32;&#32;std::vector&lt;std::string&gt;&#32;readWords(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase&#32;=&#32;1);
2097 
2098 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;The&#32;same&#32;as&#32;&quot;readToken()&quot;,&#32;but&#32;ensures&#32;that&#32;token&#32;matches&#32;to&#32;given&#32;pattern.&#32;*/</emphasis>
2099 &#32;&#32;&#32;&#32;std::string&#32;readToken(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;ptrn,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>);
2100 
2101 &#32;&#32;&#32;&#32;std::string&#32;readToken(<emphasis role="keyword">const</emphasis>&#32;<link linkend="_classpattern">pattern</link>&#32;&amp;p,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>);
2102 
2103 &#32;&#32;&#32;&#32;std::vector&lt;std::string&gt;
2104 &#32;&#32;&#32;&#32;readTokens(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;ptrn,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variablesName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase&#32;=&#32;1);
2105 
2106 &#32;&#32;&#32;&#32;std::vector&lt;std::string&gt;
2107 &#32;&#32;&#32;&#32;readTokens(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keyword">const</emphasis>&#32;<link linkend="_classpattern">pattern</link>&#32;&amp;p,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variablesName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase&#32;=&#32;1);
2108 
2109 &#32;&#32;&#32;&#32;std::vector&lt;std::string&gt;&#32;readTokens(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase&#32;=&#32;1);
2110 
2111 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;readWordTo(std::string&#32;&amp;result);
2112 
2113 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;readWordTo(std::string&#32;&amp;result,&#32;<emphasis role="keyword">const</emphasis>&#32;<link linkend="_classpattern">pattern</link>&#32;&amp;p,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>);
2114 
2115 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;readWordTo(std::string&#32;&amp;result,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;ptrn,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>);
2116 
2117 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;readTokenTo(std::string&#32;&amp;result);
2118 
2119 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;readTokenTo(std::string&#32;&amp;result,&#32;<emphasis role="keyword">const</emphasis>&#32;<link linkend="_classpattern">pattern</link>&#32;&amp;p,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>);
2120 
2121 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;readTokenTo(std::string&#32;&amp;result,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;ptrn,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>);
2122 
2123 &#32;&#32;&#32;&#32;<emphasis role="comment">/*</emphasis>
2124 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*&#32;Reads&#32;new&#32;long&#32;long&#32;value.&#32;Ignores&#32;white-spaces&#32;into&#32;the&#32;non-strict&#32;mode</emphasis>
2125 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*&#32;(strict&#32;mode&#32;is&#32;used&#32;in&#32;validators&#32;usually).</emphasis>
2126 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*/</emphasis>
2127 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;readLong();
2128 
2129 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;readUnsignedLong();
2130 
2131 &#32;&#32;&#32;&#32;<emphasis role="comment">/*</emphasis>
2132 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*&#32;Reads&#32;new&#32;int.&#32;Ignores&#32;white-spaces&#32;into&#32;the&#32;non-strict&#32;mode</emphasis>
2133 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*&#32;(strict&#32;mode&#32;is&#32;used&#32;in&#32;validators&#32;usually).</emphasis>
2134 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*/</emphasis>
2135 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;readInteger();
2136 
2137 &#32;&#32;&#32;&#32;<emphasis role="comment">/*</emphasis>
2138 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*&#32;Reads&#32;new&#32;int.&#32;Ignores&#32;white-spaces&#32;into&#32;the&#32;non-strict&#32;mode</emphasis>
2139 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*&#32;(strict&#32;mode&#32;is&#32;used&#32;in&#32;validators&#32;usually).</emphasis>
2140 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*/</emphasis>
2141 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;readInt();
2142 
2143 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;As&#32;&quot;readLong()&quot;&#32;but&#32;ensures&#32;that&#32;value&#32;in&#32;the&#32;range&#32;[minv,maxv].&#32;*/</emphasis>
2144 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;readLong(<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;minv,&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;maxv,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>);
2145 
2146 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Reads&#32;space-separated&#32;sequence&#32;of&#32;long&#32;longs.&#32;*/</emphasis>
2147 &#32;&#32;&#32;&#32;std::vector&lt;long&#32;long&gt;
2148 &#32;&#32;&#32;&#32;readLongs(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;minv,&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;maxv,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variablesName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase&#32;=&#32;1);
2149 
2150 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Reads&#32;space-separated&#32;sequence&#32;of&#32;long&#32;longs.&#32;*/</emphasis>
2151 &#32;&#32;&#32;&#32;std::vector&lt;long&#32;long&gt;&#32;readLongs(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase&#32;=&#32;1);
2152 
2153 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>
2154 &#32;&#32;&#32;&#32;readUnsignedLong(<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;minv,&#32;<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;maxv,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>);
2155 
2156 &#32;&#32;&#32;&#32;std::vector&lt;unsigned&#32;long&#32;long&gt;
2157 &#32;&#32;&#32;&#32;readUnsignedLongs(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;minv,&#32;<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;maxv,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variablesName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>,
2158 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase&#32;=&#32;1);
2159 
2160 &#32;&#32;&#32;&#32;std::vector&lt;unsigned&#32;long&#32;long&gt;&#32;readUnsignedLongs(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase&#32;=&#32;1);
2161 
2162 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;readLong(<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;minv,&#32;<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;maxv,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>);
2163 
2164 &#32;&#32;&#32;&#32;std::vector&lt;unsigned&#32;long&#32;long&gt;
2165 &#32;&#32;&#32;&#32;readLongs(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;minv,&#32;<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;maxv,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variablesName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>,
2166 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase&#32;=&#32;1);
2167 
2168 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;As&#32;&quot;readInteger()&quot;&#32;but&#32;ensures&#32;that&#32;value&#32;in&#32;the&#32;range&#32;[minv,maxv].&#32;*/</emphasis>
2169 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;readInteger(<emphasis role="keywordtype">int</emphasis>&#32;minv,&#32;<emphasis role="keywordtype">int</emphasis>&#32;maxv,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>);
2170 
2171 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;As&#32;&quot;readInt()&quot;&#32;but&#32;ensures&#32;that&#32;value&#32;in&#32;the&#32;range&#32;[minv,maxv].&#32;*/</emphasis>
2172 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;readInt(<emphasis role="keywordtype">int</emphasis>&#32;minv,&#32;<emphasis role="keywordtype">int</emphasis>&#32;maxv,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>);
2173 
2174 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Reads&#32;space-separated&#32;sequence&#32;of&#32;integers.&#32;*/</emphasis>
2175 &#32;&#32;&#32;&#32;std::vector&lt;int&gt;
2176 &#32;&#32;&#32;&#32;readIntegers(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keywordtype">int</emphasis>&#32;minv,&#32;<emphasis role="keywordtype">int</emphasis>&#32;maxv,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variablesName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase&#32;=&#32;1);
2177 
2178 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Reads&#32;space-separated&#32;sequence&#32;of&#32;integers.&#32;*/</emphasis>
2179 &#32;&#32;&#32;&#32;std::vector&lt;int&gt;&#32;readIntegers(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase&#32;=&#32;1);
2180 
2181 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Reads&#32;space-separated&#32;sequence&#32;of&#32;integers.&#32;*/</emphasis>
2182 &#32;&#32;&#32;&#32;std::vector&lt;int&gt;&#32;readInts(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keywordtype">int</emphasis>&#32;minv,&#32;<emphasis role="keywordtype">int</emphasis>&#32;maxv,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variablesName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase&#32;=&#32;1);
2183 
2184 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Reads&#32;space-separated&#32;sequence&#32;of&#32;integers.&#32;*/</emphasis>
2185 &#32;&#32;&#32;&#32;std::vector&lt;int&gt;&#32;readInts(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase&#32;=&#32;1);
2186 
2187 &#32;&#32;&#32;&#32;<emphasis role="comment">/*</emphasis>
2188 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*&#32;Reads&#32;new&#32;double.&#32;Ignores&#32;white-spaces&#32;into&#32;the&#32;non-strict&#32;mode</emphasis>
2189 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*&#32;(strict&#32;mode&#32;is&#32;used&#32;in&#32;validators&#32;usually).</emphasis>
2190 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*/</emphasis>
2191 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">double</emphasis>&#32;readReal();
2192 
2193 &#32;&#32;&#32;&#32;<emphasis role="comment">/*</emphasis>
2194 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*&#32;Reads&#32;new&#32;double.&#32;Ignores&#32;white-spaces&#32;into&#32;the&#32;non-strict&#32;mode</emphasis>
2195 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*&#32;(strict&#32;mode&#32;is&#32;used&#32;in&#32;validators&#32;usually).</emphasis>
2196 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*/</emphasis>
2197 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">double</emphasis>&#32;readDouble();
2198 
2199 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;As&#32;&quot;readReal()&quot;&#32;but&#32;ensures&#32;that&#32;value&#32;in&#32;the&#32;range&#32;[minv,maxv].&#32;*/</emphasis>
2200 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">double</emphasis>&#32;readReal(<emphasis role="keywordtype">double</emphasis>&#32;minv,&#32;<emphasis role="keywordtype">double</emphasis>&#32;maxv,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>);
2201 
2202 &#32;&#32;&#32;&#32;std::vector&lt;double&gt;
2203 &#32;&#32;&#32;&#32;readReals(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keywordtype">double</emphasis>&#32;minv,&#32;<emphasis role="keywordtype">double</emphasis>&#32;maxv,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variablesName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase&#32;=&#32;1);
2204 
2205 &#32;&#32;&#32;&#32;std::vector&lt;double&gt;&#32;readReals(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase&#32;=&#32;1);
2206 
2207 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;As&#32;&quot;readDouble()&quot;&#32;but&#32;ensures&#32;that&#32;value&#32;in&#32;the&#32;range&#32;[minv,maxv].&#32;*/</emphasis>
2208 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">double</emphasis>&#32;readDouble(<emphasis role="keywordtype">double</emphasis>&#32;minv,&#32;<emphasis role="keywordtype">double</emphasis>&#32;maxv,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>);
2209 
2210 &#32;&#32;&#32;&#32;std::vector&lt;double&gt;
2211 &#32;&#32;&#32;&#32;readDoubles(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keywordtype">double</emphasis>&#32;minv,&#32;<emphasis role="keywordtype">double</emphasis>&#32;maxv,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variablesName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase&#32;=&#32;1);
2212 
2213 &#32;&#32;&#32;&#32;std::vector&lt;double&gt;&#32;readDoubles(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase&#32;=&#32;1);
2214 
2215 &#32;&#32;&#32;&#32;<emphasis role="comment">/*</emphasis>
2216 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*&#32;As&#32;&quot;readReal()&quot;&#32;but&#32;ensures&#32;that&#32;value&#32;in&#32;the&#32;range&#32;[minv,maxv]&#32;and</emphasis>
2217 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*&#32;number&#32;of&#32;digit&#32;after&#32;the&#32;decimal&#32;point&#32;is&#32;in&#32;range&#32;[minAfterPointDigitCount,maxAfterPointDigitCount]</emphasis>
2218 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*&#32;and&#32;number&#32;is&#32;in&#32;the&#32;form&#32;&quot;[-]digit(s)[.digit(s)]&quot;.</emphasis>
2219 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*/</emphasis>
2220 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">double</emphasis>&#32;readStrictReal(<emphasis role="keywordtype">double</emphasis>&#32;minv,&#32;<emphasis role="keywordtype">double</emphasis>&#32;maxv,
2221 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;minAfterPointDigitCount,&#32;<emphasis role="keywordtype">int</emphasis>&#32;maxAfterPointDigitCount,
2222 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>);
2223 
2224 &#32;&#32;&#32;&#32;std::vector&lt;double&gt;&#32;readStrictReals(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keywordtype">double</emphasis>&#32;minv,&#32;<emphasis role="keywordtype">double</emphasis>&#32;maxv,
2225 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;minAfterPointDigitCount,&#32;<emphasis role="keywordtype">int</emphasis>&#32;maxAfterPointDigitCount,
2226 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variablesName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase&#32;=&#32;1);
2227 
2228 &#32;&#32;&#32;&#32;<emphasis role="comment">/*</emphasis>
2229 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*&#32;As&#32;&quot;readDouble()&quot;&#32;but&#32;ensures&#32;that&#32;value&#32;in&#32;the&#32;range&#32;[minv,maxv]&#32;and</emphasis>
2230 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*&#32;number&#32;of&#32;digit&#32;after&#32;the&#32;decimal&#32;point&#32;is&#32;in&#32;range&#32;[minAfterPointDigitCount,maxAfterPointDigitCount]</emphasis>
2231 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*&#32;and&#32;number&#32;is&#32;in&#32;the&#32;form&#32;&quot;[-]digit(s)[.digit(s)]&quot;.</emphasis>
2232 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*/</emphasis>
2233 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">double</emphasis>&#32;readStrictDouble(<emphasis role="keywordtype">double</emphasis>&#32;minv,&#32;<emphasis role="keywordtype">double</emphasis>&#32;maxv,
2234 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;minAfterPointDigitCount,&#32;<emphasis role="keywordtype">int</emphasis>&#32;maxAfterPointDigitCount,
2235 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>);
2236 
2237 &#32;&#32;&#32;&#32;std::vector&lt;double&gt;&#32;readStrictDoubles(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keywordtype">double</emphasis>&#32;minv,&#32;<emphasis role="keywordtype">double</emphasis>&#32;maxv,
2238 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;minAfterPointDigitCount,&#32;<emphasis role="keywordtype">int</emphasis>&#32;maxAfterPointDigitCount,
2239 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variablesName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase&#32;=&#32;1);
2240 
2241 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;As&#32;readLine().&#32;*/</emphasis>
2242 &#32;&#32;&#32;&#32;std::string&#32;readString();
2243 
2244 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Read&#32;many&#32;lines.&#32;*/</emphasis>
2245 &#32;&#32;&#32;&#32;std::vector&lt;std::string&gt;&#32;readStrings(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase&#32;=&#32;1);
2246 
2247 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;See&#32;readLine().&#32;*/</emphasis>
2248 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;readStringTo(std::string&#32;&amp;result);
2249 
2250 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;The&#32;same&#32;as&#32;&quot;readLine()/readString()&quot;,&#32;but&#32;ensures&#32;that&#32;line&#32;matches&#32;to&#32;the&#32;given&#32;pattern.&#32;*/</emphasis>
2251 &#32;&#32;&#32;&#32;std::string&#32;readString(<emphasis role="keyword">const</emphasis>&#32;<link linkend="_classpattern">pattern</link>&#32;&amp;p,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>);
2252 
2253 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;The&#32;same&#32;as&#32;&quot;readLine()/readString()&quot;,&#32;but&#32;ensures&#32;that&#32;line&#32;matches&#32;to&#32;the&#32;given&#32;pattern.&#32;*/</emphasis>
2254 &#32;&#32;&#32;&#32;std::string&#32;readString(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;ptrn,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>);
2255 
2256 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Read&#32;many&#32;lines.&#32;*/</emphasis>
2257 &#32;&#32;&#32;&#32;std::vector&lt;std::string&gt;
2258 &#32;&#32;&#32;&#32;readStrings(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keyword">const</emphasis>&#32;<link linkend="_classpattern">pattern</link>&#32;&amp;p,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase&#32;=&#32;1);
2259 
2260 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Read&#32;many&#32;lines.&#32;*/</emphasis>
2261 &#32;&#32;&#32;&#32;std::vector&lt;std::string&gt;
2262 &#32;&#32;&#32;&#32;readStrings(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;ptrn,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase&#32;=&#32;1);
2263 
2264 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;The&#32;same&#32;as&#32;&quot;readLine()/readString()&quot;,&#32;but&#32;ensures&#32;that&#32;line&#32;matches&#32;to&#32;the&#32;given&#32;pattern.&#32;*/</emphasis>
2265 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;readStringTo(std::string&#32;&amp;result,&#32;<emphasis role="keyword">const</emphasis>&#32;<link linkend="_classpattern">pattern</link>&#32;&amp;p,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>);
2266 
2267 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;The&#32;same&#32;as&#32;&quot;readLine()/readString()&quot;,&#32;but&#32;ensures&#32;that&#32;line&#32;matches&#32;to&#32;the&#32;given&#32;pattern.&#32;*/</emphasis>
2268 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;readStringTo(std::string&#32;&amp;result,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;ptrn,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>);
2269 
2270 &#32;&#32;&#32;&#32;<emphasis role="comment">/*</emphasis>
2271 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*&#32;Reads&#32;line&#32;from&#32;the&#32;current&#32;position&#32;to&#32;EOLN&#32;or&#32;EOF.&#32;Moves&#32;stream&#32;pointer&#32;to</emphasis>
2272 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*&#32;the&#32;first&#32;character&#32;of&#32;the&#32;new&#32;line&#32;(if&#32;possible).</emphasis>
2273 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*/</emphasis>
2274 &#32;&#32;&#32;&#32;std::string&#32;readLine();
2275 
2276 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Read&#32;many&#32;lines.&#32;*/</emphasis>
2277 &#32;&#32;&#32;&#32;std::vector&lt;std::string&gt;&#32;readLines(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase&#32;=&#32;1);
2278 
2279 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;See&#32;readLine().&#32;*/</emphasis>
2280 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;readLineTo(std::string&#32;&amp;result);
2281 
2282 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;The&#32;same&#32;as&#32;&quot;readLine()&quot;,&#32;but&#32;ensures&#32;that&#32;line&#32;matches&#32;to&#32;the&#32;given&#32;pattern.&#32;*/</emphasis>
2283 &#32;&#32;&#32;&#32;std::string&#32;readLine(<emphasis role="keyword">const</emphasis>&#32;<link linkend="_classpattern">pattern</link>&#32;&amp;p,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>);
2284 
2285 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;The&#32;same&#32;as&#32;&quot;readLine()&quot;,&#32;but&#32;ensures&#32;that&#32;line&#32;matches&#32;to&#32;the&#32;given&#32;pattern.&#32;*/</emphasis>
2286 &#32;&#32;&#32;&#32;std::string&#32;readLine(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;ptrn,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>);
2287 
2288 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Read&#32;many&#32;lines.&#32;*/</emphasis>
2289 &#32;&#32;&#32;&#32;std::vector&lt;std::string&gt;
2290 &#32;&#32;&#32;&#32;readLines(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keyword">const</emphasis>&#32;<link linkend="_classpattern">pattern</link>&#32;&amp;p,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase&#32;=&#32;1);
2291 
2292 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Read&#32;many&#32;lines.&#32;*/</emphasis>
2293 &#32;&#32;&#32;&#32;std::vector&lt;std::string&gt;
2294 &#32;&#32;&#32;&#32;readLines(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;ptrn,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase&#32;=&#32;1);
2295 
2296 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;The&#32;same&#32;as&#32;&quot;readLine()&quot;,&#32;but&#32;ensures&#32;that&#32;line&#32;matches&#32;to&#32;the&#32;given&#32;pattern.&#32;*/</emphasis>
2297 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;readLineTo(std::string&#32;&amp;result,&#32;<emphasis role="keyword">const</emphasis>&#32;<link linkend="_classpattern">pattern</link>&#32;&amp;p,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>);
2298 
2299 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;The&#32;same&#32;as&#32;&quot;readLine()&quot;,&#32;but&#32;ensures&#32;that&#32;line&#32;matches&#32;to&#32;the&#32;given&#32;pattern.&#32;*/</emphasis>
2300 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;readLineTo(std::string&#32;&amp;result,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;ptrn,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>);
2301 
2302 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Reads&#32;EOLN&#32;or&#32;fails.&#32;Use&#32;it&#32;in&#32;validators.&#32;Calls&#32;&quot;eoln()&quot;&#32;method&#32;internally.&#32;*/</emphasis>
2303 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;readEoln();
2304 
2305 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Reads&#32;EOF&#32;or&#32;fails.&#32;Use&#32;it&#32;in&#32;validators.&#32;Calls&#32;&quot;eof()&quot;&#32;method&#32;internally.&#32;*/</emphasis>
2306 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;readEof();
2307 
2308 &#32;&#32;&#32;&#32;<emphasis role="comment">/*</emphasis>
2309 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*&#32;Quit-functions&#32;aborts&#32;program&#32;with&#32;&lt;result&gt;&#32;and&#32;&lt;message&gt;:</emphasis>
2310 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*&#32;input/answer&#32;streams&#32;replace&#32;any&#32;result&#32;to&#32;FAIL.</emphasis>
2311 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*/</emphasis>
2312 &#32;&#32;&#32;&#32;NORETURN&#32;<emphasis role="keywordtype">void</emphasis>&#32;quit(TResult&#32;result,&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*msg);
2313 &#32;&#32;&#32;&#32;<emphasis role="comment">/*</emphasis>
2314 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*&#32;Quit-functions&#32;aborts&#32;program&#32;with&#32;&lt;result&gt;&#32;and&#32;&lt;message&gt;:</emphasis>
2315 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*&#32;input/answer&#32;streams&#32;replace&#32;any&#32;result&#32;to&#32;FAIL.</emphasis>
2316 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*/</emphasis>
2317 &#32;&#32;&#32;&#32;NORETURN&#32;<emphasis role="keywordtype">void</emphasis>&#32;quitf(TResult&#32;result,&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*msg,&#32;...);
2318 
2319 &#32;&#32;&#32;&#32;<emphasis role="comment">/*</emphasis>
2320 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*&#32;Quit-functions&#32;aborts&#32;program&#32;with&#32;&lt;result&gt;&#32;and&#32;&lt;message&gt;:</emphasis>
2321 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*&#32;input/answer&#32;streams&#32;replace&#32;any&#32;result&#32;to&#32;FAIL.</emphasis>
2322 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*/</emphasis>
2323 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;quitif(<emphasis role="keywordtype">bool</emphasis>&#32;condition,&#32;TResult&#32;result,&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*msg,&#32;...);
2324 &#32;&#32;&#32;&#32;<emphasis role="comment">/*</emphasis>
2325 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*&#32;Quit-functions&#32;aborts&#32;program&#32;with&#32;&lt;result&gt;&#32;and&#32;&lt;message&gt;:</emphasis>
2326 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*&#32;input/answer&#32;streams&#32;replace&#32;any&#32;result&#32;to&#32;FAIL.</emphasis>
2327 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*/</emphasis>
2328 &#32;&#32;&#32;&#32;NORETURN&#32;<emphasis role="keywordtype">void</emphasis>&#32;quits(TResult&#32;result,&#32;std::string&#32;msg);
2329 
2330 &#32;&#32;&#32;&#32;<emphasis role="comment">/*</emphasis>
2331 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*&#32;Checks&#32;condition&#32;and&#32;aborts&#32;a&#32;program&#32;if&#32;condition&#32;is&#32;false.</emphasis>
2332 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*&#32;Returns&#32;_wa&#32;for&#32;ouf&#32;and&#32;_fail&#32;on&#32;any&#32;other&#32;streams.</emphasis>
2333 <emphasis role="comment">&#32;&#32;&#32;&#32;&#32;*/</emphasis>
2334 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
2335 &#32;&#32;&#32;&#32;__attribute__&#32;((format&#32;(printf,&#32;3,&#32;4)))
2336 <emphasis role="preprocessor">#endif</emphasis>
2337 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;ensuref(<emphasis role="keywordtype">bool</emphasis>&#32;cond,&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*format,&#32;...);
2338 
2339 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;__testlib_ensure(<emphasis role="keywordtype">bool</emphasis>&#32;cond,&#32;std::string&#32;message);
2340 
2341 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;close();
2342 
2343 &#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">static</emphasis>&#32;<emphasis role="keywordtype">int</emphasis>&#32;NO_INDEX&#32;=&#32;INT_MAX;
2344 &#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">static</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;OPEN_BRACKET&#32;=&#32;char(11);
2345 &#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">static</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;CLOSE_BRACKET&#32;=&#32;char(17);
2346 
2347 &#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">static</emphasis>&#32;WORD&#32;LightGray&#32;=&#32;0x07;
2348 &#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">static</emphasis>&#32;WORD&#32;LightRed&#32;=&#32;0x0c;
2349 &#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">static</emphasis>&#32;WORD&#32;LightCyan&#32;=&#32;0x0b;
2350 &#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">static</emphasis>&#32;WORD&#32;LightGreen&#32;=&#32;0x0a;
2351 &#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">static</emphasis>&#32;WORD&#32;LightYellow&#32;=&#32;0x0e;
2352 
2353 &#32;&#32;&#32;&#32;<emphasis role="keyword">static</emphasis>&#32;<emphasis role="keywordtype">void</emphasis>&#32;textColor(WORD&#32;color);
2354 
2355 &#32;&#32;&#32;&#32;<emphasis role="keyword">static</emphasis>&#32;<emphasis role="keywordtype">void</emphasis>&#32;quitscr(WORD&#32;color,&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*msg);
2356 
2357 &#32;&#32;&#32;&#32;<emphasis role="keyword">static</emphasis>&#32;<emphasis role="keywordtype">void</emphasis>&#32;quitscrS(WORD&#32;color,&#32;std::string&#32;msg);
2358 
2359 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;xmlSafeWrite(std::FILE&#32;*file,&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*msg);
2360 
2361 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Skips&#32;UTF-8&#32;Byte&#32;Order&#32;Mark.&#32;*/</emphasis>
2362 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;skipBom();
2363 
2364 <emphasis role="keyword">private</emphasis>:
2365 &#32;&#32;&#32;&#32;<link linkend="_struct_in_stream">InStream</link>(<emphasis role="keyword">const</emphasis>&#32;<link linkend="_struct_in_stream">InStream</link>&#32;&amp;);
2366 
2367 &#32;&#32;&#32;&#32;<link linkend="_struct_in_stream">InStream</link>&#32;&amp;operator=(<emphasis role="keyword">const</emphasis>&#32;<link linkend="_struct_in_stream">InStream</link>&#32;&amp;);
2368 };
2369 
2370 <link linkend="_struct_in_stream">InStream</link>&#32;inf;
2371 <link linkend="_struct_in_stream">InStream</link>&#32;ouf;
2372 <link linkend="_struct_in_stream">InStream</link>&#32;ans;
2373 <emphasis role="keywordtype">bool</emphasis>&#32;appesMode;
2374 std::string&#32;appesModeEncoding&#32;=&#32;<emphasis role="stringliteral">&quot;windows-1251&quot;</emphasis>;
2375 std::string&#32;resultName;
2376 std::string&#32;checkerName&#32;=&#32;<emphasis role="stringliteral">&quot;untitled&#32;checker&quot;</emphasis>;
2377 <link linkend="_classrandom__t">random_t</link>&#32;rnd;
2378 TTestlibMode&#32;testlibMode&#32;=&#32;_unknown;
2379 <emphasis role="keywordtype">double</emphasis>&#32;__testlib_points&#32;=&#32;std::numeric_limits&lt;float&gt;::infinity();
2380 
2381 <emphasis role="keyword">struct&#32;</emphasis><link linkend="_struct_validator_bounds_hit">ValidatorBoundsHit</link>&#32;{
2382 &#32;&#32;&#32;&#32;<emphasis role="keyword">static</emphasis>&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">double</emphasis>&#32;EPS;
2383 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;minHit;
2384 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;maxHit;
2385 
2386 &#32;&#32;&#32;&#32;<link linkend="_struct_validator_bounds_hit">ValidatorBoundsHit</link>(<emphasis role="keywordtype">bool</emphasis>&#32;minHit&#32;=&#32;<emphasis role="keyword">false</emphasis>,&#32;<emphasis role="keywordtype">bool</emphasis>&#32;maxHit&#32;=&#32;<emphasis role="keyword">false</emphasis>)&#32;:&#32;minHit(minHit),&#32;maxHit(maxHit)&#32;{
2387 &#32;&#32;&#32;&#32;};
2388 
2389 &#32;&#32;&#32;&#32;<link linkend="_struct_validator_bounds_hit">ValidatorBoundsHit</link>&#32;merge(<emphasis role="keyword">const</emphasis>&#32;<link linkend="_struct_validator_bounds_hit">ValidatorBoundsHit</link>&#32;&amp;validatorBoundsHit,&#32;<emphasis role="keywordtype">bool</emphasis>&#32;ignoreMinBound,&#32;<emphasis role="keywordtype">bool</emphasis>&#32;ignoreMaxBound)&#32;{
2390 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<link linkend="_struct_validator_bounds_hit">ValidatorBoundsHit</link>(
2391 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_max(minHit,&#32;validatorBoundsHit.minHit)&#32;||&#32;ignoreMinBound,
2392 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_max(maxHit,&#32;validatorBoundsHit.maxHit)&#32;||&#32;ignoreMaxBound
2393 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;);
2394 &#32;&#32;&#32;&#32;}
2395 };
2396 
2397 <emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">double</emphasis>&#32;ValidatorBoundsHit::EPS&#32;=&#32;1E-12;
2398 
2399 <emphasis role="keyword">class&#32;</emphasis><link linkend="_class_validator">Validator</link>&#32;{
2400 <emphasis role="keyword">private</emphasis>:
2401 &#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">static</emphasis>&#32;std::string&#32;TEST_MARKUP_HEADER;
2402 &#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">static</emphasis>&#32;std::string&#32;TEST_CASE_OPEN_TAG;
2403 &#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">static</emphasis>&#32;std::string&#32;TEST_CASE_CLOSE_TAG;
2404 
2405 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;_initialized;
2406 &#32;&#32;&#32;&#32;std::string&#32;_testset;
2407 &#32;&#32;&#32;&#32;std::string&#32;_group;
2408 
2409 &#32;&#32;&#32;&#32;std::string&#32;_testOverviewLogFileName;
2410 &#32;&#32;&#32;&#32;std::string&#32;_testMarkupFileName;
2411 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;_testCase&#32;=&#32;-1;
2412 &#32;&#32;&#32;&#32;std::string&#32;_testCaseFileName;
2413 
2414 &#32;&#32;&#32;&#32;std::map&lt;std::string,&#32;ValidatorBoundsHit&gt;&#32;_boundsHitByVariableName;
2415 &#32;&#32;&#32;&#32;std::set&lt;std::string&gt;&#32;_features;
2416 &#32;&#32;&#32;&#32;std::set&lt;std::string&gt;&#32;_hitFeatures;
2417 
2418 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;isVariableNameBoundsAnalyzable(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName)&#32;{
2419 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">size_t</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;variableName.length();&#32;i++)
2420 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;((variableName[i]&#32;&gt;=&#32;<emphasis role="charliteral">&apos;0&apos;</emphasis>&#32;&amp;&amp;&#32;variableName[i]&#32;&lt;=&#32;<emphasis role="charliteral">&apos;9&apos;</emphasis>)&#32;||&#32;variableName[i]&#32;&lt;&#32;<emphasis role="charliteral">&apos;&#32;&apos;</emphasis>)
2421 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
2422 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">true</emphasis>;
2423 &#32;&#32;&#32;&#32;}
2424 
2425 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;isFeatureNameAnalyzable(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;featureName)&#32;{
2426 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">size_t</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;featureName.length();&#32;i++)
2427 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(featureName[i]&#32;&lt;&#32;<emphasis role="charliteral">&apos;&#32;&apos;</emphasis>)
2428 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
2429 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">true</emphasis>;
2430 &#32;&#32;&#32;&#32;}
2431 
2432 <emphasis role="keyword">public</emphasis>:
2433 &#32;&#32;&#32;&#32;<link linkend="_class_validator">Validator</link>()&#32;:&#32;_initialized(<emphasis role="keyword">false</emphasis>),&#32;_testset(<emphasis role="stringliteral">&quot;tests&quot;</emphasis>),&#32;_group()&#32;{
2434 &#32;&#32;&#32;&#32;}
2435 
2436 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;initialize()&#32;{
2437 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_initialized&#32;=&#32;<emphasis role="keyword">true</emphasis>;
2438 &#32;&#32;&#32;&#32;}
2439 
2440 &#32;&#32;&#32;&#32;std::string&#32;testset()<emphasis role="keyword">&#32;const&#32;</emphasis>{
2441 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!_initialized)
2442 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;Validator&#32;should&#32;be&#32;initialized&#32;with&#32;registerValidation(argc,&#32;argv)&#32;instead&#32;of&#32;registerValidation()&#32;to&#32;support&#32;validator.testset()&quot;</emphasis>);
2443 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;_testset;
2444 &#32;&#32;&#32;&#32;}
2445 
2446 &#32;&#32;&#32;&#32;std::string&#32;group()<emphasis role="keyword">&#32;const&#32;</emphasis>{
2447 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!_initialized)
2448 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;Validator&#32;should&#32;be&#32;initialized&#32;with&#32;registerValidation(argc,&#32;argv)&#32;instead&#32;of&#32;registerValidation()&#32;to&#32;support&#32;validator.group()&quot;</emphasis>);
2449 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;_group;
2450 &#32;&#32;&#32;&#32;}
2451 
2452 &#32;&#32;&#32;&#32;std::string&#32;testOverviewLogFileName()<emphasis role="keyword">&#32;const&#32;</emphasis>{
2453 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;_testOverviewLogFileName;
2454 &#32;&#32;&#32;&#32;}
2455 
2456 &#32;&#32;&#32;&#32;std::string&#32;testMarkupFileName()<emphasis role="keyword">&#32;const&#32;</emphasis>{
2457 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;_testMarkupFileName;
2458 &#32;&#32;&#32;&#32;}
2459 
2460 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;testCase()<emphasis role="keyword">&#32;const&#32;</emphasis>{
2461 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;_testCase;
2462 &#32;&#32;&#32;&#32;}
2463 
2464 &#32;&#32;&#32;&#32;std::string&#32;testCaseFileName()<emphasis role="keyword">&#32;const&#32;</emphasis>{
2465 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;_testCaseFileName;
2466 &#32;&#32;&#32;&#32;}
2467 
2468 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;setTestset(<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*<emphasis role="keyword">const</emphasis>&#32;testset)&#32;{
2469 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_testset&#32;=&#32;testset;
2470 &#32;&#32;&#32;&#32;}
2471 
2472 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;setGroup(<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*<emphasis role="keyword">const</emphasis>&#32;group)&#32;{
2473 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_group&#32;=&#32;group;
2474 &#32;&#32;&#32;&#32;}
2475 
2476 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;setTestOverviewLogFileName(<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*<emphasis role="keyword">const</emphasis>&#32;testOverviewLogFileName)&#32;{
2477 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_testOverviewLogFileName&#32;=&#32;testOverviewLogFileName;
2478 &#32;&#32;&#32;&#32;}
2479 
2480 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;setTestMarkupFileName(<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*<emphasis role="keyword">const</emphasis>&#32;testMarkupFileName)&#32;{
2481 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_testMarkupFileName&#32;=&#32;testMarkupFileName;
2482 &#32;&#32;&#32;&#32;}
2483 
2484 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;setTestCase(<emphasis role="keywordtype">int</emphasis>&#32;testCase)&#32;{
2485 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_testCase&#32;=&#32;testCase;
2486 &#32;&#32;&#32;&#32;}
2487 
2488 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;setTestCaseFileName(<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*<emphasis role="keyword">const</emphasis>&#32;testCaseFileName)&#32;{
2489 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_testCaseFileName&#32;=&#32;testCaseFileName;
2490 &#32;&#32;&#32;&#32;}
2491 
2492 &#32;&#32;&#32;&#32;std::string&#32;prepVariableName(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName)&#32;{
2493 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(variableName.length()&#32;&gt;=&#32;2&#32;&amp;&amp;&#32;variableName&#32;!=&#32;<emphasis role="stringliteral">&quot;~~&quot;</emphasis>)&#32;{
2494 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(variableName[0]&#32;==&#32;<emphasis role="charliteral">&apos;~&apos;</emphasis>&#32;&amp;&amp;&#32;variableName.back()&#32;!=&#32;<emphasis role="charliteral">&apos;~&apos;</emphasis>)
2495 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;variableName.substr(1);
2496 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(variableName[0]&#32;!=&#32;<emphasis role="charliteral">&apos;~&apos;</emphasis>&#32;&amp;&amp;&#32;variableName.back()&#32;==&#32;<emphasis role="charliteral">&apos;~&apos;</emphasis>)
2497 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;variableName.substr(0,&#32;variableName.length()&#32;-&#32;1);
2498 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(variableName[0]&#32;==&#32;<emphasis role="charliteral">&apos;~&apos;</emphasis>&#32;&amp;&amp;&#32;variableName.back()&#32;==&#32;<emphasis role="charliteral">&apos;~&apos;</emphasis>)
2499 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;variableName.substr(1,&#32;variableName.length()&#32;-&#32;2);
2500 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
2501 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;variableName;
2502 &#32;&#32;&#32;&#32;}
2503 
2504 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;ignoreMinBound(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName)&#32;{
2505 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;variableName.length()&#32;&gt;=&#32;2&#32;&amp;&amp;&#32;variableName&#32;!=&#32;<emphasis role="stringliteral">&quot;~~&quot;</emphasis>&#32;&amp;&amp;&#32;variableName[0]&#32;==&#32;<emphasis role="charliteral">&apos;~&apos;</emphasis>;
2506 &#32;&#32;&#32;&#32;}
2507 
2508 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;ignoreMaxBound(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName)&#32;{
2509 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;variableName.length()&#32;&gt;=&#32;2&#32;&amp;&amp;&#32;variableName&#32;!=&#32;<emphasis role="stringliteral">&quot;~~&quot;</emphasis>&#32;&amp;&amp;&#32;variableName.back()&#32;==&#32;<emphasis role="charliteral">&apos;~&apos;</emphasis>;
2510 &#32;&#32;&#32;&#32;}
2511 
2512 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;addBoundsHit(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName,&#32;<link linkend="_struct_validator_bounds_hit">ValidatorBoundsHit</link>&#32;boundsHit)&#32;{
2513 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(isVariableNameBoundsAnalyzable(variableName))&#32;{
2514 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::string&#32;preparedVariableName&#32;=&#32;prepVariableName(variableName);
2515 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_boundsHitByVariableName[preparedVariableName]&#32;=&#32;boundsHit.merge(_boundsHitByVariableName[preparedVariableName],
2516 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;ignoreMinBound(variableName),&#32;ignoreMaxBound(variableName));
2517 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
2518 &#32;&#32;&#32;&#32;}
2519 
2520 &#32;&#32;&#32;&#32;std::string&#32;getBoundsHitLog()&#32;{
2521 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::string&#32;result;
2522 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(std::map&lt;std::string,&#32;ValidatorBoundsHit&gt;::iterator&#32;i&#32;=&#32;_boundsHitByVariableName.begin();
2523 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;i&#32;!=&#32;_boundsHitByVariableName.end();
2524 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;i++)&#32;{
2525 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result&#32;+=&#32;<emphasis role="stringliteral">&quot;\&quot;&quot;</emphasis>&#32;+&#32;i-&gt;first&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;:&quot;</emphasis>;
2526 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(i-&gt;second.minHit)
2527 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result&#32;+=&#32;<emphasis role="stringliteral">&quot;&#32;min-value-hit&quot;</emphasis>;
2528 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(i-&gt;second.maxHit)
2529 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result&#32;+=&#32;<emphasis role="stringliteral">&quot;&#32;max-value-hit&quot;</emphasis>;
2530 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result&#32;+=&#32;<emphasis role="stringliteral">&quot;\n&quot;</emphasis>;
2531 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
2532 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;result;
2533 &#32;&#32;&#32;&#32;}
2534 
2535 &#32;&#32;&#32;&#32;std::string&#32;getFeaturesLog()&#32;{
2536 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::string&#32;result;
2537 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(std::set&lt;std::string&gt;::iterator&#32;i&#32;=&#32;_features.begin();
2538 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;i&#32;!=&#32;_features.end();
2539 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;i++)&#32;{
2540 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result&#32;+=&#32;<emphasis role="stringliteral">&quot;feature&#32;\&quot;&quot;</emphasis>&#32;+&#32;*i&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;:&quot;</emphasis>;
2541 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(_hitFeatures.count(*i))
2542 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result&#32;+=&#32;<emphasis role="stringliteral">&quot;&#32;hit&quot;</emphasis>;
2543 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result&#32;+=&#32;<emphasis role="stringliteral">&quot;\n&quot;</emphasis>;
2544 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
2545 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;result;
2546 &#32;&#32;&#32;&#32;}
2547 
2548 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;writeTestOverviewLog()&#32;{
2549 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!_testOverviewLogFileName.empty())&#32;{
2550 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::string&#32;fileName(_testOverviewLogFileName);
2551 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_testOverviewLogFileName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>;
2552 
2553 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;FILE*&#32;f;
2554 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;standard_file&#32;=&#32;<emphasis role="keyword">false</emphasis>;
2555 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(fileName&#32;==&#32;<emphasis role="stringliteral">&quot;stdout&quot;</emphasis>)
2556 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;f&#32;=&#32;stdout,&#32;standard_file&#32;=&#32;<emphasis role="keyword">true</emphasis>;
2557 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="keywordflow">if</emphasis>&#32;(fileName&#32;==&#32;<emphasis role="stringliteral">&quot;stderr&quot;</emphasis>)
2558 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;f&#32;=&#32;stderr,&#32;standard_file&#32;=&#32;<emphasis role="keyword">true</emphasis>;
2559 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
2560 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;f&#32;=&#32;fopen(fileName.c_str(),&#32;<emphasis role="stringliteral">&quot;wb&quot;</emphasis>);
2561 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(NULL&#32;==&#32;f)
2562 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;Validator::writeTestOverviewLog:&#32;can&apos;t&#32;write&#32;test&#32;overview&#32;log&#32;to&#32;(&quot;</emphasis>&#32;+&#32;fileName&#32;+&#32;<emphasis role="stringliteral">&quot;)&quot;</emphasis>);
2563 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
2564 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;fprintf(f,&#32;<emphasis role="stringliteral">&quot;%s%s&quot;</emphasis>,&#32;getBoundsHitLog().c_str(),&#32;getFeaturesLog().c_str());
2565 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::fflush(f);
2566 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!standard_file)
2567 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(std::fclose(f))
2568 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;Validator::writeTestOverviewLog:&#32;can&apos;t&#32;close&#32;test&#32;overview&#32;log&#32;file&#32;(&quot;</emphasis>&#32;+&#32;fileName&#32;+&#32;<emphasis role="stringliteral">&quot;)&quot;</emphasis>);
2569 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
2570 &#32;&#32;&#32;&#32;}
2571 
2572 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;writeTestMarkup()&#32;{
2573 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!_testMarkupFileName.empty())&#32;{
2574 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::vector&lt;int&gt;&#32;readChars&#32;=&#32;inf.getReadChars();
2575 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!readChars.empty())&#32;{
2576 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::string&#32;markup(TEST_MARKUP_HEADER);
2577 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">size_t</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;readChars.size();&#32;i++)&#32;{
2578 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;c&#32;=&#32;readChars[i];
2579 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(i&#32;+&#32;1&#32;==&#32;readChars.size()&#32;&amp;&amp;&#32;c&#32;==&#32;-1)
2580 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">continue</emphasis>;
2581 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(c&#32;&lt;=&#32;256)&#32;{
2582 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">char</emphasis>&#32;cc&#32;=&#32;char(c);
2583 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(cc&#32;==&#32;<emphasis role="charliteral">&apos;\\&apos;</emphasis>&#32;||&#32;cc&#32;==&#32;<emphasis role="charliteral">&apos;!&apos;</emphasis>)
2584 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;markup&#32;+=&#32;<emphasis role="charliteral">&apos;\\&apos;</emphasis>;
2585 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;markup&#32;+=&#32;cc;
2586 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
2587 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;markup&#32;+=&#32;TEST_CASE_OPEN_TAG;
2588 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;markup&#32;+=&#32;toString(c&#32;-&#32;256);
2589 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;markup&#32;+=&#32;TEST_CASE_CLOSE_TAG;
2590 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
2591 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
2592 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;FILE*&#32;f;
2593 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;standard_file&#32;=&#32;<emphasis role="keyword">false</emphasis>;
2594 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(_testMarkupFileName&#32;==&#32;<emphasis role="stringliteral">&quot;stdout&quot;</emphasis>)
2595 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;f&#32;=&#32;stdout,&#32;standard_file&#32;=&#32;<emphasis role="keyword">true</emphasis>;
2596 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="keywordflow">if</emphasis>&#32;(_testMarkupFileName&#32;==&#32;<emphasis role="stringliteral">&quot;stderr&quot;</emphasis>)
2597 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;f&#32;=&#32;stderr,&#32;standard_file&#32;=&#32;<emphasis role="keyword">true</emphasis>;
2598 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
2599 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;f&#32;=&#32;fopen(_testMarkupFileName.c_str(),&#32;<emphasis role="stringliteral">&quot;wb&quot;</emphasis>);
2600 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(NULL&#32;==&#32;f)
2601 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;Validator::writeTestMarkup:&#32;can&apos;t&#32;write&#32;test&#32;markup&#32;to&#32;(&quot;</emphasis>&#32;+&#32;_testMarkupFileName&#32;+&#32;<emphasis role="stringliteral">&quot;)&quot;</emphasis>);
2602 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
2603 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::fprintf(f,&#32;<emphasis role="stringliteral">&quot;%s&quot;</emphasis>,&#32;markup.c_str());
2604 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::fflush(f);
2605 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!standard_file)
2606 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(std::fclose(f))
2607 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;Validator::writeTestMarkup:&#32;can&apos;t&#32;close&#32;test&#32;markup&#32;file&#32;(&quot;</emphasis>&#32;+&#32;_testCaseFileName&#32;+&#32;<emphasis role="stringliteral">&quot;)&quot;</emphasis>);
2608 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
2609 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
2610 &#32;&#32;&#32;&#32;}
2611 
2612 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;writeTestCase()&#32;{
2613 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(_testCase&#32;&gt;&#32;0)&#32;{
2614 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::vector&lt;int&gt;&#32;readChars&#32;=&#32;inf.getReadChars();
2615 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!readChars.empty())&#32;{
2616 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::string&#32;content,&#32;testCaseContent;
2617 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;matchedTestCase&#32;=&#32;<emphasis role="keyword">false</emphasis>;
2618 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">size_t</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;readChars.size();&#32;i++)&#32;{
2619 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;c&#32;=&#32;readChars[i];
2620 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(i&#32;+&#32;1&#32;==&#32;readChars.size()&#32;&amp;&amp;&#32;c&#32;==&#32;-1)
2621 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">continue</emphasis>;
2622 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(c&#32;&lt;=&#32;256)
2623 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;content&#32;+=&#32;char(c);
2624 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
2625 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(matchedTestCase)&#32;{
2626 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;testCaseContent&#32;=&#32;content;
2627 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;matchedTestCase&#32;=&#32;<emphasis role="keyword">false</emphasis>;
2628 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
2629 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;content&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>;
2630 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;testCase&#32;=&#32;c&#32;-&#32;256;
2631 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(testCase&#32;==&#32;_testCase)
2632 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;matchedTestCase&#32;=&#32;<emphasis role="keyword">true</emphasis>;
2633 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
2634 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
2635 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(matchedTestCase)
2636 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;testCaseContent&#32;=&#32;content;
2637 
2638 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!testCaseContent.empty())&#32;{
2639 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;FILE*&#32;f;
2640 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;standard_file&#32;=&#32;<emphasis role="keyword">false</emphasis>;
2641 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(_testCaseFileName.empty()&#32;||&#32;_testCaseFileName&#32;==&#32;<emphasis role="stringliteral">&quot;stdout&quot;</emphasis>)
2642 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;f&#32;=&#32;stdout,&#32;standard_file&#32;=&#32;<emphasis role="keyword">true</emphasis>;
2643 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="keywordflow">if</emphasis>&#32;(_testCaseFileName&#32;==&#32;<emphasis role="stringliteral">&quot;stderr&quot;</emphasis>)
2644 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;f&#32;=&#32;stderr,&#32;standard_file&#32;=&#32;<emphasis role="keyword">true</emphasis>;
2645 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
2646 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;f&#32;=&#32;fopen(_testCaseFileName.c_str(),&#32;<emphasis role="stringliteral">&quot;wb&quot;</emphasis>);
2647 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(NULL&#32;==&#32;f)
2648 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;Validator::writeTestCase:&#32;can&apos;t&#32;write&#32;test&#32;case&#32;to&#32;(&quot;</emphasis>&#32;+&#32;_testCaseFileName&#32;+&#32;<emphasis role="stringliteral">&quot;)&quot;</emphasis>);
2649 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
2650 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::fprintf(f,&#32;<emphasis role="stringliteral">&quot;%s&quot;</emphasis>,&#32;testCaseContent.c_str());
2651 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::fflush(f);
2652 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!standard_file)
2653 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(std::fclose(f))
2654 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;Validator::writeTestCase:&#32;can&apos;t&#32;close&#32;test&#32;case&#32;file&#32;(&quot;</emphasis>&#32;+&#32;_testCaseFileName&#32;+&#32;<emphasis role="stringliteral">&quot;)&quot;</emphasis>);
2655 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
2656 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
2657 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
2658 &#32;&#32;&#32;&#32;}
2659 
2660 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;addFeature(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;feature)&#32;{
2661 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(_features.count(feature))
2662 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;Feature&#32;&quot;</emphasis>&#32;+&#32;feature&#32;+&#32;<emphasis role="stringliteral">&quot;&#32;registered&#32;twice.&quot;</emphasis>);
2663 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!isFeatureNameAnalyzable(feature))
2664 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;Feature&#32;name&#32;&apos;&quot;</emphasis>&#32;+&#32;feature&#32;+&#32;<emphasis role="stringliteral">&quot;&apos;&#32;contains&#32;restricted&#32;characters.&quot;</emphasis>);
2665 
2666 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_features.insert(feature);
2667 &#32;&#32;&#32;&#32;}
2668 
2669 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;feature(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;feature)&#32;{
2670 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!isFeatureNameAnalyzable(feature))
2671 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;Feature&#32;name&#32;&apos;&quot;</emphasis>&#32;+&#32;feature&#32;+&#32;<emphasis role="stringliteral">&quot;&apos;&#32;contains&#32;restricted&#32;characters.&quot;</emphasis>);
2672 
2673 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!_features.count(feature))
2674 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;Feature&#32;&quot;</emphasis>&#32;+&#32;feature&#32;+&#32;<emphasis role="stringliteral">&quot;&#32;didn&apos;t&#32;registered&#32;via&#32;addFeature(feature).&quot;</emphasis>);
2675 
2676 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_hitFeatures.insert(feature);
2677 &#32;&#32;&#32;&#32;}
2678 }&#32;validator;
2679 
2680 <emphasis role="keyword">const</emphasis>&#32;std::string&#32;Validator::TEST_MARKUP_HEADER&#32;=&#32;<emphasis role="stringliteral">&quot;MU\xF3\x01&quot;</emphasis>;
2681 <emphasis role="keyword">const</emphasis>&#32;std::string&#32;Validator::TEST_CASE_OPEN_TAG&#32;=&#32;<emphasis role="stringliteral">&quot;!c&quot;</emphasis>;
2682 <emphasis role="keyword">const</emphasis>&#32;std::string&#32;Validator::TEST_CASE_CLOSE_TAG&#32;=&#32;<emphasis role="stringliteral">&quot;;&quot;</emphasis>;
2683 
2684 <emphasis role="keyword">struct&#32;</emphasis><link linkend="_struct_testlib_finalize_guard">TestlibFinalizeGuard</link>&#32;{
2685 &#32;&#32;&#32;&#32;<emphasis role="keyword">static</emphasis>&#32;<emphasis role="keywordtype">bool</emphasis>&#32;alive;
2686 &#32;&#32;&#32;&#32;<emphasis role="keyword">static</emphasis>&#32;<emphasis role="keywordtype">bool</emphasis>&#32;registered;
2687 
2688 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;quitCount,&#32;readEofCount;
2689 
2690 &#32;&#32;&#32;&#32;<link linkend="_struct_testlib_finalize_guard">TestlibFinalizeGuard</link>()&#32;:&#32;quitCount(0),&#32;readEofCount(0)&#32;{
2691 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;No&#32;operations.</emphasis>
2692 &#32;&#32;&#32;&#32;}
2693 
2694 &#32;&#32;&#32;&#32;<link linkend="_struct_testlib_finalize_guard">~TestlibFinalizeGuard</link>()&#32;{
2695 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;_alive&#32;=&#32;alive;
2696 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;alive&#32;=&#32;<emphasis role="keyword">false</emphasis>;
2697 
2698 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(_alive)&#32;{
2699 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(testlibMode&#32;==&#32;_checker&#32;&amp;&amp;&#32;quitCount&#32;==&#32;0)
2700 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;Checker&#32;must&#32;end&#32;with&#32;quit&#32;or&#32;quitf&#32;call.&quot;</emphasis>);
2701 
2702 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(testlibMode&#32;==&#32;_validator&#32;&amp;&amp;&#32;readEofCount&#32;==&#32;0&#32;&amp;&amp;&#32;quitCount&#32;==&#32;0)
2703 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;Validator&#32;must&#32;end&#32;with&#32;readEof&#32;call.&quot;</emphasis>);
2704 
2705 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;opts&#32;*/</emphasis>
2706 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;autoEnsureNoUnusedOpts();
2707 
2708 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!registered)
2709 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;Call&#32;register-function&#32;in&#32;the&#32;first&#32;line&#32;of&#32;the&#32;main&#32;(registerTestlibCmd&#32;or&#32;other&#32;similar)&quot;</emphasis>);
2710 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
2711 
2712 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__testlib_exitCode&#32;==&#32;0)&#32;{
2713 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;validator.writeTestOverviewLog();
2714 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;validator.writeTestMarkup();
2715 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;validator.writeTestCase();
2716 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
2717 &#32;&#32;&#32;&#32;}
2718 
2719 <emphasis role="keyword">private</emphasis>:
2720 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;opts&#32;*/</emphasis>
2721 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;autoEnsureNoUnusedOpts();
2722 };
2723 
2724 <emphasis role="keywordtype">bool</emphasis>&#32;TestlibFinalizeGuard::alive&#32;=&#32;<emphasis role="keyword">true</emphasis>;
2725 <emphasis role="keywordtype">bool</emphasis>&#32;TestlibFinalizeGuard::registered&#32;=&#32;<emphasis role="keyword">false</emphasis>;
2726 <emphasis role="keyword">extern</emphasis>&#32;<link linkend="_struct_testlib_finalize_guard">TestlibFinalizeGuard</link>&#32;testlibFinalizeGuard;
2727 
2728 <emphasis role="comment">/*</emphasis>
2729 <emphasis role="comment">&#32;*&#32;Call&#32;it&#32;to&#32;disable&#32;checks&#32;on&#32;finalization.</emphasis>
2730 <emphasis role="comment">&#32;*/</emphasis>
2731 <emphasis role="keywordtype">void</emphasis>&#32;disableFinalizeGuard()&#32;{
2732 &#32;&#32;&#32;&#32;TestlibFinalizeGuard::alive&#32;=&#32;<emphasis role="keyword">false</emphasis>;
2733 }
2734 
2735 <emphasis role="comment">/*&#32;Interactor&#32;streams.</emphasis>
2736 <emphasis role="comment">&#32;*/</emphasis>
2737 std::fstream&#32;tout;
2738 
2739 <emphasis role="comment">/*&#32;implementation</emphasis>
2740 <emphasis role="comment">&#32;*/</emphasis>
2741 
2742 InStream::InStream()&#32;{
2743 &#32;&#32;&#32;&#32;reader&#32;=&#32;NULL;
2744 &#32;&#32;&#32;&#32;lastLine&#32;=&#32;-1;
2745 &#32;&#32;&#32;&#32;opened&#32;=&#32;<emphasis role="keyword">false</emphasis>;
2746 &#32;&#32;&#32;&#32;name&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>;
2747 &#32;&#32;&#32;&#32;mode&#32;=&#32;_input;
2748 &#32;&#32;&#32;&#32;strict&#32;=&#32;<emphasis role="keyword">false</emphasis>;
2749 &#32;&#32;&#32;&#32;stdfile&#32;=&#32;<emphasis role="keyword">false</emphasis>;
2750 &#32;&#32;&#32;&#32;wordReserveSize&#32;=&#32;4;
2751 &#32;&#32;&#32;&#32;readManyIteration&#32;=&#32;NO_INDEX;
2752 &#32;&#32;&#32;&#32;maxFileSize&#32;=&#32;128&#32;*&#32;1024&#32;*&#32;1024;&#32;<emphasis role="comment">//&#32;128MB.</emphasis>
2753 &#32;&#32;&#32;&#32;maxTokenLength&#32;=&#32;32&#32;*&#32;1024&#32;*&#32;1024;&#32;<emphasis role="comment">//&#32;32MB.</emphasis>
2754 &#32;&#32;&#32;&#32;maxMessageLength&#32;=&#32;32000;
2755 }
2756 
2757 InStream::InStream(<emphasis role="keyword">const</emphasis>&#32;<link linkend="_struct_in_stream">InStream</link>&#32;&amp;baseStream,&#32;std::string&#32;content)&#32;{
2758 &#32;&#32;&#32;&#32;reader&#32;=&#32;<emphasis role="keyword">new</emphasis>&#32;<link linkend="_class_string_input_stream_reader">StringInputStreamReader</link>(content);
2759 &#32;&#32;&#32;&#32;lastLine&#32;=&#32;-1;
2760 &#32;&#32;&#32;&#32;opened&#32;=&#32;<emphasis role="keyword">true</emphasis>;
2761 &#32;&#32;&#32;&#32;strict&#32;=&#32;baseStream.strict;
2762 &#32;&#32;&#32;&#32;stdfile&#32;=&#32;<emphasis role="keyword">false</emphasis>;
2763 &#32;&#32;&#32;&#32;mode&#32;=&#32;baseStream.mode;
2764 &#32;&#32;&#32;&#32;name&#32;=&#32;<emphasis role="stringliteral">&quot;based&#32;on&#32;&quot;</emphasis>&#32;+&#32;baseStream.name;
2765 &#32;&#32;&#32;&#32;readManyIteration&#32;=&#32;NO_INDEX;
2766 &#32;&#32;&#32;&#32;maxFileSize&#32;=&#32;128&#32;*&#32;1024&#32;*&#32;1024;&#32;<emphasis role="comment">//&#32;128MB.</emphasis>
2767 &#32;&#32;&#32;&#32;maxTokenLength&#32;=&#32;32&#32;*&#32;1024&#32;*&#32;1024;&#32;<emphasis role="comment">//&#32;32MB.</emphasis>
2768 &#32;&#32;&#32;&#32;maxMessageLength&#32;=&#32;32000;
2769 }
2770 
2771 InStream::~InStream()&#32;{
2772 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(NULL&#32;!=&#32;reader)&#32;{
2773 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;reader-&gt;close();
2774 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">delete</emphasis>&#32;reader;
2775 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;reader&#32;=&#32;NULL;
2776 &#32;&#32;&#32;&#32;}
2777 }
2778 
2779 <emphasis role="keywordtype">void</emphasis>&#32;InStream::setTestCase(<emphasis role="keywordtype">int</emphasis>&#32;testCase)&#32;{
2780 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(testlibMode&#32;!=&#32;_validator&#32;||&#32;mode&#32;!=&#32;_input&#32;||&#32;!stdfile&#32;||&#32;<emphasis role="keyword">this</emphasis>&#32;!=&#32;&amp;inf)
2781 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;InStream::setTestCase&#32;can&#32;be&#32;used&#32;only&#32;for&#32;inf&#32;in&#32;validator-mode.&quot;</emphasis>
2782 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;&#32;Actually,&#32;prefer&#32;setTestCase&#32;function&#32;instead&#32;of&#32;InStream&#32;member&quot;</emphasis>);
2783 &#32;&#32;&#32;&#32;reader-&gt;setTestCase(testCase);
2784 }
2785 
2786 std::vector&lt;int&gt;&#32;InStream::getReadChars()&#32;{
2787 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(testlibMode&#32;!=&#32;_validator&#32;||&#32;mode&#32;!=&#32;_input&#32;||&#32;!stdfile&#32;||&#32;<emphasis role="keyword">this</emphasis>&#32;!=&#32;&amp;inf)
2788 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;InStream::getReadChars&#32;can&#32;be&#32;used&#32;only&#32;for&#32;inf&#32;in&#32;validator-mode.&quot;</emphasis>);
2789 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;reader&#32;==&#32;NULL&#32;?&#32;std::vector&lt;int&gt;()&#32;:&#32;reader-&gt;getReadChars();
2790 }
2791 
2792 <emphasis role="keywordtype">void</emphasis>&#32;setTestCase(<emphasis role="keywordtype">int</emphasis>&#32;testCase)&#32;{
2793 &#32;&#32;&#32;&#32;<emphasis role="keyword">static</emphasis>&#32;<emphasis role="keywordtype">bool</emphasis>&#32;first_run&#32;=&#32;<emphasis role="keyword">true</emphasis>;
2794 &#32;&#32;&#32;&#32;<emphasis role="keyword">static</emphasis>&#32;<emphasis role="keywordtype">bool</emphasis>&#32;zero_based&#32;=&#32;<emphasis role="keyword">false</emphasis>;
2795 
2796 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(first_run&#32;&amp;&amp;&#32;testCase&#32;==&#32;0)
2797 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;zero_based&#32;=&#32;<emphasis role="keyword">true</emphasis>;
2798 
2799 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(zero_based)
2800 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;testCase++;
2801 
2802 &#32;&#32;&#32;&#32;__testlib_hasTestCase&#32;=&#32;<emphasis role="keyword">true</emphasis>;
2803 &#32;&#32;&#32;&#32;__testlib_testCase&#32;=&#32;testCase;
2804 
2805 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(testlibMode&#32;==&#32;_validator)
2806 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;inf.setTestCase(testCase);
2807 
2808 &#32;&#32;&#32;&#32;first_run&#32;=&#32;<emphasis role="keyword">false</emphasis>;
2809 }
2810 
2811 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
2812 __attribute__((<emphasis role="keyword">const</emphasis>))
2813 <emphasis role="preprocessor">#endif</emphasis>
2814 <emphasis role="keywordtype">int</emphasis>&#32;resultExitCode(TResult&#32;r)&#32;{
2815 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(r&#32;==&#32;_ok)
2816 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;OK_EXIT_CODE;
2817 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(r&#32;==&#32;_wa)
2818 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;WA_EXIT_CODE;
2819 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(r&#32;==&#32;_pe)
2820 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;PE_EXIT_CODE;
2821 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(r&#32;==&#32;_fail)
2822 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;FAIL_EXIT_CODE;
2823 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(r&#32;==&#32;_dirt)
2824 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;DIRT_EXIT_CODE;
2825 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(r&#32;==&#32;_points)
2826 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;POINTS_EXIT_CODE;
2827 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(r&#32;==&#32;_unexpected_eof)
2828 <emphasis role="preprocessor">#ifdef&#32;ENABLE_UNEXPECTED_EOF</emphasis>
2829 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;UNEXPECTED_EOF_EXIT_CODE;
2830 <emphasis role="preprocessor">#else</emphasis>
2831 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;PE_EXIT_CODE;
2832 <emphasis role="preprocessor">#endif</emphasis>
2833 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(r&#32;&gt;=&#32;_partially)
2834 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;PC_BASE_EXIT_CODE&#32;+&#32;(r&#32;-&#32;_partially);
2835 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;FAIL_EXIT_CODE;
2836 }
2837 
2838 <emphasis role="keywordtype">void</emphasis>&#32;InStream::textColor(
2839 #<emphasis role="keywordflow">if</emphasis>&#32;!(defined(ON_WINDOWS)&#32;&amp;&amp;&#32;(!defined(_MSC_VER)&#32;||&#32;_MSC_VER&#32;&gt;&#32;1400))&#32;&amp;&amp;&#32;defined(__GNUC__)
2840 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__attribute__((unused))
2841 #endif
2842 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;WORD&#32;color
2843 )&#32;{
2844 <emphasis role="preprocessor">#if&#32;defined(ON_WINDOWS)&#32;&amp;&amp;&#32;(!defined(_MSC_VER)&#32;||&#32;_MSC_VER&#32;&gt;&#32;1400)</emphasis>
2845 &#32;&#32;&#32;&#32;HANDLE&#32;handle&#32;=&#32;GetStdHandle(STD_OUTPUT_HANDLE);
2846 &#32;&#32;&#32;&#32;SetConsoleTextAttribute(handle,&#32;color);
2847 <emphasis role="preprocessor">#endif</emphasis>
2848 <emphasis role="preprocessor">#if&#32;!defined(ON_WINDOWS)&#32;&amp;&amp;&#32;defined(__GNUC__)</emphasis>
2849 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(isatty(2))
2850 &#32;&#32;&#32;&#32;{
2851 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">switch</emphasis>&#32;(color)
2852 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
2853 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">case</emphasis>&#32;LightRed:
2854 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;fprintf(stderr,&#32;<emphasis role="stringliteral">&quot;\033[1;31m&quot;</emphasis>);
2855 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">break</emphasis>;
2856 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">case</emphasis>&#32;LightCyan:
2857 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;fprintf(stderr,&#32;<emphasis role="stringliteral">&quot;\033[1;36m&quot;</emphasis>);
2858 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">break</emphasis>;
2859 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">case</emphasis>&#32;LightGreen:
2860 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;fprintf(stderr,&#32;<emphasis role="stringliteral">&quot;\033[1;32m&quot;</emphasis>);
2861 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">break</emphasis>;
2862 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">case</emphasis>&#32;LightYellow:
2863 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;fprintf(stderr,&#32;<emphasis role="stringliteral">&quot;\033[1;33m&quot;</emphasis>);
2864 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">break</emphasis>;
2865 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">case</emphasis>&#32;LightGray:
2866 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">default</emphasis>:
2867 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;fprintf(stderr,&#32;<emphasis role="stringliteral">&quot;\033[0m&quot;</emphasis>);
2868 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
2869 &#32;&#32;&#32;&#32;}
2870 <emphasis role="preprocessor">#endif</emphasis>
2871 }
2872 
2873 <emphasis role="preprocessor">#ifdef&#32;TESTLIB_THROW_EXIT_EXCEPTION_INSTEAD_OF_EXIT</emphasis>
2874 <emphasis role="keyword">class&#32;</emphasis>exit_exception:&#32;<emphasis role="keyword">public</emphasis>&#32;std::exception&#32;{
2875 <emphasis role="keyword">private</emphasis>:
2876 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;exitCode;
2877 <emphasis role="keyword">public</emphasis>:
2878 &#32;&#32;&#32;&#32;exit_exception(<emphasis role="keywordtype">int</emphasis>&#32;exitCode):&#32;exitCode(exitCode)&#32;{}
2879 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;getExitCode()&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;exitCode;&#32;}
2880 };
2881 <emphasis role="preprocessor">#endif</emphasis>
2882 
2883 NORETURN&#32;<emphasis role="keywordtype">void</emphasis>&#32;halt(<emphasis role="keywordtype">int</emphasis>&#32;exitCode)&#32;{
2884 <emphasis role="preprocessor">#ifdef&#32;FOOTER</emphasis>
2885 &#32;&#32;&#32;&#32;InStream::textColor(InStream::LightGray);
2886 &#32;&#32;&#32;&#32;std::fprintf(stderr,&#32;<emphasis role="stringliteral">&quot;Checker:&#32;\&quot;%s\&quot;\n&quot;</emphasis>,&#32;checkerName.c_str());
2887 &#32;&#32;&#32;&#32;std::fprintf(stderr,&#32;<emphasis role="stringliteral">&quot;Exit&#32;code:&#32;%d\n&quot;</emphasis>,&#32;exitCode);
2888 &#32;&#32;&#32;&#32;InStream::textColor(InStream::LightGray);
2889 <emphasis role="preprocessor">#endif</emphasis>
2890 &#32;&#32;&#32;&#32;__testlib_exitCode&#32;=&#32;exitCode;
2891 <emphasis role="preprocessor">#ifdef&#32;TESTLIB_THROW_EXIT_EXCEPTION_INSTEAD_OF_EXIT</emphasis>
2892 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">throw</emphasis>&#32;exit_exception(exitCode);
2893 <emphasis role="preprocessor">#endif</emphasis>
2894 &#32;&#32;&#32;&#32;std::exit(exitCode);
2895 }
2896 
2897 <emphasis role="keyword">static</emphasis>&#32;<emphasis role="keywordtype">bool</emphasis>&#32;__testlib_shouldCheckDirt(TResult&#32;result)&#32;{
2898 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;result&#32;==&#32;_ok&#32;||&#32;result&#32;==&#32;_points&#32;||&#32;result&#32;&gt;=&#32;_partially;
2899 }
2900 
2901 <emphasis role="keyword">static</emphasis>&#32;std::string&#32;__testlib_appendMessage(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;message,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;extra)&#32;{
2902 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;openPos&#32;=&#32;-1,&#32;closePos&#32;=&#32;-1;
2903 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">size_t</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;message.length();&#32;i++)&#32;{
2904 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(message[i]&#32;==&#32;InStream::OPEN_BRACKET)&#32;{
2905 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(openPos&#32;==&#32;-1)
2906 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;openPos&#32;=&#32;int(i);
2907 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
2908 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;openPos&#32;=&#32;INT_MAX;
2909 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
2910 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(message[i]&#32;==&#32;InStream::CLOSE_BRACKET)&#32;{
2911 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(closePos&#32;==&#32;-1)
2912 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;closePos&#32;=&#32;int(i);
2913 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
2914 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;closePos&#32;=&#32;INT_MAX;
2915 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
2916 &#32;&#32;&#32;&#32;}
2917 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(openPos&#32;!=&#32;-1&#32;&amp;&amp;&#32;openPos&#32;!=&#32;INT_MAX
2918 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&amp;&amp;&#32;closePos&#32;!=&#32;-1&#32;&amp;&amp;&#32;closePos&#32;!=&#32;INT_MAX
2919 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&amp;&amp;&#32;openPos&#32;&lt;&#32;closePos)&#32;{
2920 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;index&#32;=&#32;message.find(extra,&#32;openPos);
2921 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(index&#32;==&#32;std::string::npos&#32;||&#32;<emphasis role="keywordtype">int</emphasis>(index)&#32;&gt;=&#32;closePos)&#32;{
2922 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::string&#32;result(message);
2923 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result.insert(closePos,&#32;<emphasis role="stringliteral">&quot;,&#32;&quot;</emphasis>&#32;+&#32;extra);
2924 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;result;
2925 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
2926 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;message;
2927 &#32;&#32;&#32;&#32;}
2928 
2929 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;message&#32;+&#32;<emphasis role="stringliteral">&quot;&#32;&quot;</emphasis>&#32;+&#32;InStream::OPEN_BRACKET&#32;+&#32;extra&#32;+&#32;InStream::CLOSE_BRACKET;
2930 }
2931 
2932 <emphasis role="keyword">static</emphasis>&#32;std::string&#32;__testlib_toPrintableMessage(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;message)&#32;{
2933 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;openPos&#32;=&#32;-1,&#32;closePos&#32;=&#32;-1;
2934 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">size_t</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;message.length();&#32;i++)&#32;{
2935 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(message[i]&#32;==&#32;InStream::OPEN_BRACKET)&#32;{
2936 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(openPos&#32;==&#32;-1)
2937 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;openPos&#32;=&#32;int(i);
2938 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
2939 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;openPos&#32;=&#32;INT_MAX;
2940 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
2941 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(message[i]&#32;==&#32;InStream::CLOSE_BRACKET)&#32;{
2942 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(closePos&#32;==&#32;-1)
2943 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;closePos&#32;=&#32;int(i);
2944 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
2945 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;closePos&#32;=&#32;INT_MAX;
2946 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
2947 &#32;&#32;&#32;&#32;}
2948 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(openPos&#32;!=&#32;-1&#32;&amp;&amp;&#32;openPos&#32;!=&#32;INT_MAX
2949 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&amp;&amp;&#32;closePos&#32;!=&#32;-1&#32;&amp;&amp;&#32;closePos&#32;!=&#32;INT_MAX
2950 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&amp;&amp;&#32;openPos&#32;&lt;&#32;closePos)&#32;{
2951 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::string&#32;result(message);
2952 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result[openPos]&#32;=&#32;<emphasis role="charliteral">&apos;(&apos;</emphasis>;
2953 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result[closePos]&#32;=&#32;<emphasis role="charliteral">&apos;)&apos;</emphasis>;
2954 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;result;
2955 &#32;&#32;&#32;&#32;}
2956 
2957 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;message;
2958 }
2959 
2960 NORETURN&#32;<emphasis role="keywordtype">void</emphasis>&#32;InStream::quit(TResult&#32;result,&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*msg)&#32;{
2961 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(TestlibFinalizeGuard::alive)
2962 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;testlibFinalizeGuard.quitCount++;
2963 
2964 &#32;&#32;&#32;&#32;std::string&#32;message(msg);
2965 &#32;&#32;&#32;&#32;message&#32;=&#32;trim(message);
2966 
2967 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__testlib_hasTestCase)&#32;{
2968 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(result&#32;!=&#32;_ok)
2969 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;message&#32;=&#32;__testlib_appendMessage(message,&#32;<emphasis role="stringliteral">&quot;test&#32;case&#32;&quot;</emphasis>&#32;+&#32;vtos(__testlib_testCase));
2970 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
2971 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__testlib_testCase&#32;==&#32;1)
2972 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;message&#32;=&#32;__testlib_appendMessage(message,&#32;vtos(__testlib_testCase)&#32;+&#32;<emphasis role="stringliteral">&quot;&#32;test&#32;case&quot;</emphasis>);
2973 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
2974 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;message&#32;=&#32;__testlib_appendMessage(message,&#32;vtos(__testlib_testCase)&#32;+&#32;<emphasis role="stringliteral">&quot;&#32;test&#32;cases&quot;</emphasis>);
2975 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
2976 &#32;&#32;&#32;&#32;}
2977 
2978 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;You&#32;can&#32;change&#32;maxMessageLength.</emphasis>
2979 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Example:&#32;&apos;inf.maxMessageLength&#32;=&#32;1024&#32;*&#32;1024;&apos;.</emphasis>
2980 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(message.length()&#32;&gt;&#32;maxMessageLength)&#32;{
2981 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::string&#32;warn&#32;=&#32;<emphasis role="stringliteral">&quot;message&#32;length&#32;exceeds&#32;&quot;</emphasis>&#32;+&#32;vtos(maxMessageLength)
2982 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;+&#32;<emphasis role="stringliteral">&quot;,&#32;the&#32;message&#32;is&#32;truncated:&#32;&quot;</emphasis>;
2983 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;message&#32;=&#32;warn&#32;+&#32;message.substr(0,&#32;maxMessageLength&#32;-&#32;warn.length());
2984 &#32;&#32;&#32;&#32;}
2985 
2986 <emphasis role="preprocessor">#ifndef&#32;ENABLE_UNEXPECTED_EOF</emphasis>
2987 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(result&#32;==&#32;_unexpected_eof)
2988 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result&#32;=&#32;_pe;
2989 <emphasis role="preprocessor">#endif</emphasis>
2990 
2991 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(testlibMode&#32;==&#32;_scorer&#32;&amp;&amp;&#32;result&#32;!=&#32;_fail)
2992 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quits(_fail,&#32;<emphasis role="stringliteral">&quot;Scorer&#32;should&#32;return&#32;points&#32;only.&#32;Don&apos;t&#32;use&#32;a&#32;quit&#32;function.&quot;</emphasis>);
2993 
2994 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(mode&#32;!=&#32;_output&#32;&amp;&amp;&#32;result&#32;!=&#32;_fail)&#32;{
2995 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(mode&#32;==&#32;_input&#32;&amp;&amp;&#32;testlibMode&#32;==&#32;_validator&#32;&amp;&amp;&#32;lastLine&#32;!=&#32;-1)
2996 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quits(_fail,&#32;__testlib_appendMessage(__testlib_appendMessage(message,&#32;name),&#32;<emphasis role="stringliteral">&quot;line&#32;&quot;</emphasis>&#32;+&#32;vtos(lastLine)));
2997 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
2998 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quits(_fail,&#32;__testlib_appendMessage(message,&#32;name));
2999 &#32;&#32;&#32;&#32;}
3000 
3001 &#32;&#32;&#32;&#32;std::FILE&#32;*resultFile;
3002 &#32;&#32;&#32;&#32;std::string&#32;errorName;
3003 
3004 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__testlib_shouldCheckDirt(result))&#32;{
3005 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(testlibMode&#32;!=&#32;_interactor&#32;&amp;&amp;&#32;!ouf.seekEof())
3006 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_dirt,&#32;<emphasis role="stringliteral">&quot;Extra&#32;information&#32;in&#32;the&#32;output&#32;file&quot;</emphasis>);
3007 &#32;&#32;&#32;&#32;}
3008 
3009 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;pctype&#32;=&#32;result&#32;-&#32;_partially;
3010 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;isPartial&#32;=&#32;<emphasis role="keyword">false</emphasis>;
3011 
3012 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">switch</emphasis>&#32;(result)&#32;{
3013 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">case</emphasis>&#32;_ok:
3014 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;errorName&#32;=&#32;<emphasis role="stringliteral">&quot;ok&#32;&quot;</emphasis>;
3015 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quitscrS(LightGreen,&#32;errorName);
3016 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">break</emphasis>;
3017 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">case</emphasis>&#32;_wa:
3018 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;errorName&#32;=&#32;<emphasis role="stringliteral">&quot;wrong&#32;answer&#32;&quot;</emphasis>;
3019 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quitscrS(LightRed,&#32;errorName);
3020 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">break</emphasis>;
3021 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">case</emphasis>&#32;_pe:
3022 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;errorName&#32;=&#32;<emphasis role="stringliteral">&quot;wrong&#32;output&#32;format&#32;&quot;</emphasis>;
3023 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quitscrS(LightRed,&#32;errorName);
3024 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">break</emphasis>;
3025 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">case</emphasis>&#32;_fail:
3026 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;errorName&#32;=&#32;<emphasis role="stringliteral">&quot;FAIL&#32;&quot;</emphasis>;
3027 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quitscrS(LightRed,&#32;errorName);
3028 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">break</emphasis>;
3029 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">case</emphasis>&#32;_dirt:
3030 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;errorName&#32;=&#32;<emphasis role="stringliteral">&quot;wrong&#32;output&#32;format&#32;&quot;</emphasis>;
3031 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quitscrS(LightCyan,&#32;errorName);
3032 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result&#32;=&#32;_pe;
3033 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">break</emphasis>;
3034 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">case</emphasis>&#32;_points:
3035 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;errorName&#32;=&#32;<emphasis role="stringliteral">&quot;points&#32;&quot;</emphasis>;
3036 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quitscrS(LightYellow,&#32;errorName);
3037 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">break</emphasis>;
3038 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">case</emphasis>&#32;_unexpected_eof:
3039 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;errorName&#32;=&#32;<emphasis role="stringliteral">&quot;unexpected&#32;eof&#32;&quot;</emphasis>;
3040 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quitscrS(LightCyan,&#32;errorName);
3041 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">break</emphasis>;
3042 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">default</emphasis>:
3043 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(result&#32;&gt;=&#32;_partially)&#32;{
3044 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;errorName&#32;=&#32;format(<emphasis role="stringliteral">&quot;partially&#32;correct&#32;(%d)&#32;&quot;</emphasis>,&#32;pctype);
3045 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;isPartial&#32;=&#32;<emphasis role="keyword">true</emphasis>;
3046 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quitscrS(LightYellow,&#32;errorName);
3047 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>
3048 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_fail,&#32;<emphasis role="stringliteral">&quot;What&#32;is&#32;the&#32;code&#32;???&#32;&quot;</emphasis>);
3049 &#32;&#32;&#32;&#32;}
3050 
3051 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(resultName&#32;!=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>)&#32;{
3052 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;resultFile&#32;=&#32;std::fopen(resultName.c_str(),&#32;<emphasis role="stringliteral">&quot;w&quot;</emphasis>);
3053 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(resultFile&#32;==&#32;NULL)&#32;{
3054 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;resultName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>;
3055 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_fail,&#32;<emphasis role="stringliteral">&quot;Can&#32;not&#32;write&#32;to&#32;the&#32;result&#32;file&quot;</emphasis>);
3056 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
3057 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(appesMode)&#32;{
3058 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::fprintf(resultFile,&#32;<emphasis role="stringliteral">&quot;&lt;?xml&#32;version=\&quot;1.0\&quot;&#32;encoding=\&quot;%s\&quot;?&gt;&quot;</emphasis>,&#32;appesModeEncoding.c_str());
3059 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(isPartial)
3060 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::fprintf(resultFile,&#32;<emphasis role="stringliteral">&quot;&lt;result&#32;outcome&#32;=&#32;\&quot;%s\&quot;&#32;pctype&#32;=&#32;\&quot;%d\&quot;&gt;&quot;</emphasis>,
3061 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;outcomes[(<emphasis role="keywordtype">int</emphasis>)&#32;_partially].c_str(),&#32;pctype);
3062 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
3063 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(result&#32;!=&#32;_points)
3064 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::fprintf(resultFile,&#32;<emphasis role="stringliteral">&quot;&lt;result&#32;outcome&#32;=&#32;\&quot;%s\&quot;&gt;&quot;</emphasis>,&#32;outcomes[(<emphasis role="keywordtype">int</emphasis>)&#32;result].c_str());
3065 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
3066 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__testlib_points&#32;==&#32;std::numeric_limits&lt;float&gt;::infinity())
3067 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_fail,&#32;<emphasis role="stringliteral">&quot;Expected&#32;points,&#32;but&#32;infinity&#32;found&quot;</emphasis>);
3068 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::string&#32;stringPoints&#32;=&#32;removeDoubleTrailingZeroes(format(<emphasis role="stringliteral">&quot;%.10f&quot;</emphasis>,&#32;__testlib_points));
3069 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::fprintf(resultFile,&#32;<emphasis role="stringliteral">&quot;&lt;result&#32;outcome&#32;=&#32;\&quot;%s\&quot;&#32;points&#32;=&#32;\&quot;%s\&quot;&gt;&quot;</emphasis>,
3070 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;outcomes[(<emphasis role="keywordtype">int</emphasis>)&#32;result].c_str(),&#32;stringPoints.c_str());
3071 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
3072 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
3073 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;xmlSafeWrite(resultFile,&#32;__testlib_toPrintableMessage(message).c_str());
3074 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::fprintf(resultFile,&#32;<emphasis role="stringliteral">&quot;&lt;/result&gt;\n&quot;</emphasis>);
3075 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>
3076 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::fprintf(resultFile,&#32;<emphasis role="stringliteral">&quot;%s&quot;</emphasis>,&#32;__testlib_toPrintableMessage(message).c_str());
3077 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(NULL&#32;==&#32;resultFile&#32;||&#32;fclose(resultFile)&#32;!=&#32;0)&#32;{
3078 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;resultName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>;
3079 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_fail,&#32;<emphasis role="stringliteral">&quot;Can&#32;not&#32;write&#32;to&#32;the&#32;result&#32;file&quot;</emphasis>);
3080 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
3081 &#32;&#32;&#32;&#32;}
3082 
3083 &#32;&#32;&#32;&#32;quitscr(LightGray,&#32;__testlib_toPrintableMessage(message).c_str());
3084 &#32;&#32;&#32;&#32;std::fprintf(stderr,&#32;<emphasis role="stringliteral">&quot;\n&quot;</emphasis>);
3085 
3086 &#32;&#32;&#32;&#32;inf.close();
3087 &#32;&#32;&#32;&#32;ouf.close();
3088 &#32;&#32;&#32;&#32;ans.close();
3089 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(tout.is_open())
3090 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;tout.close();
3091 
3092 &#32;&#32;&#32;&#32;textColor(LightGray);
3093 
3094 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(resultName&#32;!=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>)
3095 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::fprintf(stderr,&#32;<emphasis role="stringliteral">&quot;See&#32;file&#32;to&#32;check&#32;exit&#32;message\n&quot;</emphasis>);
3096 
3097 &#32;&#32;&#32;&#32;halt(resultExitCode(result));
3098 }
3099 
3100 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
3101 __attribute__&#32;((format&#32;(printf,&#32;3,&#32;4)))
3102 <emphasis role="preprocessor">#endif</emphasis>
3103 NORETURN&#32;<emphasis role="keywordtype">void</emphasis>&#32;InStream::quitf(TResult&#32;result,&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*msg,&#32;...)&#32;{
3104 &#32;&#32;&#32;&#32;FMT_TO_RESULT(msg,&#32;msg,&#32;message);
3105 &#32;&#32;&#32;&#32;InStream::quit(result,&#32;message.c_str());
3106 }
3107 
3108 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
3109 __attribute__&#32;((format&#32;(printf,&#32;4,&#32;5)))
3110 <emphasis role="preprocessor">#endif</emphasis>
3111 <emphasis role="keywordtype">void</emphasis>&#32;InStream::quitif(<emphasis role="keywordtype">bool</emphasis>&#32;condition,&#32;TResult&#32;result,&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*msg,&#32;...)&#32;{
3112 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(condition)&#32;{
3113 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;FMT_TO_RESULT(msg,&#32;msg,&#32;message);
3114 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;InStream::quit(result,&#32;message.c_str());
3115 &#32;&#32;&#32;&#32;}
3116 }
3117 
3118 NORETURN&#32;<emphasis role="keywordtype">void</emphasis>&#32;InStream::quits(TResult&#32;result,&#32;std::string&#32;msg)&#32;{
3119 &#32;&#32;&#32;&#32;InStream::quit(result,&#32;msg.c_str());
3120 }
3121 
3122 <emphasis role="keywordtype">void</emphasis>&#32;InStream::xmlSafeWrite(std::FILE&#32;*file,&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*msg)&#32;{
3123 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;lmsg&#32;=&#32;strlen(msg);
3124 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">size_t</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;lmsg;&#32;i++)&#32;{
3125 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(msg[i]&#32;==&#32;<emphasis role="charliteral">&apos;&amp;&apos;</emphasis>)&#32;{
3126 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::fprintf(file,&#32;<emphasis role="stringliteral">&quot;%s&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;&amp;amp;&quot;</emphasis>);
3127 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">continue</emphasis>;
3128 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
3129 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(msg[i]&#32;==&#32;<emphasis role="charliteral">&apos;&lt;&apos;</emphasis>)&#32;{
3130 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::fprintf(file,&#32;<emphasis role="stringliteral">&quot;%s&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;&amp;lt;&quot;</emphasis>);
3131 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">continue</emphasis>;
3132 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
3133 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(msg[i]&#32;==&#32;<emphasis role="charliteral">&apos;&gt;&apos;</emphasis>)&#32;{
3134 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::fprintf(file,&#32;<emphasis role="stringliteral">&quot;%s&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;&amp;gt;&quot;</emphasis>);
3135 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">continue</emphasis>;
3136 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
3137 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(msg[i]&#32;==&#32;<emphasis role="charliteral">&apos;&quot;&apos;</emphasis>)&#32;{
3138 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::fprintf(file,&#32;<emphasis role="stringliteral">&quot;%s&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;&amp;quot;&quot;</emphasis>);
3139 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">continue</emphasis>;
3140 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
3141 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(0&#32;&lt;=&#32;msg[i]&#32;&amp;&amp;&#32;msg[i]&#32;&lt;=&#32;31)&#32;{
3142 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::fprintf(file,&#32;<emphasis role="stringliteral">&quot;%c&quot;</emphasis>,&#32;<emphasis role="charliteral">&apos;.&apos;</emphasis>);
3143 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">continue</emphasis>;
3144 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
3145 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::fprintf(file,&#32;<emphasis role="stringliteral">&quot;%c&quot;</emphasis>,&#32;msg[i]);
3146 &#32;&#32;&#32;&#32;}
3147 }
3148 
3149 <emphasis role="keywordtype">void</emphasis>&#32;InStream::quitscrS(WORD&#32;color,&#32;std::string&#32;msg)&#32;{
3150 &#32;&#32;&#32;&#32;quitscr(color,&#32;msg.c_str());
3151 }
3152 
3153 <emphasis role="keywordtype">void</emphasis>&#32;InStream::quitscr(WORD&#32;color,&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*msg)&#32;{
3154 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(resultName&#32;==&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>)&#32;{
3155 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;textColor(color);
3156 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::fprintf(stderr,&#32;<emphasis role="stringliteral">&quot;%s&quot;</emphasis>,&#32;msg);
3157 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;textColor(LightGray);
3158 &#32;&#32;&#32;&#32;}
3159 }
3160 
3161 <emphasis role="keywordtype">void</emphasis>&#32;InStream::reset(std::FILE&#32;*file)&#32;{
3162 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(opened&#32;&amp;&amp;&#32;stdfile)
3163 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_fail,&#32;<emphasis role="stringliteral">&quot;Can&apos;t&#32;reset&#32;standard&#32;handle&quot;</emphasis>);
3164 
3165 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(opened)
3166 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;close();
3167 
3168 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!stdfile&#32;&amp;&amp;&#32;NULL&#32;==&#32;file)
3169 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(NULL&#32;==&#32;(file&#32;=&#32;std::fopen(name.c_str(),&#32;<emphasis role="stringliteral">&quot;rb&quot;</emphasis>)))&#32;{
3170 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(mode&#32;==&#32;_output)
3171 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quits(_pe,&#32;std::string(<emphasis role="stringliteral">&quot;Output&#32;file&#32;not&#32;found:&#32;\&quot;&quot;</emphasis>)&#32;+&#32;name&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&quot;</emphasis>);
3172 
3173 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(mode&#32;==&#32;_answer)
3174 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quits(_fail,&#32;std::string(<emphasis role="stringliteral">&quot;Answer&#32;file&#32;not&#32;found:&#32;\&quot;&quot;</emphasis>)&#32;+&#32;name&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&quot;</emphasis>);
3175 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
3176 
3177 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(NULL&#32;!=&#32;file)&#32;{
3178 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;opened&#32;=&#32;<emphasis role="keyword">true</emphasis>;
3179 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_set_binary(file);
3180 
3181 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(stdfile)
3182 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;reader&#32;=&#32;<emphasis role="keyword">new</emphasis>&#32;<link linkend="_class_file_input_stream_reader">FileInputStreamReader</link>(file,&#32;name);
3183 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
3184 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;reader&#32;=&#32;<emphasis role="keyword">new</emphasis>&#32;<link linkend="_class_buffered_file_input_stream_reader">BufferedFileInputStreamReader</link>(file,&#32;name);
3185 &#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
3186 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;opened&#32;=&#32;<emphasis role="keyword">false</emphasis>;
3187 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;reader&#32;=&#32;NULL;
3188 &#32;&#32;&#32;&#32;}
3189 }
3190 
3191 <emphasis role="keywordtype">void</emphasis>&#32;InStream::init(std::string&#32;fileName,&#32;TMode&#32;mode)&#32;{
3192 &#32;&#32;&#32;&#32;opened&#32;=&#32;<emphasis role="keyword">false</emphasis>;
3193 &#32;&#32;&#32;&#32;name&#32;=&#32;fileName;
3194 &#32;&#32;&#32;&#32;stdfile&#32;=&#32;<emphasis role="keyword">false</emphasis>;
3195 &#32;&#32;&#32;&#32;this-&gt;mode&#32;=&#32;mode;
3196 
3197 &#32;&#32;&#32;&#32;std::ifstream&#32;stream;
3198 &#32;&#32;&#32;&#32;stream.open(fileName.c_str(),&#32;std::ios::in);
3199 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(stream.is_open())&#32;{
3200 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::streampos&#32;start&#32;=&#32;stream.tellg();
3201 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;stream.seekg(0,&#32;std::ios::end);
3202 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::streampos&#32;end&#32;=&#32;stream.tellg();
3203 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;fileSize&#32;=&#32;size_t(end&#32;-&#32;start);
3204 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;stream.close();
3205 
3206 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;You&#32;can&#32;change&#32;maxFileSize.</emphasis>
3207 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Example:&#32;&apos;inf.maxFileSize&#32;=&#32;256&#32;*&#32;1024&#32;*&#32;1024;&apos;.</emphasis>
3208 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(fileSize&#32;&gt;&#32;maxFileSize)
3209 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quitf(_pe,&#32;<emphasis role="stringliteral">&quot;File&#32;size&#32;exceeds&#32;%d&#32;bytes,&#32;size&#32;is&#32;%d&quot;</emphasis>,&#32;<emphasis role="keywordtype">int</emphasis>(maxFileSize),&#32;<emphasis role="keywordtype">int</emphasis>(fileSize));
3210 &#32;&#32;&#32;&#32;}
3211 
3212 &#32;&#32;&#32;&#32;reset();
3213 }
3214 
3215 <emphasis role="keywordtype">void</emphasis>&#32;InStream::init(std::FILE&#32;*f,&#32;TMode&#32;mode)&#32;{
3216 &#32;&#32;&#32;&#32;opened&#32;=&#32;<emphasis role="keyword">false</emphasis>;
3217 &#32;&#32;&#32;&#32;name&#32;=&#32;<emphasis role="stringliteral">&quot;untitled&quot;</emphasis>;
3218 &#32;&#32;&#32;&#32;this-&gt;mode&#32;=&#32;mode;
3219 
3220 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(f&#32;==&#32;stdin)
3221 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;name&#32;=&#32;<emphasis role="stringliteral">&quot;stdin&quot;</emphasis>,&#32;stdfile&#32;=&#32;<emphasis role="keyword">true</emphasis>;
3222 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(f&#32;==&#32;stdout)
3223 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;name&#32;=&#32;<emphasis role="stringliteral">&quot;stdout&quot;</emphasis>,&#32;stdfile&#32;=&#32;<emphasis role="keyword">true</emphasis>;
3224 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(f&#32;==&#32;stderr)
3225 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;name&#32;=&#32;<emphasis role="stringliteral">&quot;stderr&quot;</emphasis>,&#32;stdfile&#32;=&#32;<emphasis role="keyword">true</emphasis>;
3226 
3227 &#32;&#32;&#32;&#32;reset(f);
3228 }
3229 
3230 <emphasis role="keywordtype">void</emphasis>&#32;InStream::skipBom()&#32;{
3231 &#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;utf8Bom&#32;=&#32;<emphasis role="stringliteral">&quot;\xEF\xBB\xBF&quot;</emphasis>;
3232 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;index&#32;=&#32;0;
3233 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">while</emphasis>&#32;(index&#32;&lt;&#32;utf8Bom.size()&#32;&amp;&amp;&#32;curChar()&#32;==&#32;utf8Bom[index])&#32;{
3234 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;index++;
3235 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;skipChar();
3236 &#32;&#32;&#32;&#32;}
3237 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(index&#32;&lt;&#32;utf8Bom.size())&#32;{
3238 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">while</emphasis>&#32;(index&#32;!=&#32;0)&#32;{
3239 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;unreadChar(utf8Bom[index&#32;-&#32;1]);
3240 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;index--;
3241 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
3242 &#32;&#32;&#32;&#32;}
3243 }
3244 
3245 <emphasis role="keywordtype">char</emphasis>&#32;InStream::curChar()&#32;{
3246 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;char(reader-&gt;curChar());
3247 }
3248 
3249 <emphasis role="keywordtype">char</emphasis>&#32;InStream::nextChar()&#32;{
3250 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;char(reader-&gt;nextChar());
3251 }
3252 
3253 <emphasis role="keywordtype">char</emphasis>&#32;InStream::readChar()&#32;{
3254 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;nextChar();
3255 }
3256 
3257 <emphasis role="keywordtype">char</emphasis>&#32;InStream::readChar(<emphasis role="keywordtype">char</emphasis>&#32;c)&#32;{
3258 &#32;&#32;&#32;&#32;lastLine&#32;=&#32;reader-&gt;getLine();
3259 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">char</emphasis>&#32;found&#32;=&#32;readChar();
3260 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(c&#32;!=&#32;found)&#32;{
3261 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!isEoln(found))
3262 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_pe,&#32;(<emphasis role="stringliteral">&quot;Unexpected&#32;character&#32;&apos;&quot;</emphasis>&#32;+&#32;std::string(1,&#32;found)&#32;+&#32;<emphasis role="stringliteral">&quot;&apos;,&#32;but&#32;&apos;&quot;</emphasis>&#32;+&#32;std::string(1,&#32;c)&#32;+
3263 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;&apos;&#32;expected&quot;</emphasis>).c_str());
3264 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
3265 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_pe,&#32;(<emphasis role="stringliteral">&quot;Unexpected&#32;character&#32;&quot;</emphasis>&#32;+&#32;(<emphasis role="stringliteral">&quot;#&quot;</emphasis>&#32;+&#32;vtos(<emphasis role="keywordtype">int</emphasis>(found)))&#32;+&#32;<emphasis role="stringliteral">&quot;,&#32;but&#32;&apos;&quot;</emphasis>&#32;+&#32;std::string(1,&#32;c)&#32;+
3266 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;&apos;&#32;expected&quot;</emphasis>).c_str());
3267 &#32;&#32;&#32;&#32;}
3268 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;found;
3269 }
3270 
3271 <emphasis role="keywordtype">char</emphasis>&#32;InStream::readSpace()&#32;{
3272 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;readChar(<emphasis role="charliteral">&apos;&#32;&apos;</emphasis>);
3273 }
3274 
3275 <emphasis role="keywordtype">void</emphasis>&#32;InStream::unreadChar(<emphasis role="keywordtype">char</emphasis>&#32;c)&#32;{
3276 &#32;&#32;&#32;&#32;reader-&gt;unreadChar(c);
3277 }
3278 
3279 <emphasis role="keywordtype">void</emphasis>&#32;InStream::skipChar()&#32;{
3280 &#32;&#32;&#32;&#32;reader-&gt;skipChar();
3281 }
3282 
3283 <emphasis role="keywordtype">void</emphasis>&#32;InStream::skipBlanks()&#32;{
3284 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">while</emphasis>&#32;(isBlanks(reader-&gt;curChar()))
3285 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;reader-&gt;skipChar();
3286 }
3287 
3288 std::string&#32;InStream::readWord()&#32;{
3289 &#32;&#32;&#32;&#32;readWordTo(_tmpReadToken);
3290 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;_tmpReadToken;
3291 }
3292 
3293 <emphasis role="keywordtype">void</emphasis>&#32;InStream::readWordTo(std::string&#32;&amp;result)&#32;{
3294 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!strict)
3295 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;skipBlanks();
3296 
3297 &#32;&#32;&#32;&#32;lastLine&#32;=&#32;reader-&gt;getLine();
3298 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;cur&#32;=&#32;reader-&gt;nextChar();
3299 
3300 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(cur&#32;==&#32;EOFC)
3301 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_unexpected_eof,&#32;<emphasis role="stringliteral">&quot;Unexpected&#32;end&#32;of&#32;file&#32;-&#32;token&#32;expected&quot;</emphasis>);
3302 
3303 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(isBlanks(cur))
3304 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_pe,&#32;<emphasis role="stringliteral">&quot;Unexpected&#32;white-space&#32;-&#32;token&#32;expected&quot;</emphasis>);
3305 
3306 &#32;&#32;&#32;&#32;result.clear();
3307 
3308 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">while</emphasis>&#32;(!(isBlanks(cur)&#32;||&#32;cur&#32;==&#32;EOFC))&#32;{
3309 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result&#32;+=&#32;char(cur);
3310 
3311 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;You&#32;can&#32;change&#32;maxTokenLength.</emphasis>
3312 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Example:&#32;&apos;inf.maxTokenLength&#32;=&#32;128&#32;*&#32;1024&#32;*&#32;1024;&apos;.</emphasis>
3313 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(result.length()&#32;&gt;&#32;maxTokenLength)
3314 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quitf(_pe,&#32;<emphasis role="stringliteral">&quot;Length&#32;of&#32;token&#32;exceeds&#32;%d,&#32;token&#32;is&#32;&apos;%s...&apos;&quot;</emphasis>,&#32;<emphasis role="keywordtype">int</emphasis>(maxTokenLength),
3315 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_part(result).c_str());
3316 
3317 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;cur&#32;=&#32;reader-&gt;nextChar();
3318 &#32;&#32;&#32;&#32;}
3319 
3320 &#32;&#32;&#32;&#32;reader-&gt;unreadChar(cur);
3321 
3322 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(result.length()&#32;==&#32;0)
3323 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_unexpected_eof,&#32;<emphasis role="stringliteral">&quot;Unexpected&#32;end&#32;of&#32;file&#32;or&#32;white-space&#32;-&#32;token&#32;expected&quot;</emphasis>);
3324 }
3325 
3326 std::string&#32;InStream::readToken()&#32;{
3327 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;readWord();
3328 }
3329 
3330 <emphasis role="keywordtype">void</emphasis>&#32;InStream::readTokenTo(std::string&#32;&amp;result)&#32;{
3331 &#32;&#32;&#32;&#32;readWordTo(result);
3332 }
3333 
3334 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
3335 __attribute__((<emphasis role="keyword">const</emphasis>))
3336 <emphasis role="preprocessor">#endif</emphasis>
3337 <emphasis role="keyword">static</emphasis>&#32;std::string&#32;__testlib_part(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;s)&#32;{
3338 &#32;&#32;&#32;&#32;std::string&#32;t;
3339 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">size_t</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;s.length();&#32;i++)
3340 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(s[i]&#32;!=&#32;<emphasis role="charliteral">&apos;\0&apos;</emphasis>)
3341 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;t&#32;+=&#32;s[i];
3342 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
3343 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;t&#32;+=&#32;<emphasis role="charliteral">&apos;~&apos;</emphasis>;
3344 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(t.length()&#32;&lt;=&#32;64)
3345 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;t;
3346 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
3347 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;t.substr(0,&#32;30)&#32;+&#32;<emphasis role="stringliteral">&quot;...&quot;</emphasis>&#32;+&#32;t.substr(s.length()&#32;-&#32;31,&#32;31);
3348 }
3349 
3350 <emphasis role="preprocessor">#define&#32;__testlib_readMany(readMany,&#32;readOne,&#32;typeName,&#32;space)&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;\</emphasis>
3351 <emphasis role="preprocessor">&#32;&#32;&#32;&#32;if&#32;(size&#32;&lt;&#32;0)&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;\</emphasis>
3352 <emphasis role="preprocessor">&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_fail,&#32;#readMany&#32;&quot;:&#32;size&#32;should&#32;be&#32;non-negative.&quot;);&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;\</emphasis>
3353 <emphasis role="preprocessor">&#32;&#32;&#32;&#32;if&#32;(size&#32;&gt;&#32;100000000)&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;\</emphasis>
3354 <emphasis role="preprocessor">&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_fail,&#32;#readMany&#32;&quot;:&#32;size&#32;should&#32;be&#32;at&#32;most&#32;100000000.&quot;);&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;\</emphasis>
3355 <emphasis role="preprocessor">&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;\</emphasis>
3356 <emphasis role="preprocessor">&#32;&#32;&#32;&#32;std::vector&lt;typeName&gt;&#32;result(size);&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;\</emphasis>
3357 <emphasis role="preprocessor">&#32;&#32;&#32;&#32;readManyIteration&#32;=&#32;indexBase;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;\</emphasis>
3358 <emphasis role="preprocessor">&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;\</emphasis>
3359 <emphasis role="preprocessor">&#32;&#32;&#32;&#32;for&#32;(int&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;size;&#32;i++)&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;\</emphasis>
3360 <emphasis role="preprocessor">&#32;&#32;&#32;&#32;{&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;\</emphasis>
3361 <emphasis role="preprocessor">&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result[i]&#32;=&#32;readOne;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;\</emphasis>
3362 <emphasis role="preprocessor">&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;readManyIteration++;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;\</emphasis>
3363 <emphasis role="preprocessor">&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;if&#32;(strict&#32;&amp;&amp;&#32;space&#32;&amp;&amp;&#32;i&#32;+&#32;1&#32;&lt;&#32;size)&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;\</emphasis>
3364 <emphasis role="preprocessor">&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;readSpace();&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;\</emphasis>
3365 <emphasis role="preprocessor">&#32;&#32;&#32;&#32;}&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;\</emphasis>
3366 <emphasis role="preprocessor">&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;\</emphasis>
3367 <emphasis role="preprocessor">&#32;&#32;&#32;&#32;readManyIteration&#32;=&#32;NO_INDEX;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;\</emphasis>
3368 <emphasis role="preprocessor">&#32;&#32;&#32;&#32;return&#32;result;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;\</emphasis>
3369 <emphasis role="preprocessor"></emphasis>
3370 
3371 std::string&#32;InStream::readWord(<emphasis role="keyword">const</emphasis>&#32;<link linkend="_classpattern">pattern</link>&#32;&amp;p,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName)&#32;{
3372 &#32;&#32;&#32;&#32;readWordTo(_tmpReadToken);
3373 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!p.matches(_tmpReadToken))&#32;{
3374 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(readManyIteration&#32;==&#32;NO_INDEX)&#32;{
3375 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(variableName.empty())
3376 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_wa,
3377 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;(<emphasis role="stringliteral">&quot;Token&#32;\&quot;&quot;</emphasis>&#32;+&#32;__testlib_part(_tmpReadToken)&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&#32;doesn&apos;t&#32;correspond&#32;to&#32;pattern&#32;\&quot;&quot;</emphasis>&#32;+&#32;p.src()&#32;+
3378 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;\&quot;&quot;</emphasis>).c_str());
3379 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
3380 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_wa,&#32;(<emphasis role="stringliteral">&quot;Token&#32;parameter&#32;[name=&quot;</emphasis>&#32;+&#32;variableName&#32;+&#32;<emphasis role="stringliteral">&quot;]&#32;equals&#32;to&#32;\&quot;&quot;</emphasis>&#32;+&#32;__testlib_part(_tmpReadToken)&#32;+
3381 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;\&quot;,&#32;doesn&apos;t&#32;correspond&#32;to&#32;pattern&#32;\&quot;&quot;</emphasis>&#32;+&#32;p.src()&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&quot;</emphasis>).c_str());
3382 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
3383 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(variableName.empty())
3384 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_wa,&#32;(<emphasis role="stringliteral">&quot;Token&#32;element&#32;[index=&quot;</emphasis>&#32;+&#32;vtos(readManyIteration)&#32;+&#32;<emphasis role="stringliteral">&quot;]&#32;equals&#32;to&#32;\&quot;&quot;</emphasis>&#32;+
3385 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_part(_tmpReadToken)&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&#32;doesn&apos;t&#32;correspond&#32;to&#32;pattern&#32;\&quot;&quot;</emphasis>&#32;+&#32;p.src()&#32;+
3386 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;\&quot;&quot;</emphasis>).c_str());
3387 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
3388 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_wa,&#32;(<emphasis role="stringliteral">&quot;Token&#32;element&#32;&quot;</emphasis>&#32;+&#32;variableName&#32;+&#32;<emphasis role="stringliteral">&quot;[&quot;</emphasis>&#32;+&#32;vtos(readManyIteration)&#32;+&#32;<emphasis role="stringliteral">&quot;]&#32;equals&#32;to&#32;\&quot;&quot;</emphasis>&#32;+
3389 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_part(_tmpReadToken)&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;,&#32;doesn&apos;t&#32;correspond&#32;to&#32;pattern&#32;\&quot;&quot;</emphasis>&#32;+&#32;p.src()&#32;+
3390 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;\&quot;&quot;</emphasis>).c_str());
3391 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
3392 &#32;&#32;&#32;&#32;}
3393 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;_tmpReadToken;
3394 }
3395 
3396 std::vector&lt;std::string&gt;
3397 InStream::readWords(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keyword">const</emphasis>&#32;<link linkend="_classpattern">pattern</link>&#32;&amp;p,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variablesName,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase)&#32;{
3398 &#32;&#32;&#32;&#32;__testlib_readMany(readWords,&#32;readWord(p,&#32;variablesName),&#32;std::string,&#32;<emphasis role="keyword">true</emphasis>);
3399 }
3400 
3401 std::vector&lt;std::string&gt;&#32;InStream::readWords(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase)&#32;{
3402 &#32;&#32;&#32;&#32;__testlib_readMany(readWords,&#32;readWord(),&#32;std::string,&#32;<emphasis role="keyword">true</emphasis>);
3403 }
3404 
3405 std::string&#32;InStream::readWord(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;ptrn,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName)&#32;{
3406 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;readWord(<link linkend="_classpattern">pattern</link>(ptrn),&#32;variableName);
3407 }
3408 
3409 std::vector&lt;std::string&gt;
3410 InStream::readWords(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;ptrn,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variablesName,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase)&#32;{
3411 &#32;&#32;&#32;&#32;<link linkend="_classpattern">pattern</link>&#32;p(ptrn);
3412 &#32;&#32;&#32;&#32;__testlib_readMany(readWords,&#32;readWord(p,&#32;variablesName),&#32;std::string,&#32;<emphasis role="keyword">true</emphasis>);
3413 }
3414 
3415 std::string&#32;InStream::readToken(<emphasis role="keyword">const</emphasis>&#32;<link linkend="_classpattern">pattern</link>&#32;&amp;p,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName)&#32;{
3416 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;readWord(p,&#32;variableName);
3417 }
3418 
3419 std::vector&lt;std::string&gt;
3420 InStream::readTokens(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keyword">const</emphasis>&#32;<link linkend="_classpattern">pattern</link>&#32;&amp;p,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variablesName,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase)&#32;{
3421 &#32;&#32;&#32;&#32;__testlib_readMany(readTokens,&#32;readToken(p,&#32;variablesName),&#32;std::string,&#32;<emphasis role="keyword">true</emphasis>);
3422 }
3423 
3424 std::vector&lt;std::string&gt;&#32;InStream::readTokens(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase)&#32;{
3425 &#32;&#32;&#32;&#32;__testlib_readMany(readTokens,&#32;readToken(),&#32;std::string,&#32;<emphasis role="keyword">true</emphasis>);
3426 }
3427 
3428 std::string&#32;InStream::readToken(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;ptrn,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName)&#32;{
3429 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;readWord(ptrn,&#32;variableName);
3430 }
3431 
3432 std::vector&lt;std::string&gt;
3433 InStream::readTokens(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;ptrn,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variablesName,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase)&#32;{
3434 &#32;&#32;&#32;&#32;<link linkend="_classpattern">pattern</link>&#32;p(ptrn);
3435 &#32;&#32;&#32;&#32;__testlib_readMany(readTokens,&#32;readWord(p,&#32;variablesName),&#32;std::string,&#32;<emphasis role="keyword">true</emphasis>);
3436 }
3437 
3438 <emphasis role="keywordtype">void</emphasis>&#32;InStream::readWordTo(std::string&#32;&amp;result,&#32;<emphasis role="keyword">const</emphasis>&#32;<link linkend="_classpattern">pattern</link>&#32;&amp;p,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName)&#32;{
3439 &#32;&#32;&#32;&#32;readWordTo(result);
3440 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!p.matches(result))&#32;{
3441 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(variableName.empty())
3442 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_wa,&#32;(<emphasis role="stringliteral">&quot;Token&#32;\&quot;&quot;</emphasis>&#32;+&#32;__testlib_part(result)&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&#32;doesn&apos;t&#32;correspond&#32;to&#32;pattern&#32;\&quot;&quot;</emphasis>&#32;+&#32;p.src()&#32;+
3443 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;\&quot;&quot;</emphasis>).c_str());
3444 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
3445 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_wa,&#32;(<emphasis role="stringliteral">&quot;Token&#32;parameter&#32;[name=&quot;</emphasis>&#32;+&#32;variableName&#32;+&#32;<emphasis role="stringliteral">&quot;]&#32;equals&#32;to&#32;\&quot;&quot;</emphasis>&#32;+&#32;__testlib_part(result)&#32;+
3446 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;\&quot;,&#32;doesn&apos;t&#32;correspond&#32;to&#32;pattern&#32;\&quot;&quot;</emphasis>&#32;+&#32;p.src()&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&quot;</emphasis>).c_str());
3447 &#32;&#32;&#32;&#32;}
3448 }
3449 
3450 <emphasis role="keywordtype">void</emphasis>&#32;InStream::readWordTo(std::string&#32;&amp;result,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;ptrn,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName)&#32;{
3451 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;readWordTo(result,&#32;<link linkend="_classpattern">pattern</link>(ptrn),&#32;variableName);
3452 }
3453 
3454 <emphasis role="keywordtype">void</emphasis>&#32;InStream::readTokenTo(std::string&#32;&amp;result,&#32;<emphasis role="keyword">const</emphasis>&#32;<link linkend="_classpattern">pattern</link>&#32;&amp;p,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName)&#32;{
3455 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;readWordTo(result,&#32;p,&#32;variableName);
3456 }
3457 
3458 <emphasis role="keywordtype">void</emphasis>&#32;InStream::readTokenTo(std::string&#32;&amp;result,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;ptrn,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName)&#32;{
3459 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;readWordTo(result,&#32;ptrn,&#32;variableName);
3460 }
3461 
3462 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
3463 __attribute__((pure))
3464 <emphasis role="preprocessor">#endif</emphasis>
3465 <emphasis role="keyword">static</emphasis>&#32;<emphasis role="keyword">inline</emphasis>&#32;<emphasis role="keywordtype">bool</emphasis>&#32;equals(<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;integer,&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*s)&#32;{
3466 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(integer&#32;==&#32;LLONG_MIN)
3467 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;strcmp(s,&#32;<emphasis role="stringliteral">&quot;-9223372036854775808&quot;</emphasis>)&#32;==&#32;0;
3468 
3469 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(integer&#32;==&#32;0LL)
3470 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;strcmp(s,&#32;<emphasis role="stringliteral">&quot;0&quot;</emphasis>)&#32;==&#32;0;
3471 
3472 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;length&#32;=&#32;strlen(s);
3473 
3474 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(length&#32;==&#32;0)
3475 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
3476 
3477 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(integer&#32;&lt;&#32;0&#32;&amp;&amp;&#32;s[0]&#32;!=&#32;<emphasis role="charliteral">&apos;-&apos;</emphasis>)
3478 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
3479 
3480 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(integer&#32;&lt;&#32;0)
3481 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;s++,&#32;length--,&#32;integer&#32;=&#32;-integer;
3482 
3483 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(length&#32;==&#32;0)
3484 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
3485 
3486 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">while</emphasis>&#32;(integer&#32;&gt;&#32;0)&#32;{
3487 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;digit&#32;=&#32;int(integer&#32;%&#32;10);
3488 
3489 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(s[length&#32;-&#32;1]&#32;!=&#32;<emphasis role="charliteral">&apos;0&apos;</emphasis>&#32;+&#32;digit)
3490 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
3491 
3492 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;length--;
3493 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;integer&#32;/=&#32;10;
3494 &#32;&#32;&#32;&#32;}
3495 
3496 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;length&#32;==&#32;0;
3497 }
3498 
3499 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
3500 __attribute__((pure))
3501 <emphasis role="preprocessor">#endif</emphasis>
3502 <emphasis role="keyword">static</emphasis>&#32;<emphasis role="keyword">inline</emphasis>&#32;<emphasis role="keywordtype">bool</emphasis>&#32;equals(<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;integer,&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*s)&#32;{
3503 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(integer&#32;==&#32;ULLONG_MAX)
3504 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;strcmp(s,&#32;<emphasis role="stringliteral">&quot;18446744073709551615&quot;</emphasis>)&#32;==&#32;0;
3505 
3506 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(integer&#32;==&#32;0ULL)
3507 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;strcmp(s,&#32;<emphasis role="stringliteral">&quot;0&quot;</emphasis>)&#32;==&#32;0;
3508 
3509 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;length&#32;=&#32;strlen(s);
3510 
3511 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(length&#32;==&#32;0)
3512 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
3513 
3514 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">while</emphasis>&#32;(integer&#32;&gt;&#32;0)&#32;{
3515 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;digit&#32;=&#32;int(integer&#32;%&#32;10);
3516 
3517 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(s[length&#32;-&#32;1]&#32;!=&#32;<emphasis role="charliteral">&apos;0&apos;</emphasis>&#32;+&#32;digit)
3518 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
3519 
3520 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;length--;
3521 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;integer&#32;/=&#32;10;
3522 &#32;&#32;&#32;&#32;}
3523 
3524 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;length&#32;==&#32;0;
3525 }
3526 
3527 <emphasis role="keyword">static</emphasis>&#32;<emphasis role="keyword">inline</emphasis>&#32;<emphasis role="keywordtype">double</emphasis>&#32;stringToDouble(<link linkend="_struct_in_stream">InStream</link>&#32;&amp;in,&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*buffer)&#32;{
3528 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">double</emphasis>&#32;result;
3529 
3530 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;length&#32;=&#32;strlen(buffer);
3531 
3532 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;minusCount&#32;=&#32;0;
3533 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;plusCount&#32;=&#32;0;
3534 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;decimalPointCount&#32;=&#32;0;
3535 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;digitCount&#32;=&#32;0;
3536 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;eCount&#32;=&#32;0;
3537 
3538 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">size_t</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;length;&#32;i++)&#32;{
3539 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;((<emphasis role="charliteral">&apos;0&apos;</emphasis>&#32;&lt;=&#32;buffer[i]&#32;&amp;&amp;&#32;buffer[i]&#32;&lt;=&#32;<emphasis role="charliteral">&apos;9&apos;</emphasis>)&#32;||&#32;buffer[i]&#32;==&#32;<emphasis role="charliteral">&apos;.&apos;</emphasis>
3540 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;||&#32;buffer[i]&#32;==&#32;<emphasis role="charliteral">&apos;e&apos;</emphasis>&#32;||&#32;buffer[i]&#32;==&#32;<emphasis role="charliteral">&apos;E&apos;</emphasis>
3541 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;||&#32;buffer[i]&#32;==&#32;<emphasis role="charliteral">&apos;-&apos;</emphasis>&#32;||&#32;buffer[i]&#32;==&#32;<emphasis role="charliteral">&apos;+&apos;</emphasis>)&#32;{
3542 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(<emphasis role="charliteral">&apos;0&apos;</emphasis>&#32;&lt;=&#32;buffer[i]&#32;&amp;&amp;&#32;buffer[i]&#32;&lt;=&#32;<emphasis role="charliteral">&apos;9&apos;</emphasis>)
3543 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;digitCount++;
3544 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(buffer[i]&#32;==&#32;<emphasis role="charliteral">&apos;e&apos;</emphasis>&#32;||&#32;buffer[i]&#32;==&#32;<emphasis role="charliteral">&apos;E&apos;</emphasis>)
3545 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;eCount++;
3546 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(buffer[i]&#32;==&#32;<emphasis role="charliteral">&apos;-&apos;</emphasis>)
3547 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;minusCount++;
3548 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(buffer[i]&#32;==&#32;<emphasis role="charliteral">&apos;+&apos;</emphasis>)
3549 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;plusCount++;
3550 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(buffer[i]&#32;==&#32;<emphasis role="charliteral">&apos;.&apos;</emphasis>)
3551 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;decimalPointCount++;
3552 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>
3553 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;in.quit(_pe,&#32;(<emphasis role="stringliteral">&quot;Expected&#32;double,&#32;but&#32;\&quot;&quot;</emphasis>&#32;+&#32;__testlib_part(buffer)&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&#32;found&quot;</emphasis>).c_str());
3554 &#32;&#32;&#32;&#32;}
3555 
3556 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;If&#32;for&#32;sure&#32;is&#32;not&#32;a&#32;number&#32;in&#32;standard&#32;notation&#32;or&#32;in&#32;e-notation.</emphasis>
3557 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(digitCount&#32;==&#32;0&#32;||&#32;minusCount&#32;&gt;&#32;2&#32;||&#32;plusCount&#32;&gt;&#32;2&#32;||&#32;decimalPointCount&#32;&gt;&#32;1&#32;||&#32;eCount&#32;&gt;&#32;1)
3558 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;in.quit(_pe,&#32;(<emphasis role="stringliteral">&quot;Expected&#32;double,&#32;but&#32;\&quot;&quot;</emphasis>&#32;+&#32;__testlib_part(buffer)&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&#32;found&quot;</emphasis>).c_str());
3559 
3560 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">char</emphasis>&#32;*suffix&#32;=&#32;<emphasis role="keyword">new</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>[length&#32;+&#32;1];
3561 &#32;&#32;&#32;&#32;std::memset(suffix,&#32;0,&#32;length&#32;+&#32;1);
3562 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;scanned&#32;=&#32;std::sscanf(buffer,&#32;<emphasis role="stringliteral">&quot;%lf%s&quot;</emphasis>,&#32;&amp;result,&#32;suffix);
3563 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;empty&#32;=&#32;strlen(suffix)&#32;==&#32;0;
3564 &#32;&#32;&#32;&#32;<emphasis role="keyword">delete</emphasis>[]&#32;suffix;
3565 
3566 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(scanned&#32;==&#32;1&#32;||&#32;(scanned&#32;==&#32;2&#32;&amp;&amp;&#32;empty))&#32;{
3567 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__testlib_isNaN(result))
3568 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;in.quit(_pe,&#32;(<emphasis role="stringliteral">&quot;Expected&#32;double,&#32;but&#32;\&quot;&quot;</emphasis>&#32;+&#32;__testlib_part(buffer)&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&#32;found&quot;</emphasis>).c_str());
3569 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;result;
3570 &#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>
3571 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;in.quit(_pe,&#32;(<emphasis role="stringliteral">&quot;Expected&#32;double,&#32;but&#32;\&quot;&quot;</emphasis>&#32;+&#32;__testlib_part(buffer)&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&#32;found&quot;</emphasis>).c_str());
3572 }
3573 
3574 <emphasis role="keyword">static</emphasis>&#32;<emphasis role="keyword">inline</emphasis>&#32;<emphasis role="keywordtype">double</emphasis>&#32;stringToDouble(<link linkend="_struct_in_stream">InStream</link>&#32;&amp;in,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&amp;&#32;buffer)&#32;{
3575 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">size_t</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;buffer.length();&#32;i++)
3576 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(buffer[i]&#32;==&#32;<emphasis role="charliteral">&apos;\0&apos;</emphasis>)
3577 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;in.quit(_pe,&#32;(<emphasis role="stringliteral">&quot;Expected&#32;double,&#32;but&#32;\&quot;&quot;</emphasis>&#32;+&#32;__testlib_part(buffer)&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&#32;found&#32;(it&#32;contains&#32;\\0)&quot;</emphasis>).c_str());
3578 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;stringToDouble(in,&#32;buffer.c_str());
3579 }
3580 
3581 <emphasis role="keyword">static</emphasis>&#32;<emphasis role="keyword">inline</emphasis>&#32;<emphasis role="keywordtype">double</emphasis>&#32;stringToStrictDouble(<link linkend="_struct_in_stream">InStream</link>&#32;&amp;in,&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*buffer,
3582 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;minAfterPointDigitCount,&#32;<emphasis role="keywordtype">int</emphasis>&#32;maxAfterPointDigitCount)&#32;{
3583 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(minAfterPointDigitCount&#32;&lt;&#32;0)
3584 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;in.quit(_fail,&#32;<emphasis role="stringliteral">&quot;stringToStrictDouble:&#32;minAfterPointDigitCount&#32;should&#32;be&#32;non-negative.&quot;</emphasis>);
3585 
3586 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(minAfterPointDigitCount&#32;&gt;&#32;maxAfterPointDigitCount)
3587 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;in.quit(_fail,
3588 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;stringToStrictDouble:&#32;minAfterPointDigitCount&#32;should&#32;be&#32;less&#32;or&#32;equal&#32;to&#32;maxAfterPointDigitCount.&quot;</emphasis>);
3589 
3590 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">double</emphasis>&#32;result;
3591 
3592 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;length&#32;=&#32;strlen(buffer);
3593 
3594 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(length&#32;==&#32;0&#32;||&#32;length&#32;&gt;&#32;1000)
3595 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;in.quit(_pe,&#32;(<emphasis role="stringliteral">&quot;Expected&#32;strict&#32;double,&#32;but&#32;\&quot;&quot;</emphasis>&#32;+&#32;__testlib_part(buffer)&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&#32;found&quot;</emphasis>).c_str());
3596 
3597 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(buffer[0]&#32;!=&#32;<emphasis role="charliteral">&apos;-&apos;</emphasis>&#32;&amp;&amp;&#32;(buffer[0]&#32;&lt;&#32;<emphasis role="charliteral">&apos;0&apos;</emphasis>&#32;||&#32;buffer[0]&#32;&gt;&#32;<emphasis role="charliteral">&apos;9&apos;</emphasis>))
3598 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;in.quit(_pe,&#32;(<emphasis role="stringliteral">&quot;Expected&#32;strict&#32;double,&#32;but&#32;\&quot;&quot;</emphasis>&#32;+&#32;__testlib_part(buffer)&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&#32;found&quot;</emphasis>).c_str());
3599 
3600 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;pointPos&#32;=&#32;-1;
3601 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">size_t</emphasis>&#32;i&#32;=&#32;1;&#32;i&#32;+&#32;1&#32;&lt;&#32;length;&#32;i++)&#32;{
3602 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(buffer[i]&#32;==&#32;<emphasis role="charliteral">&apos;.&apos;</emphasis>)&#32;{
3603 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(pointPos&#32;&gt;&#32;-1)
3604 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;in.quit(_pe,&#32;(<emphasis role="stringliteral">&quot;Expected&#32;strict&#32;double,&#32;but&#32;\&quot;&quot;</emphasis>&#32;+&#32;__testlib_part(buffer)&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&#32;found&quot;</emphasis>).c_str());
3605 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;pointPos&#32;=&#32;int(i);
3606 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
3607 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(buffer[i]&#32;!=&#32;<emphasis role="charliteral">&apos;.&apos;</emphasis>&#32;&amp;&amp;&#32;(buffer[i]&#32;&lt;&#32;<emphasis role="charliteral">&apos;0&apos;</emphasis>&#32;||&#32;buffer[i]&#32;&gt;&#32;<emphasis role="charliteral">&apos;9&apos;</emphasis>))
3608 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;in.quit(_pe,&#32;(<emphasis role="stringliteral">&quot;Expected&#32;strict&#32;double,&#32;but&#32;\&quot;&quot;</emphasis>&#32;+&#32;__testlib_part(buffer)&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&#32;found&quot;</emphasis>).c_str());
3609 &#32;&#32;&#32;&#32;}
3610 
3611 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(buffer[length&#32;-&#32;1]&#32;&lt;&#32;<emphasis role="charliteral">&apos;0&apos;</emphasis>&#32;||&#32;buffer[length&#32;-&#32;1]&#32;&gt;&#32;<emphasis role="charliteral">&apos;9&apos;</emphasis>)
3612 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;in.quit(_pe,&#32;(<emphasis role="stringliteral">&quot;Expected&#32;strict&#32;double,&#32;but&#32;\&quot;&quot;</emphasis>&#32;+&#32;__testlib_part(buffer)&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&#32;found&quot;</emphasis>).c_str());
3613 
3614 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;afterDigitsCount&#32;=&#32;(pointPos&#32;==&#32;-1&#32;?&#32;0&#32;:&#32;int(length)&#32;-&#32;pointPos&#32;-&#32;1);
3615 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(afterDigitsCount&#32;&lt;&#32;minAfterPointDigitCount&#32;||&#32;afterDigitsCount&#32;&gt;&#32;maxAfterPointDigitCount)
3616 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;in.quit(_pe,&#32;(<emphasis role="stringliteral">&quot;Expected&#32;strict&#32;double&#32;with&#32;number&#32;of&#32;digits&#32;after&#32;point&#32;in&#32;range&#32;[&quot;</emphasis>
3617 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;+&#32;vtos(minAfterPointDigitCount)
3618 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;+&#32;<emphasis role="stringliteral">&quot;,&quot;</emphasis>
3619 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;+&#32;vtos(maxAfterPointDigitCount)
3620 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;+&#32;<emphasis role="stringliteral">&quot;],&#32;but&#32;\&quot;&quot;</emphasis>&#32;+&#32;__testlib_part(buffer)&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&#32;found&quot;</emphasis>).c_str()
3621 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;);
3622 
3623 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;firstDigitPos&#32;=&#32;-1;
3624 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">size_t</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;length;&#32;i++)
3625 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(buffer[i]&#32;&gt;=&#32;<emphasis role="charliteral">&apos;0&apos;</emphasis>&#32;&amp;&amp;&#32;buffer[i]&#32;&lt;=&#32;<emphasis role="charliteral">&apos;9&apos;</emphasis>)&#32;{
3626 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;firstDigitPos&#32;=&#32;int(i);
3627 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">break</emphasis>;
3628 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
3629 
3630 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(firstDigitPos&#32;&gt;&#32;1&#32;||&#32;firstDigitPos&#32;==&#32;-1)
3631 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;in.quit(_pe,&#32;(<emphasis role="stringliteral">&quot;Expected&#32;strict&#32;double,&#32;but&#32;\&quot;&quot;</emphasis>&#32;+&#32;__testlib_part(buffer)&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&#32;found&quot;</emphasis>).c_str());
3632 
3633 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(buffer[firstDigitPos]&#32;==&#32;<emphasis role="charliteral">&apos;0&apos;</emphasis>&#32;&amp;&amp;&#32;firstDigitPos&#32;+&#32;1&#32;&lt;&#32;<emphasis role="keywordtype">int</emphasis>(length)
3634 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&amp;&amp;&#32;buffer[firstDigitPos&#32;+&#32;1]&#32;&gt;=&#32;<emphasis role="charliteral">&apos;0&apos;</emphasis>&#32;&amp;&amp;&#32;buffer[firstDigitPos&#32;+&#32;1]&#32;&lt;=&#32;<emphasis role="charliteral">&apos;9&apos;</emphasis>)
3635 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;in.quit(_pe,&#32;(<emphasis role="stringliteral">&quot;Expected&#32;strict&#32;double,&#32;but&#32;\&quot;&quot;</emphasis>&#32;+&#32;__testlib_part(buffer)&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&#32;found&quot;</emphasis>).c_str());
3636 
3637 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">char</emphasis>&#32;*suffix&#32;=&#32;<emphasis role="keyword">new</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>[length&#32;+&#32;1];
3638 &#32;&#32;&#32;&#32;std::memset(suffix,&#32;0,&#32;length&#32;+&#32;1);
3639 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;scanned&#32;=&#32;std::sscanf(buffer,&#32;<emphasis role="stringliteral">&quot;%lf%s&quot;</emphasis>,&#32;&amp;result,&#32;suffix);
3640 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;empty&#32;=&#32;strlen(suffix)&#32;==&#32;0;
3641 &#32;&#32;&#32;&#32;<emphasis role="keyword">delete</emphasis>[]&#32;suffix;
3642 
3643 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(scanned&#32;==&#32;1&#32;||&#32;(scanned&#32;==&#32;2&#32;&amp;&amp;&#32;empty))&#32;{
3644 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__testlib_isNaN(result)&#32;||&#32;__testlib_isInfinite(result))
3645 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;in.quit(_pe,&#32;(<emphasis role="stringliteral">&quot;Expected&#32;double,&#32;but&#32;\&quot;&quot;</emphasis>&#32;+&#32;__testlib_part(buffer)&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&#32;found&quot;</emphasis>).c_str());
3646 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(buffer[0]&#32;==&#32;<emphasis role="charliteral">&apos;-&apos;</emphasis>&#32;&amp;&amp;&#32;result&#32;&gt;=&#32;0)
3647 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;in.quit(_pe,&#32;(<emphasis role="stringliteral">&quot;Redundant&#32;minus&#32;in&#32;\&quot;&quot;</emphasis>&#32;+&#32;__testlib_part(buffer)&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&#32;found&quot;</emphasis>).c_str());
3648 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;result;
3649 &#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>
3650 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;in.quit(_pe,&#32;(<emphasis role="stringliteral">&quot;Expected&#32;double,&#32;but&#32;\&quot;&quot;</emphasis>&#32;+&#32;__testlib_part(buffer)&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&#32;found&quot;</emphasis>).c_str());
3651 }
3652 
3653 <emphasis role="keyword">static</emphasis>&#32;<emphasis role="keyword">inline</emphasis>&#32;<emphasis role="keywordtype">double</emphasis>&#32;stringToStrictDouble(<link linkend="_struct_in_stream">InStream</link>&#32;&amp;in,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&amp;&#32;buffer,
3654 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;minAfterPointDigitCount,&#32;<emphasis role="keywordtype">int</emphasis>&#32;maxAfterPointDigitCount)&#32;{
3655 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">size_t</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;buffer.length();&#32;i++)
3656 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(buffer[i]&#32;==&#32;<emphasis role="charliteral">&apos;\0&apos;</emphasis>)
3657 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;in.quit(_pe,&#32;(<emphasis role="stringliteral">&quot;Expected&#32;double,&#32;but&#32;\&quot;&quot;</emphasis>&#32;+&#32;__testlib_part(buffer)&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&#32;found&#32;(it&#32;contains&#32;\\0)&quot;</emphasis>).c_str());
3658 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;stringToStrictDouble(in,&#32;buffer.c_str(),&#32;minAfterPointDigitCount,&#32;maxAfterPointDigitCount);
3659 }
3660 
3661 <emphasis role="keyword">static</emphasis>&#32;<emphasis role="keyword">inline</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;stringToLongLong(<link linkend="_struct_in_stream">InStream</link>&#32;&amp;in,&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*buffer)&#32;{
3662 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;length&#32;=&#32;strlen(buffer);
3663 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(length&#32;==&#32;0&#32;||&#32;length&#32;&gt;&#32;20)
3664 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;in.quit(_pe,&#32;(<emphasis role="stringliteral">&quot;Expected&#32;integer,&#32;but&#32;\&quot;&quot;</emphasis>&#32;+&#32;__testlib_part(buffer)&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&#32;found&quot;</emphasis>).c_str());
3665 
3666 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;has_minus&#32;=&#32;(length&#32;&gt;&#32;1&#32;&amp;&amp;&#32;buffer[0]&#32;==&#32;<emphasis role="charliteral">&apos;-&apos;</emphasis>);
3667 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;zeroes&#32;=&#32;0;
3668 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;processingZeroes&#32;=&#32;<emphasis role="keyword">true</emphasis>;
3669 
3670 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">int</emphasis>&#32;i&#32;=&#32;(has_minus&#32;?&#32;1&#32;:&#32;0);&#32;i&#32;&lt;&#32;int(length);&#32;i++)&#32;{
3671 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(buffer[i]&#32;==&#32;<emphasis role="charliteral">&apos;0&apos;</emphasis>&#32;&amp;&amp;&#32;processingZeroes)
3672 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;zeroes++;
3673 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
3674 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;processingZeroes&#32;=&#32;<emphasis role="keyword">false</emphasis>;
3675 
3676 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(buffer[i]&#32;&lt;&#32;<emphasis role="charliteral">&apos;0&apos;</emphasis>&#32;||&#32;buffer[i]&#32;&gt;&#32;<emphasis role="charliteral">&apos;9&apos;</emphasis>)
3677 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;in.quit(_pe,&#32;(<emphasis role="stringliteral">&quot;Expected&#32;integer,&#32;but&#32;\&quot;&quot;</emphasis>&#32;+&#32;__testlib_part(buffer)&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&#32;found&quot;</emphasis>).c_str());
3678 &#32;&#32;&#32;&#32;}
3679 
3680 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">int</emphasis>&#32;result;
3681 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">try</emphasis>&#32;{
3682 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result&#32;=&#32;std::stoll(buffer);
3683 &#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">catch</emphasis>&#32;(<emphasis role="keyword">const</emphasis>&#32;std::exception&amp;)&#32;{
3684 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;in.quit(_pe,&#32;(<emphasis role="stringliteral">&quot;Expected&#32;integer,&#32;but&#32;\&quot;&quot;</emphasis>&#32;+&#32;__testlib_part(buffer)&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&#32;found&quot;</emphasis>).c_str());
3685 &#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">catch</emphasis>&#32;(...)&#32;{
3686 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;in.quit(_pe,&#32;(<emphasis role="stringliteral">&quot;Expected&#32;integer,&#32;but&#32;\&quot;&quot;</emphasis>&#32;+&#32;__testlib_part(buffer)&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&#32;found&quot;</emphasis>).c_str());
3687 &#32;&#32;&#32;&#32;}
3688 
3689 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;((zeroes&#32;&gt;&#32;0&#32;&amp;&amp;&#32;(result&#32;!=&#32;0&#32;||&#32;has_minus))&#32;||&#32;zeroes&#32;&gt;&#32;1)
3690 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;in.quit(_pe,&#32;(<emphasis role="stringliteral">&quot;Expected&#32;integer,&#32;but&#32;\&quot;&quot;</emphasis>&#32;+&#32;__testlib_part(buffer)&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&#32;found&quot;</emphasis>).c_str());
3691 
3692 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;result;
3693 }
3694 
3695 <emphasis role="keyword">static</emphasis>&#32;<emphasis role="keyword">inline</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;stringToLongLong(<link linkend="_struct_in_stream">InStream</link>&#32;&amp;in,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&amp;&#32;buffer)&#32;{
3696 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">size_t</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;buffer.length();&#32;i++)
3697 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(buffer[i]&#32;==&#32;<emphasis role="charliteral">&apos;\0&apos;</emphasis>)
3698 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;in.quit(_pe,&#32;(<emphasis role="stringliteral">&quot;Expected&#32;integer,&#32;but&#32;\&quot;&quot;</emphasis>&#32;+&#32;__testlib_part(buffer)&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&#32;found&#32;(it&#32;contains&#32;\\0)&quot;</emphasis>).c_str());
3699 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;stringToLongLong(in,&#32;buffer.c_str());
3700 }
3701 
3702 <emphasis role="keyword">static</emphasis>&#32;<emphasis role="keyword">inline</emphasis>&#32;<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;stringToUnsignedLongLong(<link linkend="_struct_in_stream">InStream</link>&#32;&amp;in,&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*buffer)&#32;{
3703 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;length&#32;=&#32;strlen(buffer);
3704 
3705 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(length&#32;==&#32;0&#32;||&#32;length&#32;&gt;&#32;20)
3706 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;in.quit(_pe,&#32;(<emphasis role="stringliteral">&quot;Expected&#32;unsigned&#32;integer,&#32;but&#32;\&quot;&quot;</emphasis>&#32;+&#32;__testlib_part(buffer)&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&#32;found&quot;</emphasis>).c_str());
3707 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(length&#32;&gt;&#32;1&#32;&amp;&amp;&#32;buffer[0]&#32;==&#32;<emphasis role="charliteral">&apos;0&apos;</emphasis>)
3708 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;in.quit(_pe,&#32;(<emphasis role="stringliteral">&quot;Expected&#32;unsigned&#32;integer,&#32;but&#32;\&quot;&quot;</emphasis>&#32;+&#32;__testlib_part(buffer)&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&#32;found&quot;</emphasis>).c_str());
3709 
3710 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">int</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;int(length);&#32;i++)&#32;{
3711 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(buffer[i]&#32;&lt;&#32;<emphasis role="charliteral">&apos;0&apos;</emphasis>&#32;||&#32;buffer[i]&#32;&gt;&#32;<emphasis role="charliteral">&apos;9&apos;</emphasis>)
3712 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;in.quit(_pe,&#32;(<emphasis role="stringliteral">&quot;Expected&#32;unsigned&#32;integer,&#32;but&#32;\&quot;&quot;</emphasis>&#32;+&#32;__testlib_part(buffer)&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&#32;found&quot;</emphasis>).c_str());
3713 &#32;&#32;&#32;&#32;}
3714 
3715 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;result;
3716 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">try</emphasis>&#32;{
3717 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result&#32;=&#32;std::stoull(buffer);
3718 &#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">catch</emphasis>&#32;(<emphasis role="keyword">const</emphasis>&#32;std::exception&amp;)&#32;{
3719 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;in.quit(_pe,&#32;(<emphasis role="stringliteral">&quot;Expected&#32;unsigned&#32;integer,&#32;but&#32;\&quot;&quot;</emphasis>&#32;+&#32;__testlib_part(buffer)&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&#32;found&quot;</emphasis>).c_str());
3720 &#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">catch</emphasis>&#32;(...)&#32;{
3721 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;in.quit(_pe,&#32;(<emphasis role="stringliteral">&quot;Expected&#32;unsigned&#32;integer,&#32;but&#32;\&quot;&quot;</emphasis>&#32;+&#32;__testlib_part(buffer)&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&#32;found&quot;</emphasis>).c_str());
3722 &#32;&#32;&#32;&#32;}
3723 
3724 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;result;
3725 }
3726 
3727 <emphasis role="keyword">static</emphasis>&#32;<emphasis role="keyword">inline</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;stringToUnsignedLongLong(<link linkend="_struct_in_stream">InStream</link>&#32;&amp;in,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&amp;&#32;buffer)&#32;{
3728 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">size_t</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;buffer.length();&#32;i++)
3729 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(buffer[i]&#32;==&#32;<emphasis role="charliteral">&apos;\0&apos;</emphasis>)
3730 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;in.quit(_pe,&#32;(<emphasis role="stringliteral">&quot;Expected&#32;unsigned&#32;integer,&#32;but&#32;\&quot;&quot;</emphasis>&#32;+&#32;__testlib_part(buffer)&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&#32;found&#32;(it&#32;contains&#32;\\0)&quot;</emphasis>).c_str());
3731 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;stringToUnsignedLongLong(in,&#32;buffer.c_str());
3732 }
3733 
3734 <emphasis role="keywordtype">int</emphasis>&#32;InStream::readInteger()&#32;{
3735 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!strict&#32;&amp;&amp;&#32;seekEof())
3736 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_unexpected_eof,&#32;<emphasis role="stringliteral">&quot;Unexpected&#32;end&#32;of&#32;file&#32;-&#32;int32&#32;expected&quot;</emphasis>);
3737 
3738 &#32;&#32;&#32;&#32;readWordTo(_tmpReadToken);
3739 
3740 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;value&#32;=&#32;stringToLongLong(*<emphasis role="keyword">this</emphasis>,&#32;_tmpReadToken);
3741 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(value&#32;&lt;&#32;INT_MIN&#32;||&#32;value&#32;&gt;&#32;INT_MAX)
3742 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_pe,&#32;(<emphasis role="stringliteral">&quot;Expected&#32;int32,&#32;but&#32;\&quot;&quot;</emphasis>&#32;+&#32;__testlib_part(_tmpReadToken)&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&#32;found&quot;</emphasis>).c_str());
3743 
3744 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;int(value);
3745 }
3746 
3747 <emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;InStream::readLong()&#32;{
3748 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!strict&#32;&amp;&amp;&#32;seekEof())
3749 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_unexpected_eof,&#32;<emphasis role="stringliteral">&quot;Unexpected&#32;end&#32;of&#32;file&#32;-&#32;int64&#32;expected&quot;</emphasis>);
3750 
3751 &#32;&#32;&#32;&#32;readWordTo(_tmpReadToken);
3752 
3753 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;stringToLongLong(*<emphasis role="keyword">this</emphasis>,&#32;_tmpReadToken);
3754 }
3755 
3756 <emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;InStream::readUnsignedLong()&#32;{
3757 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!strict&#32;&amp;&amp;&#32;seekEof())
3758 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_unexpected_eof,&#32;<emphasis role="stringliteral">&quot;Unexpected&#32;end&#32;of&#32;file&#32;-&#32;int64&#32;expected&quot;</emphasis>);
3759 
3760 &#32;&#32;&#32;&#32;readWordTo(_tmpReadToken);
3761 
3762 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;stringToUnsignedLongLong(*<emphasis role="keyword">this</emphasis>,&#32;_tmpReadToken);
3763 }
3764 
3765 <emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;InStream::readLong(<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;minv,&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;maxv,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName)&#32;{
3766 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;result&#32;=&#32;readLong();
3767 
3768 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(result&#32;&lt;&#32;minv&#32;||&#32;result&#32;&gt;&#32;maxv)&#32;{
3769 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(readManyIteration&#32;==&#32;NO_INDEX)&#32;{
3770 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(variableName.empty())
3771 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_wa,&#32;(<emphasis role="stringliteral">&quot;Integer&#32;&quot;</emphasis>&#32;+&#32;vtos(result)&#32;+&#32;<emphasis role="stringliteral">&quot;&#32;violates&#32;the&#32;range&#32;[&quot;</emphasis>&#32;+&#32;toHumanReadableString(minv)&#32;+&#32;<emphasis role="stringliteral">&quot;,&#32;&quot;</emphasis>&#32;+&#32;toHumanReadableString(maxv)&#32;+
3772 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;]&quot;</emphasis>).c_str());
3773 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
3774 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_wa,&#32;(<emphasis role="stringliteral">&quot;Integer&#32;parameter&#32;[name=&quot;</emphasis>&#32;+&#32;std::string(variableName)&#32;+&#32;<emphasis role="stringliteral">&quot;]&#32;equals&#32;to&#32;&quot;</emphasis>&#32;+&#32;vtos(result)&#32;+
3775 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;,&#32;violates&#32;the&#32;range&#32;[&quot;</emphasis>&#32;+&#32;toHumanReadableString(minv)&#32;+&#32;<emphasis role="stringliteral">&quot;,&#32;&quot;</emphasis>&#32;+&#32;toHumanReadableString(maxv)&#32;+&#32;<emphasis role="stringliteral">&quot;]&quot;</emphasis>).c_str());
3776 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
3777 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(variableName.empty())
3778 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_wa,&#32;(<emphasis role="stringliteral">&quot;Integer&#32;element&#32;[index=&quot;</emphasis>&#32;+&#32;vtos(readManyIteration)&#32;+&#32;<emphasis role="stringliteral">&quot;]&#32;equals&#32;to&#32;&quot;</emphasis>&#32;+&#32;vtos(result)&#32;+
3779 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;,&#32;violates&#32;the&#32;range&#32;[&quot;</emphasis>&#32;+&#32;toHumanReadableString(minv)&#32;+&#32;<emphasis role="stringliteral">&quot;,&#32;&quot;</emphasis>&#32;+&#32;toHumanReadableString(maxv)&#32;+&#32;<emphasis role="stringliteral">&quot;]&quot;</emphasis>).c_str());
3780 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
3781 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_wa,
3782 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;(<emphasis role="stringliteral">&quot;Integer&#32;element&#32;&quot;</emphasis>&#32;+&#32;std::string(variableName)&#32;+&#32;<emphasis role="stringliteral">&quot;[&quot;</emphasis>&#32;+&#32;vtos(readManyIteration)&#32;+&#32;<emphasis role="stringliteral">&quot;]&#32;equals&#32;to&#32;&quot;</emphasis>&#32;+
3783 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;vtos(result)&#32;+&#32;<emphasis role="stringliteral">&quot;,&#32;violates&#32;the&#32;range&#32;[&quot;</emphasis>&#32;+&#32;toHumanReadableString(minv)&#32;+&#32;<emphasis role="stringliteral">&quot;,&#32;&quot;</emphasis>&#32;+&#32;toHumanReadableString(maxv)&#32;+&#32;<emphasis role="stringliteral">&quot;]&quot;</emphasis>).c_str());
3784 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
3785 &#32;&#32;&#32;&#32;}
3786 
3787 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(strict&#32;&amp;&amp;&#32;!variableName.empty())
3788 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;validator.addBoundsHit(variableName,&#32;<link linkend="_struct_validator_bounds_hit">ValidatorBoundsHit</link>(minv&#32;==&#32;result,&#32;maxv&#32;==&#32;result));
3789 
3790 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;result;
3791 }
3792 
3793 std::vector&lt;long&#32;long&gt;
3794 InStream::readLongs(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;minv,&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;maxv,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variablesName,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase)&#32;{
3795 &#32;&#32;&#32;&#32;__testlib_readMany(readLongs,&#32;readLong(minv,&#32;maxv,&#32;variablesName),&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>,&#32;<emphasis role="keyword">true</emphasis>)
3796 }
3797 
3798 std::vector&lt;long&#32;long&gt;&#32;InStream::readLongs(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase)&#32;{
3799 &#32;&#32;&#32;&#32;__testlib_readMany(readLongs,&#32;readLong(),&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>,&#32;<emphasis role="keyword">true</emphasis>)
3800 }
3801 
3802 <emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>
3803 InStream::readUnsignedLong(<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;minv,&#32;<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;maxv,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName)&#32;{
3804 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;result&#32;=&#32;readUnsignedLong();
3805 
3806 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(result&#32;&lt;&#32;minv&#32;||&#32;result&#32;&gt;&#32;maxv)&#32;{
3807 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(readManyIteration&#32;==&#32;NO_INDEX)&#32;{
3808 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(variableName.empty())
3809 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_wa,
3810 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;(<emphasis role="stringliteral">&quot;Unsigned&#32;integer&#32;&quot;</emphasis>&#32;+&#32;vtos(result)&#32;+&#32;<emphasis role="stringliteral">&quot;&#32;violates&#32;the&#32;range&#32;[&quot;</emphasis>&#32;+&#32;toHumanReadableString(minv)&#32;+&#32;<emphasis role="stringliteral">&quot;,&#32;&quot;</emphasis>&#32;+&#32;toHumanReadableString(maxv)&#32;+
3811 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;]&quot;</emphasis>).c_str());
3812 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
3813 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_wa,
3814 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;(<emphasis role="stringliteral">&quot;Unsigned&#32;integer&#32;parameter&#32;[name=&quot;</emphasis>&#32;+&#32;std::string(variableName)&#32;+&#32;<emphasis role="stringliteral">&quot;]&#32;equals&#32;to&#32;&quot;</emphasis>&#32;+&#32;vtos(result)&#32;+
3815 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;,&#32;violates&#32;the&#32;range&#32;[&quot;</emphasis>&#32;+&#32;toHumanReadableString(minv)&#32;+&#32;<emphasis role="stringliteral">&quot;,&#32;&quot;</emphasis>&#32;+&#32;toHumanReadableString(maxv)&#32;+&#32;<emphasis role="stringliteral">&quot;]&quot;</emphasis>).c_str());
3816 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
3817 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(variableName.empty())
3818 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_wa,
3819 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;(<emphasis role="stringliteral">&quot;Unsigned&#32;integer&#32;element&#32;[index=&quot;</emphasis>&#32;+&#32;vtos(readManyIteration)&#32;+&#32;<emphasis role="stringliteral">&quot;]&#32;equals&#32;to&#32;&quot;</emphasis>&#32;+&#32;vtos(result)&#32;+
3820 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;,&#32;violates&#32;the&#32;range&#32;[&quot;</emphasis>&#32;+&#32;toHumanReadableString(minv)&#32;+&#32;<emphasis role="stringliteral">&quot;,&#32;&quot;</emphasis>&#32;+&#32;toHumanReadableString(maxv)&#32;+&#32;<emphasis role="stringliteral">&quot;]&quot;</emphasis>).c_str());
3821 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
3822 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_wa,&#32;(<emphasis role="stringliteral">&quot;Unsigned&#32;integer&#32;element&#32;&quot;</emphasis>&#32;+&#32;std::string(variableName)&#32;+&#32;<emphasis role="stringliteral">&quot;[&quot;</emphasis>&#32;+&#32;vtos(readManyIteration)&#32;+
3823 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;]&#32;equals&#32;to&#32;&quot;</emphasis>&#32;+&#32;vtos(result)&#32;+&#32;<emphasis role="stringliteral">&quot;,&#32;violates&#32;the&#32;range&#32;[&quot;</emphasis>&#32;+&#32;toHumanReadableString(minv)&#32;+&#32;<emphasis role="stringliteral">&quot;,&#32;&quot;</emphasis>&#32;+&#32;toHumanReadableString(maxv)&#32;+
3824 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;]&quot;</emphasis>).c_str());
3825 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
3826 &#32;&#32;&#32;&#32;}
3827 
3828 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(strict&#32;&amp;&amp;&#32;!variableName.empty())
3829 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;validator.addBoundsHit(variableName,&#32;<link linkend="_struct_validator_bounds_hit">ValidatorBoundsHit</link>(minv&#32;==&#32;result,&#32;maxv&#32;==&#32;result));
3830 
3831 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;result;
3832 }
3833 
3834 std::vector&lt;unsigned&#32;long&#32;long&gt;&#32;InStream::readUnsignedLongs(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;minv,&#32;<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;maxv,
3835 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variablesName,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase)&#32;{
3836 &#32;&#32;&#32;&#32;__testlib_readMany(readUnsignedLongs,&#32;readUnsignedLong(minv,&#32;maxv,&#32;variablesName),&#32;<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>,&#32;<emphasis role="keyword">true</emphasis>)
3837 }
3838 
3839 std::vector&lt;unsigned&#32;long&#32;long&gt;&#32;InStream::readUnsignedLongs(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase)&#32;{
3840 &#32;&#32;&#32;&#32;__testlib_readMany(readUnsignedLongs,&#32;readUnsignedLong(),&#32;<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>,&#32;<emphasis role="keyword">true</emphasis>)
3841 }
3842 
3843 <emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>
3844 InStream::readLong(<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;minv,&#32;<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;maxv,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName)&#32;{
3845 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;readUnsignedLong(minv,&#32;maxv,&#32;variableName);
3846 }
3847 
3848 <emphasis role="keywordtype">int</emphasis>&#32;InStream::readInt()&#32;{
3849 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;readInteger();
3850 }
3851 
3852 <emphasis role="keywordtype">int</emphasis>&#32;InStream::readInt(<emphasis role="keywordtype">int</emphasis>&#32;minv,&#32;<emphasis role="keywordtype">int</emphasis>&#32;maxv,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName)&#32;{
3853 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;result&#32;=&#32;readInt();
3854 
3855 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(result&#32;&lt;&#32;minv&#32;||&#32;result&#32;&gt;&#32;maxv)&#32;{
3856 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(readManyIteration&#32;==&#32;NO_INDEX)&#32;{
3857 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(variableName.empty())
3858 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_wa,&#32;(<emphasis role="stringliteral">&quot;Integer&#32;&quot;</emphasis>&#32;+&#32;vtos(result)&#32;+&#32;<emphasis role="stringliteral">&quot;&#32;violates&#32;the&#32;range&#32;[&quot;</emphasis>&#32;+&#32;toHumanReadableString(minv)&#32;+&#32;<emphasis role="stringliteral">&quot;,&#32;&quot;</emphasis>&#32;+&#32;toHumanReadableString(maxv)&#32;+
3859 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;]&quot;</emphasis>).c_str());
3860 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
3861 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_wa,&#32;(<emphasis role="stringliteral">&quot;Integer&#32;parameter&#32;[name=&quot;</emphasis>&#32;+&#32;std::string(variableName)&#32;+&#32;<emphasis role="stringliteral">&quot;]&#32;equals&#32;to&#32;&quot;</emphasis>&#32;+&#32;vtos(result)&#32;+
3862 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;,&#32;violates&#32;the&#32;range&#32;[&quot;</emphasis>&#32;+&#32;toHumanReadableString(minv)&#32;+&#32;<emphasis role="stringliteral">&quot;,&#32;&quot;</emphasis>&#32;+&#32;toHumanReadableString(maxv)&#32;+&#32;<emphasis role="stringliteral">&quot;]&quot;</emphasis>).c_str());
3863 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
3864 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(variableName.empty())
3865 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_wa,&#32;(<emphasis role="stringliteral">&quot;Integer&#32;element&#32;[index=&quot;</emphasis>&#32;+&#32;vtos(readManyIteration)&#32;+&#32;<emphasis role="stringliteral">&quot;]&#32;equals&#32;to&#32;&quot;</emphasis>&#32;+&#32;vtos(result)&#32;+
3866 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;,&#32;violates&#32;the&#32;range&#32;[&quot;</emphasis>&#32;+&#32;toHumanReadableString(minv)&#32;+&#32;<emphasis role="stringliteral">&quot;,&#32;&quot;</emphasis>&#32;+&#32;toHumanReadableString(maxv)&#32;+&#32;<emphasis role="stringliteral">&quot;]&quot;</emphasis>).c_str());
3867 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
3868 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_wa,
3869 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;(<emphasis role="stringliteral">&quot;Integer&#32;element&#32;&quot;</emphasis>&#32;+&#32;std::string(variableName)&#32;+&#32;<emphasis role="stringliteral">&quot;[&quot;</emphasis>&#32;+&#32;vtos(readManyIteration)&#32;+&#32;<emphasis role="stringliteral">&quot;]&#32;equals&#32;to&#32;&quot;</emphasis>&#32;+
3870 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;vtos(result)&#32;+&#32;<emphasis role="stringliteral">&quot;,&#32;violates&#32;the&#32;range&#32;[&quot;</emphasis>&#32;+&#32;toHumanReadableString(minv)&#32;+&#32;<emphasis role="stringliteral">&quot;,&#32;&quot;</emphasis>&#32;+&#32;toHumanReadableString(maxv)&#32;+&#32;<emphasis role="stringliteral">&quot;]&quot;</emphasis>).c_str());
3871 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
3872 &#32;&#32;&#32;&#32;}
3873 
3874 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(strict&#32;&amp;&amp;&#32;!variableName.empty())
3875 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;validator.addBoundsHit(variableName,&#32;<link linkend="_struct_validator_bounds_hit">ValidatorBoundsHit</link>(minv&#32;==&#32;result,&#32;maxv&#32;==&#32;result));
3876 
3877 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;result;
3878 }
3879 
3880 <emphasis role="keywordtype">int</emphasis>&#32;InStream::readInteger(<emphasis role="keywordtype">int</emphasis>&#32;minv,&#32;<emphasis role="keywordtype">int</emphasis>&#32;maxv,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName)&#32;{
3881 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;readInt(minv,&#32;maxv,&#32;variableName);
3882 }
3883 
3884 std::vector&lt;int&gt;&#32;InStream::readInts(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keywordtype">int</emphasis>&#32;minv,&#32;<emphasis role="keywordtype">int</emphasis>&#32;maxv,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variablesName,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase)&#32;{
3885 &#32;&#32;&#32;&#32;__testlib_readMany(readInts,&#32;readInt(minv,&#32;maxv,&#32;variablesName),&#32;<emphasis role="keywordtype">int</emphasis>,&#32;<emphasis role="keyword">true</emphasis>)
3886 }
3887 
3888 std::vector&lt;int&gt;&#32;InStream::readInts(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase)&#32;{
3889 &#32;&#32;&#32;&#32;__testlib_readMany(readInts,&#32;readInt(),&#32;<emphasis role="keywordtype">int</emphasis>,&#32;<emphasis role="keyword">true</emphasis>)
3890 }
3891 
3892 std::vector&lt;int&gt;&#32;InStream::readIntegers(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keywordtype">int</emphasis>&#32;minv,&#32;<emphasis role="keywordtype">int</emphasis>&#32;maxv,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variablesName,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase)&#32;{
3893 &#32;&#32;&#32;&#32;__testlib_readMany(readIntegers,&#32;readInt(minv,&#32;maxv,&#32;variablesName),&#32;<emphasis role="keywordtype">int</emphasis>,&#32;<emphasis role="keyword">true</emphasis>)
3894 }
3895 
3896 std::vector&lt;int&gt;&#32;InStream::readIntegers(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase)&#32;{
3897 &#32;&#32;&#32;&#32;__testlib_readMany(readIntegers,&#32;readInt(),&#32;<emphasis role="keywordtype">int</emphasis>,&#32;<emphasis role="keyword">true</emphasis>)
3898 }
3899 
3900 <emphasis role="keywordtype">double</emphasis>&#32;InStream::readReal()&#32;{
3901 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!strict&#32;&amp;&amp;&#32;seekEof())
3902 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_unexpected_eof,&#32;<emphasis role="stringliteral">&quot;Unexpected&#32;end&#32;of&#32;file&#32;-&#32;double&#32;expected&quot;</emphasis>);
3903 
3904 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;stringToDouble(*<emphasis role="keyword">this</emphasis>,&#32;readWord());
3905 }
3906 
3907 <emphasis role="keywordtype">double</emphasis>&#32;InStream::readDouble()&#32;{
3908 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;readReal();
3909 }
3910 
3911 <emphasis role="keywordtype">double</emphasis>&#32;InStream::readReal(<emphasis role="keywordtype">double</emphasis>&#32;minv,&#32;<emphasis role="keywordtype">double</emphasis>&#32;maxv,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName)&#32;{
3912 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">double</emphasis>&#32;result&#32;=&#32;readReal();
3913 
3914 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(result&#32;&lt;&#32;minv&#32;||&#32;result&#32;&gt;&#32;maxv)&#32;{
3915 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(readManyIteration&#32;==&#32;NO_INDEX)&#32;{
3916 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(variableName.empty())
3917 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_wa,&#32;(<emphasis role="stringliteral">&quot;Double&#32;&quot;</emphasis>&#32;+&#32;vtos(result)&#32;+&#32;<emphasis role="stringliteral">&quot;&#32;violates&#32;the&#32;range&#32;[&quot;</emphasis>&#32;+&#32;vtos(minv)&#32;+&#32;<emphasis role="stringliteral">&quot;,&#32;&quot;</emphasis>&#32;+&#32;vtos(maxv)&#32;+
3918 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;]&quot;</emphasis>).c_str());
3919 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
3920 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_wa,&#32;(<emphasis role="stringliteral">&quot;Double&#32;parameter&#32;[name=&quot;</emphasis>&#32;+&#32;std::string(variableName)&#32;+&#32;<emphasis role="stringliteral">&quot;]&#32;equals&#32;to&#32;&quot;</emphasis>&#32;+&#32;vtos(result)&#32;+
3921 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;,&#32;violates&#32;the&#32;range&#32;[&quot;</emphasis>&#32;+&#32;vtos(minv)&#32;+&#32;<emphasis role="stringliteral">&quot;,&#32;&quot;</emphasis>&#32;+&#32;vtos(maxv)&#32;+&#32;<emphasis role="stringliteral">&quot;]&quot;</emphasis>).c_str());
3922 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
3923 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(variableName.empty())
3924 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_wa,&#32;(<emphasis role="stringliteral">&quot;Double&#32;element&#32;[index=&quot;</emphasis>&#32;+&#32;vtos(readManyIteration)&#32;+&#32;<emphasis role="stringliteral">&quot;]&#32;equals&#32;to&#32;&quot;</emphasis>&#32;+&#32;vtos(result)&#32;+
3925 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;,&#32;violates&#32;the&#32;range&#32;[&quot;</emphasis>&#32;+&#32;vtos(minv)&#32;+&#32;<emphasis role="stringliteral">&quot;,&#32;&quot;</emphasis>&#32;+&#32;vtos(maxv)&#32;+&#32;<emphasis role="stringliteral">&quot;]&quot;</emphasis>).c_str());
3926 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
3927 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_wa,
3928 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;(<emphasis role="stringliteral">&quot;Double&#32;element&#32;&quot;</emphasis>&#32;+&#32;std::string(variableName)&#32;+&#32;<emphasis role="stringliteral">&quot;[&quot;</emphasis>&#32;+&#32;vtos(readManyIteration)&#32;+&#32;<emphasis role="stringliteral">&quot;]&#32;equals&#32;to&#32;&quot;</emphasis>&#32;+
3929 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;vtos(result)&#32;+&#32;<emphasis role="stringliteral">&quot;,&#32;violates&#32;the&#32;range&#32;[&quot;</emphasis>&#32;+&#32;vtos(minv)&#32;+&#32;<emphasis role="stringliteral">&quot;,&#32;&quot;</emphasis>&#32;+&#32;vtos(maxv)&#32;+&#32;<emphasis role="stringliteral">&quot;]&quot;</emphasis>).c_str());
3930 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
3931 &#32;&#32;&#32;&#32;}
3932 
3933 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(strict&#32;&amp;&amp;&#32;!variableName.empty())
3934 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;validator.addBoundsHit(variableName,&#32;<link linkend="_struct_validator_bounds_hit">ValidatorBoundsHit</link>(
3935 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;doubleDelta(minv,&#32;result)&#32;&lt;&#32;ValidatorBoundsHit::EPS,
3936 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;doubleDelta(maxv,&#32;result)&#32;&lt;&#32;ValidatorBoundsHit::EPS
3937 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;));
3938 
3939 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;result;
3940 }
3941 
3942 std::vector&lt;double&gt;
3943 InStream::readReals(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keywordtype">double</emphasis>&#32;minv,&#32;<emphasis role="keywordtype">double</emphasis>&#32;maxv,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variablesName,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase)&#32;{
3944 &#32;&#32;&#32;&#32;__testlib_readMany(readReals,&#32;readReal(minv,&#32;maxv,&#32;variablesName),&#32;<emphasis role="keywordtype">double</emphasis>,&#32;<emphasis role="keyword">true</emphasis>)
3945 }
3946 
3947 std::vector&lt;double&gt;&#32;InStream::readReals(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase)&#32;{
3948 &#32;&#32;&#32;&#32;__testlib_readMany(readReals,&#32;readReal(),&#32;<emphasis role="keywordtype">double</emphasis>,&#32;<emphasis role="keyword">true</emphasis>)
3949 }
3950 
3951 <emphasis role="keywordtype">double</emphasis>&#32;InStream::readDouble(<emphasis role="keywordtype">double</emphasis>&#32;minv,&#32;<emphasis role="keywordtype">double</emphasis>&#32;maxv,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName)&#32;{
3952 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;readReal(minv,&#32;maxv,&#32;variableName);
3953 }
3954 
3955 std::vector&lt;double&gt;
3956 InStream::readDoubles(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keywordtype">double</emphasis>&#32;minv,&#32;<emphasis role="keywordtype">double</emphasis>&#32;maxv,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variablesName,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase)&#32;{
3957 &#32;&#32;&#32;&#32;__testlib_readMany(readDoubles,&#32;readDouble(minv,&#32;maxv,&#32;variablesName),&#32;<emphasis role="keywordtype">double</emphasis>,&#32;<emphasis role="keyword">true</emphasis>)
3958 }
3959 
3960 std::vector&lt;double&gt;&#32;InStream::readDoubles(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase)&#32;{
3961 &#32;&#32;&#32;&#32;__testlib_readMany(readDoubles,&#32;readDouble(),&#32;<emphasis role="keywordtype">double</emphasis>,&#32;<emphasis role="keyword">true</emphasis>)
3962 }
3963 
3964 <emphasis role="keywordtype">double</emphasis>&#32;InStream::readStrictReal(<emphasis role="keywordtype">double</emphasis>&#32;minv,&#32;<emphasis role="keywordtype">double</emphasis>&#32;maxv,
3965 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;minAfterPointDigitCount,&#32;<emphasis role="keywordtype">int</emphasis>&#32;maxAfterPointDigitCount,
3966 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName)&#32;{
3967 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!strict&#32;&amp;&amp;&#32;seekEof())
3968 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_unexpected_eof,&#32;<emphasis role="stringliteral">&quot;Unexpected&#32;end&#32;of&#32;file&#32;-&#32;strict&#32;double&#32;expected&quot;</emphasis>);
3969 
3970 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">double</emphasis>&#32;result&#32;=&#32;stringToStrictDouble(*<emphasis role="keyword">this</emphasis>,&#32;readWord(),&#32;minAfterPointDigitCount,&#32;maxAfterPointDigitCount);
3971 
3972 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(result&#32;&lt;&#32;minv&#32;||&#32;result&#32;&gt;&#32;maxv)&#32;{
3973 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(readManyIteration&#32;==&#32;NO_INDEX)&#32;{
3974 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(variableName.empty())
3975 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_wa,&#32;(<emphasis role="stringliteral">&quot;Strict&#32;double&#32;&quot;</emphasis>&#32;+&#32;vtos(result)&#32;+&#32;<emphasis role="stringliteral">&quot;&#32;violates&#32;the&#32;range&#32;[&quot;</emphasis>&#32;+&#32;vtos(minv)&#32;+&#32;<emphasis role="stringliteral">&quot;,&#32;&quot;</emphasis>&#32;+&#32;vtos(maxv)&#32;+
3976 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;]&quot;</emphasis>).c_str());
3977 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
3978 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_wa,
3979 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;(<emphasis role="stringliteral">&quot;Strict&#32;double&#32;parameter&#32;[name=&quot;</emphasis>&#32;+&#32;std::string(variableName)&#32;+&#32;<emphasis role="stringliteral">&quot;]&#32;equals&#32;to&#32;&quot;</emphasis>&#32;+&#32;vtos(result)&#32;+
3980 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;,&#32;violates&#32;the&#32;range&#32;[&quot;</emphasis>&#32;+&#32;vtos(minv)&#32;+&#32;<emphasis role="stringliteral">&quot;,&#32;&quot;</emphasis>&#32;+&#32;vtos(maxv)&#32;+&#32;<emphasis role="stringliteral">&quot;]&quot;</emphasis>).c_str());
3981 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
3982 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(variableName.empty())
3983 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_wa,&#32;(<emphasis role="stringliteral">&quot;Strict&#32;double&#32;element&#32;[index=&quot;</emphasis>&#32;+&#32;vtos(readManyIteration)&#32;+&#32;<emphasis role="stringliteral">&quot;]&#32;equals&#32;to&#32;&quot;</emphasis>&#32;+&#32;vtos(result)&#32;+
3984 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;,&#32;violates&#32;the&#32;range&#32;[&quot;</emphasis>&#32;+&#32;vtos(minv)&#32;+&#32;<emphasis role="stringliteral">&quot;,&#32;&quot;</emphasis>&#32;+&#32;vtos(maxv)&#32;+&#32;<emphasis role="stringliteral">&quot;]&quot;</emphasis>).c_str());
3985 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
3986 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_wa,&#32;(<emphasis role="stringliteral">&quot;Strict&#32;double&#32;element&#32;&quot;</emphasis>&#32;+&#32;std::string(variableName)&#32;+&#32;<emphasis role="stringliteral">&quot;[&quot;</emphasis>&#32;+&#32;vtos(readManyIteration)&#32;+
3987 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;]&#32;equals&#32;to&#32;&quot;</emphasis>&#32;+&#32;vtos(result)&#32;+&#32;<emphasis role="stringliteral">&quot;,&#32;violates&#32;the&#32;range&#32;[&quot;</emphasis>&#32;+&#32;vtos(minv)&#32;+&#32;<emphasis role="stringliteral">&quot;,&#32;&quot;</emphasis>&#32;+&#32;vtos(maxv)&#32;+
3988 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;]&quot;</emphasis>).c_str());
3989 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
3990 &#32;&#32;&#32;&#32;}
3991 
3992 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(strict&#32;&amp;&amp;&#32;!variableName.empty())
3993 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;validator.addBoundsHit(variableName,&#32;<link linkend="_struct_validator_bounds_hit">ValidatorBoundsHit</link>(
3994 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;doubleDelta(minv,&#32;result)&#32;&lt;&#32;ValidatorBoundsHit::EPS,
3995 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;doubleDelta(maxv,&#32;result)&#32;&lt;&#32;ValidatorBoundsHit::EPS
3996 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;));
3997 
3998 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;result;
3999 }
4000 
4001 std::vector&lt;double&gt;&#32;InStream::readStrictReals(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keywordtype">double</emphasis>&#32;minv,&#32;<emphasis role="keywordtype">double</emphasis>&#32;maxv,
4002 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;minAfterPointDigitCount,&#32;<emphasis role="keywordtype">int</emphasis>&#32;maxAfterPointDigitCount,
4003 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variablesName,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase)&#32;{
4004 &#32;&#32;&#32;&#32;__testlib_readMany(readStrictReals,
4005 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;readStrictReal(minv,&#32;maxv,&#32;minAfterPointDigitCount,&#32;maxAfterPointDigitCount,&#32;variablesName),
4006 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">double</emphasis>,&#32;<emphasis role="keyword">true</emphasis>)
4007 }
4008 
4009 <emphasis role="keywordtype">double</emphasis>&#32;InStream::readStrictDouble(<emphasis role="keywordtype">double</emphasis>&#32;minv,&#32;<emphasis role="keywordtype">double</emphasis>&#32;maxv,
4010 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;minAfterPointDigitCount,&#32;<emphasis role="keywordtype">int</emphasis>&#32;maxAfterPointDigitCount,
4011 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName)&#32;{
4012 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;readStrictReal(minv,&#32;maxv,
4013 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;minAfterPointDigitCount,&#32;maxAfterPointDigitCount,
4014 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;variableName);
4015 }
4016 
4017 std::vector&lt;double&gt;&#32;InStream::readStrictDoubles(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keywordtype">double</emphasis>&#32;minv,&#32;<emphasis role="keywordtype">double</emphasis>&#32;maxv,
4018 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;minAfterPointDigitCount,&#32;<emphasis role="keywordtype">int</emphasis>&#32;maxAfterPointDigitCount,
4019 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variablesName,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase)&#32;{
4020 &#32;&#32;&#32;&#32;__testlib_readMany(readStrictDoubles,
4021 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;readStrictDouble(minv,&#32;maxv,&#32;minAfterPointDigitCount,&#32;maxAfterPointDigitCount,&#32;variablesName),
4022 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">double</emphasis>,&#32;<emphasis role="keyword">true</emphasis>)
4023 }
4024 
4025 <emphasis role="keywordtype">bool</emphasis>&#32;InStream::eof()&#32;{
4026 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!strict&#32;&amp;&amp;&#32;NULL&#32;==&#32;reader)
4027 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">true</emphasis>;
4028 
4029 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;reader-&gt;eof();
4030 }
4031 
4032 <emphasis role="keywordtype">bool</emphasis>&#32;InStream::seekEof()&#32;{
4033 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!strict&#32;&amp;&amp;&#32;NULL&#32;==&#32;reader)
4034 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">true</emphasis>;
4035 &#32;&#32;&#32;&#32;skipBlanks();
4036 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;eof();
4037 }
4038 
4039 <emphasis role="keywordtype">bool</emphasis>&#32;InStream::eoln()&#32;{
4040 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!strict&#32;&amp;&amp;&#32;NULL&#32;==&#32;reader)
4041 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">true</emphasis>;
4042 
4043 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;c&#32;=&#32;reader-&gt;nextChar();
4044 
4045 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!strict)&#32;{
4046 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(c&#32;==&#32;EOFC)
4047 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">true</emphasis>;
4048 
4049 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(c&#32;==&#32;CR)&#32;{
4050 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;c&#32;=&#32;reader-&gt;nextChar();
4051 
4052 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(c&#32;!=&#32;LF)&#32;{
4053 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;reader-&gt;unreadChar(c);
4054 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;reader-&gt;unreadChar(CR);
4055 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
4056 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>
4057 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">true</emphasis>;
4058 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
4059 
4060 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(c&#32;==&#32;LF)
4061 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">true</emphasis>;
4062 
4063 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;reader-&gt;unreadChar(c);
4064 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
4065 &#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
4066 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;returnCr&#32;=&#32;<emphasis role="keyword">false</emphasis>;
4067 
4068 <emphasis role="preprocessor">#if&#32;(defined(ON_WINDOWS)&#32;&amp;&amp;&#32;!defined(FOR_LINUX))&#32;||&#32;defined(FOR_WINDOWS)</emphasis>
4069 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(c&#32;!=&#32;CR)&#32;{
4070 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;reader-&gt;unreadChar(c);
4071 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
4072 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
4073 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!returnCr)
4074 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;returnCr&#32;=&#32;<emphasis role="keyword">true</emphasis>;
4075 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;c&#32;=&#32;reader-&gt;nextChar();
4076 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
4077 <emphasis role="preprocessor">#endif</emphasis>
4078 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(c&#32;!=&#32;LF)&#32;{
4079 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;reader-&gt;unreadChar(c);
4080 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(returnCr)
4081 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;reader-&gt;unreadChar(CR);
4082 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
4083 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
4084 
4085 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">true</emphasis>;
4086 &#32;&#32;&#32;&#32;}
4087 }
4088 
4089 <emphasis role="keywordtype">void</emphasis>&#32;InStream::readEoln()&#32;{
4090 &#32;&#32;&#32;&#32;lastLine&#32;=&#32;reader-&gt;getLine();
4091 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!eoln())
4092 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_pe,&#32;<emphasis role="stringliteral">&quot;Expected&#32;EOLN&quot;</emphasis>);
4093 }
4094 
4095 <emphasis role="keywordtype">void</emphasis>&#32;InStream::readEof()&#32;{
4096 &#32;&#32;&#32;&#32;lastLine&#32;=&#32;reader-&gt;getLine();
4097 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!eof())
4098 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_pe,&#32;<emphasis role="stringliteral">&quot;Expected&#32;EOF&quot;</emphasis>);
4099 
4100 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(TestlibFinalizeGuard::alive&#32;&amp;&amp;&#32;<emphasis role="keyword">this</emphasis>&#32;==&#32;&amp;inf)
4101 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;testlibFinalizeGuard.readEofCount++;
4102 }
4103 
4104 <emphasis role="keywordtype">bool</emphasis>&#32;InStream::seekEoln()&#32;{
4105 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!strict&#32;&amp;&amp;&#32;NULL&#32;==&#32;reader)
4106 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">true</emphasis>;
4107 
4108 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;cur;
4109 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">do</emphasis>&#32;{
4110 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;cur&#32;=&#32;reader-&gt;nextChar();
4111 &#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">while</emphasis>&#32;(cur&#32;==&#32;SPACE&#32;||&#32;cur&#32;==&#32;TAB);
4112 
4113 &#32;&#32;&#32;&#32;reader-&gt;unreadChar(cur);
4114 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;eoln();
4115 }
4116 
4117 <emphasis role="keywordtype">void</emphasis>&#32;InStream::nextLine()&#32;{
4118 &#32;&#32;&#32;&#32;readLine();
4119 }
4120 
4121 <emphasis role="keywordtype">void</emphasis>&#32;InStream::readStringTo(std::string&#32;&amp;result)&#32;{
4122 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(NULL&#32;==&#32;reader)
4123 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_pe,&#32;<emphasis role="stringliteral">&quot;Expected&#32;line&quot;</emphasis>);
4124 
4125 &#32;&#32;&#32;&#32;result.clear();
4126 
4127 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(;;)&#32;{
4128 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;cur&#32;=&#32;reader-&gt;curChar();
4129 
4130 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(cur&#32;==&#32;LF&#32;||&#32;cur&#32;==&#32;EOFC)
4131 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">break</emphasis>;
4132 
4133 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(cur&#32;==&#32;CR)&#32;{
4134 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;cur&#32;=&#32;reader-&gt;nextChar();
4135 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(reader-&gt;curChar()&#32;==&#32;LF)&#32;{
4136 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;reader-&gt;unreadChar(cur);
4137 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">break</emphasis>;
4138 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
4139 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
4140 
4141 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;lastLine&#32;=&#32;reader-&gt;getLine();
4142 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result&#32;+=&#32;char(reader-&gt;nextChar());
4143 &#32;&#32;&#32;&#32;}
4144 
4145 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(strict)
4146 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;readEoln();
4147 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
4148 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;eoln();
4149 }
4150 
4151 std::string&#32;InStream::readString()&#32;{
4152 &#32;&#32;&#32;&#32;readStringTo(_tmpReadToken);
4153 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;_tmpReadToken;
4154 }
4155 
4156 std::vector&lt;std::string&gt;&#32;InStream::readStrings(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase)&#32;{
4157 &#32;&#32;&#32;&#32;__testlib_readMany(readStrings,&#32;readString(),&#32;std::string,&#32;<emphasis role="keyword">false</emphasis>)
4158 }
4159 
4160 <emphasis role="keywordtype">void</emphasis>&#32;InStream::readStringTo(std::string&#32;&amp;result,&#32;<emphasis role="keyword">const</emphasis>&#32;<link linkend="_classpattern">pattern</link>&#32;&amp;p,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName)&#32;{
4161 &#32;&#32;&#32;&#32;readStringTo(result);
4162 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!p.matches(result))&#32;{
4163 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(readManyIteration&#32;==&#32;NO_INDEX)&#32;{
4164 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(variableName.empty())
4165 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_wa,&#32;(<emphasis role="stringliteral">&quot;Line&#32;\&quot;&quot;</emphasis>&#32;+&#32;__testlib_part(result)&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&#32;doesn&apos;t&#32;correspond&#32;to&#32;pattern&#32;\&quot;&quot;</emphasis>&#32;+&#32;p.src()&#32;+
4166 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;\&quot;&quot;</emphasis>).c_str());
4167 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
4168 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_wa,&#32;(<emphasis role="stringliteral">&quot;Line&#32;[name=&quot;</emphasis>&#32;+&#32;variableName&#32;+&#32;<emphasis role="stringliteral">&quot;]&#32;equals&#32;to&#32;\&quot;&quot;</emphasis>&#32;+&#32;__testlib_part(result)&#32;+
4169 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;\&quot;,&#32;doesn&apos;t&#32;correspond&#32;to&#32;pattern&#32;\&quot;&quot;</emphasis>&#32;+&#32;p.src()&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&quot;</emphasis>).c_str());
4170 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
4171 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(variableName.empty())
4172 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_wa,
4173 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;(<emphasis role="stringliteral">&quot;Line&#32;element&#32;[index=&quot;</emphasis>&#32;+&#32;vtos(readManyIteration)&#32;+&#32;<emphasis role="stringliteral">&quot;]&#32;equals&#32;to&#32;\&quot;&quot;</emphasis>&#32;+&#32;__testlib_part(result)&#32;+
4174 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;\&quot;&#32;doesn&apos;t&#32;correspond&#32;to&#32;pattern&#32;\&quot;&quot;</emphasis>&#32;+&#32;p.src()&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&quot;</emphasis>).c_str());
4175 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
4176 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_wa,
4177 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;(<emphasis role="stringliteral">&quot;Line&#32;element&#32;&quot;</emphasis>&#32;+&#32;std::string(variableName)&#32;+&#32;<emphasis role="stringliteral">&quot;[&quot;</emphasis>&#32;+&#32;vtos(readManyIteration)&#32;+&#32;<emphasis role="stringliteral">&quot;]&#32;equals&#32;to&#32;\&quot;&quot;</emphasis>&#32;+
4178 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_part(result)&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;,&#32;doesn&apos;t&#32;correspond&#32;to&#32;pattern&#32;\&quot;&quot;</emphasis>&#32;+&#32;p.src()&#32;+&#32;<emphasis role="stringliteral">&quot;\&quot;&quot;</emphasis>).c_str());
4179 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
4180 &#32;&#32;&#32;&#32;}
4181 }
4182 
4183 <emphasis role="keywordtype">void</emphasis>&#32;InStream::readStringTo(std::string&#32;&amp;result,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;ptrn,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName)&#32;{
4184 &#32;&#32;&#32;&#32;readStringTo(result,&#32;<link linkend="_classpattern">pattern</link>(ptrn),&#32;variableName);
4185 }
4186 
4187 std::string&#32;InStream::readString(<emphasis role="keyword">const</emphasis>&#32;<link linkend="_classpattern">pattern</link>&#32;&amp;p,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName)&#32;{
4188 &#32;&#32;&#32;&#32;readStringTo(_tmpReadToken,&#32;p,&#32;variableName);
4189 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;_tmpReadToken;
4190 }
4191 
4192 std::vector&lt;std::string&gt;
4193 InStream::readStrings(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keyword">const</emphasis>&#32;<link linkend="_classpattern">pattern</link>&#32;&amp;p,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variablesName,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase)&#32;{
4194 &#32;&#32;&#32;&#32;__testlib_readMany(readStrings,&#32;readString(p,&#32;variablesName),&#32;std::string,&#32;<emphasis role="keyword">false</emphasis>)
4195 }
4196 
4197 std::string&#32;InStream::readString(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;ptrn,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName)&#32;{
4198 &#32;&#32;&#32;&#32;readStringTo(_tmpReadToken,&#32;ptrn,&#32;variableName);
4199 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;_tmpReadToken;
4200 }
4201 
4202 std::vector&lt;std::string&gt;
4203 InStream::readStrings(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;ptrn,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variablesName,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase)&#32;{
4204 &#32;&#32;&#32;&#32;<link linkend="_classpattern">pattern</link>&#32;p(ptrn);
4205 &#32;&#32;&#32;&#32;__testlib_readMany(readStrings,&#32;readString(p,&#32;variablesName),&#32;std::string,&#32;<emphasis role="keyword">false</emphasis>)
4206 }
4207 
4208 <emphasis role="keywordtype">void</emphasis>&#32;InStream::readLineTo(std::string&#32;&amp;result)&#32;{
4209 &#32;&#32;&#32;&#32;readStringTo(result);
4210 }
4211 
4212 std::string&#32;InStream::readLine()&#32;{
4213 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;readString();
4214 }
4215 
4216 std::vector&lt;std::string&gt;&#32;InStream::readLines(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase)&#32;{
4217 &#32;&#32;&#32;&#32;__testlib_readMany(readLines,&#32;readString(),&#32;std::string,&#32;<emphasis role="keyword">false</emphasis>)
4218 }
4219 
4220 <emphasis role="keywordtype">void</emphasis>&#32;InStream::readLineTo(std::string&#32;&amp;result,&#32;<emphasis role="keyword">const</emphasis>&#32;<link linkend="_classpattern">pattern</link>&#32;&amp;p,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName)&#32;{
4221 &#32;&#32;&#32;&#32;readStringTo(result,&#32;p,&#32;variableName);
4222 }
4223 
4224 <emphasis role="keywordtype">void</emphasis>&#32;InStream::readLineTo(std::string&#32;&amp;result,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;ptrn,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName)&#32;{
4225 &#32;&#32;&#32;&#32;readStringTo(result,&#32;ptrn,&#32;variableName);
4226 }
4227 
4228 std::string&#32;InStream::readLine(<emphasis role="keyword">const</emphasis>&#32;<link linkend="_classpattern">pattern</link>&#32;&amp;p,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName)&#32;{
4229 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;readString(p,&#32;variableName);
4230 }
4231 
4232 std::vector&lt;std::string&gt;
4233 InStream::readLines(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keyword">const</emphasis>&#32;<link linkend="_classpattern">pattern</link>&#32;&amp;p,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variablesName,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase)&#32;{
4234 &#32;&#32;&#32;&#32;__testlib_readMany(readLines,&#32;readString(p,&#32;variablesName),&#32;std::string,&#32;<emphasis role="keyword">false</emphasis>)
4235 }
4236 
4237 std::string&#32;InStream::readLine(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;ptrn,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variableName)&#32;{
4238 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;readString(ptrn,&#32;variableName);
4239 }
4240 
4241 std::vector&lt;std::string&gt;
4242 InStream::readLines(<emphasis role="keywordtype">int</emphasis>&#32;size,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;ptrn,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;variablesName,&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexBase)&#32;{
4243 &#32;&#32;&#32;&#32;<link linkend="_classpattern">pattern</link>&#32;p(ptrn);
4244 &#32;&#32;&#32;&#32;__testlib_readMany(readLines,&#32;readString(p,&#32;variablesName),&#32;std::string,&#32;<emphasis role="keyword">false</emphasis>)
4245 }
4246 
4247 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
4248 __attribute__&#32;((format&#32;(printf,&#32;3,&#32;4)))
4249 <emphasis role="preprocessor">#endif</emphasis>
4250 <emphasis role="keywordtype">void</emphasis>&#32;InStream::ensuref(<emphasis role="keywordtype">bool</emphasis>&#32;cond,&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*format,&#32;...)&#32;{
4251 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!cond)&#32;{
4252 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;FMT_TO_RESULT(format,&#32;format,&#32;message);
4253 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;this-&gt;__testlib_ensure(cond,&#32;message);
4254 &#32;&#32;&#32;&#32;}
4255 }
4256 
4257 <emphasis role="keywordtype">void</emphasis>&#32;InStream::__testlib_ensure(<emphasis role="keywordtype">bool</emphasis>&#32;cond,&#32;std::string&#32;message)&#32;{
4258 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!cond)
4259 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;this-&gt;quit(_wa,&#32;message.c_str());
4260 }
4261 
4262 <emphasis role="keywordtype">void</emphasis>&#32;InStream::close()&#32;{
4263 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(NULL&#32;!=&#32;reader)&#32;{
4264 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;reader-&gt;close();
4265 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">delete</emphasis>&#32;reader;
4266 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;reader&#32;=&#32;NULL;
4267 &#32;&#32;&#32;&#32;}
4268 
4269 &#32;&#32;&#32;&#32;opened&#32;=&#32;<emphasis role="keyword">false</emphasis>;
4270 }
4271 
4272 NORETURN&#32;<emphasis role="keywordtype">void</emphasis>&#32;quit(TResult&#32;result,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;msg)&#32;{
4273 &#32;&#32;&#32;&#32;ouf.quit(result,&#32;msg.c_str());
4274 }
4275 
4276 NORETURN&#32;<emphasis role="keywordtype">void</emphasis>&#32;quit(TResult&#32;result,&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*msg)&#32;{
4277 &#32;&#32;&#32;&#32;ouf.quit(result,&#32;msg);
4278 }
4279 
4280 NORETURN&#32;<emphasis role="keywordtype">void</emphasis>&#32;__testlib_quitp(<emphasis role="keywordtype">double</emphasis>&#32;points,&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*message)&#32;{
4281 &#32;&#32;&#32;&#32;__testlib_points&#32;=&#32;points;
4282 &#32;&#32;&#32;&#32;std::string&#32;stringPoints&#32;=&#32;removeDoubleTrailingZeroes(format(<emphasis role="stringliteral">&quot;%.10f&quot;</emphasis>,&#32;points));
4283 
4284 &#32;&#32;&#32;&#32;std::string&#32;quitMessage;
4285 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(NULL&#32;==&#32;message&#32;||&#32;0&#32;==&#32;strlen(message))
4286 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quitMessage&#32;=&#32;stringPoints;
4287 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
4288 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quitMessage&#32;=&#32;stringPoints&#32;+&#32;<emphasis role="stringliteral">&quot;&#32;&quot;</emphasis>&#32;+&#32;message;
4289 
4290 &#32;&#32;&#32;&#32;quit(_points,&#32;quitMessage.c_str());
4291 }
4292 
4293 NORETURN&#32;<emphasis role="keywordtype">void</emphasis>&#32;__testlib_quitp(<emphasis role="keywordtype">int</emphasis>&#32;points,&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*message)&#32;{
4294 &#32;&#32;&#32;&#32;__testlib_points&#32;=&#32;points;
4295 &#32;&#32;&#32;&#32;std::string&#32;stringPoints&#32;=&#32;format(<emphasis role="stringliteral">&quot;%d&quot;</emphasis>,&#32;points);
4296 
4297 &#32;&#32;&#32;&#32;std::string&#32;quitMessage;
4298 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(NULL&#32;==&#32;message&#32;||&#32;0&#32;==&#32;strlen(message))
4299 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quitMessage&#32;=&#32;stringPoints;
4300 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
4301 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quitMessage&#32;=&#32;stringPoints&#32;+&#32;<emphasis role="stringliteral">&quot;&#32;&quot;</emphasis>&#32;+&#32;message;
4302 
4303 &#32;&#32;&#32;&#32;quit(_points,&#32;quitMessage.c_str());
4304 }
4305 
4306 NORETURN&#32;<emphasis role="keywordtype">void</emphasis>&#32;quitp(<emphasis role="keywordtype">float</emphasis>&#32;points,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;message&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>)&#32;{
4307 &#32;&#32;&#32;&#32;__testlib_quitp(<emphasis role="keywordtype">double</emphasis>(points),&#32;message.c_str());
4308 }
4309 
4310 NORETURN&#32;<emphasis role="keywordtype">void</emphasis>&#32;quitp(<emphasis role="keywordtype">double</emphasis>&#32;points,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;message&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>)&#32;{
4311 &#32;&#32;&#32;&#32;__testlib_quitp(points,&#32;message.c_str());
4312 }
4313 
4314 NORETURN&#32;<emphasis role="keywordtype">void</emphasis>&#32;quitp(<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">double</emphasis>&#32;points,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;message&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>)&#32;{
4315 &#32;&#32;&#32;&#32;__testlib_quitp(<emphasis role="keywordtype">double</emphasis>(points),&#32;message.c_str());
4316 }
4317 
4318 NORETURN&#32;<emphasis role="keywordtype">void</emphasis>&#32;quitp(<emphasis role="keywordtype">int</emphasis>&#32;points,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;message&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>)&#32;{
4319 &#32;&#32;&#32;&#32;__testlib_quitp(points,&#32;message.c_str());
4320 }
4321 
4322 NORETURN&#32;<emphasis role="keywordtype">void</emphasis>&#32;quitpi(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;points_info,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;message&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>)&#32;{
4323 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(points_info.find(<emphasis role="charliteral">&apos;&#32;&apos;</emphasis>)&#32;!=&#32;std::string::npos)
4324 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_fail,&#32;<emphasis role="stringliteral">&quot;Parameter&#32;&apos;points_info&apos;&#32;can&apos;t&#32;contain&#32;spaces&quot;</emphasis>);
4325 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(message.empty())
4326 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_points,&#32;(<emphasis role="stringliteral">&quot;points_info=&quot;</emphasis>&#32;+&#32;points_info).c_str());
4327 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
4328 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_points,&#32;(<emphasis role="stringliteral">&quot;points_info=&quot;</emphasis>&#32;+&#32;points_info&#32;+&#32;<emphasis role="stringliteral">&quot;&#32;&quot;</emphasis>&#32;+&#32;message).c_str());
4329 }
4330 
4331 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;F&gt;
4332 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
4333 __attribute__&#32;((format&#32;(printf,&#32;2,&#32;3)))
4334 <emphasis role="preprocessor">#endif</emphasis>
4335 NORETURN&#32;<emphasis role="keywordtype">void</emphasis>&#32;quitp(F&#32;points,&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*format,&#32;...)&#32;{
4336 &#32;&#32;&#32;&#32;FMT_TO_RESULT(format,&#32;format,&#32;message);
4337 &#32;&#32;&#32;&#32;quitp(points,&#32;message);
4338 }
4339 
4340 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
4341 __attribute__&#32;((format&#32;(printf,&#32;2,&#32;3)))
4342 <emphasis role="preprocessor">#endif</emphasis>
4343 NORETURN&#32;<emphasis role="keywordtype">void</emphasis>&#32;quitf(TResult&#32;result,&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*format,&#32;...)&#32;{
4344 &#32;&#32;&#32;&#32;FMT_TO_RESULT(format,&#32;format,&#32;message);
4345 &#32;&#32;&#32;&#32;quit(result,&#32;message);
4346 }
4347 
4348 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
4349 __attribute__&#32;((format&#32;(printf,&#32;3,&#32;4)))
4350 <emphasis role="preprocessor">#endif</emphasis>
4351 <emphasis role="keywordtype">void</emphasis>&#32;quitif(<emphasis role="keywordtype">bool</emphasis>&#32;condition,&#32;TResult&#32;result,&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*format,&#32;...)&#32;{
4352 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(condition)&#32;{
4353 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;FMT_TO_RESULT(format,&#32;format,&#32;message);
4354 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(result,&#32;message);
4355 &#32;&#32;&#32;&#32;}
4356 }
4357 
4358 NORETURN&#32;<emphasis role="keywordtype">void</emphasis>&#32;__testlib_help()&#32;{
4359 &#32;&#32;&#32;&#32;InStream::textColor(InStream::LightCyan);
4360 &#32;&#32;&#32;&#32;std::fprintf(stderr,&#32;<emphasis role="stringliteral">&quot;TESTLIB&#32;%s,&#32;https://github.com/MikeMirzayanov/testlib/&#32;&quot;</emphasis>,&#32;VERSION);
4361 &#32;&#32;&#32;&#32;std::fprintf(stderr,&#32;<emphasis role="stringliteral">&quot;by&#32;Mike&#32;Mirzayanov,&#32;copyright(c)&#32;2005-2020\n&quot;</emphasis>);
4362 &#32;&#32;&#32;&#32;std::fprintf(stderr,&#32;<emphasis role="stringliteral">&quot;Checker&#32;name:&#32;\&quot;%s\&quot;\n&quot;</emphasis>,&#32;checkerName.c_str());
4363 &#32;&#32;&#32;&#32;InStream::textColor(InStream::LightGray);
4364 
4365 &#32;&#32;&#32;&#32;std::fprintf(stderr,&#32;<emphasis role="stringliteral">&quot;\n&quot;</emphasis>);
4366 &#32;&#32;&#32;&#32;std::fprintf(stderr,&#32;<emphasis role="stringliteral">&quot;Latest&#32;features:&#32;\n&quot;</emphasis>);
4367 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">size_t</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;<emphasis role="keyword">sizeof</emphasis>(latestFeatures)&#32;/&#32;<emphasis role="keyword">sizeof</emphasis>(<emphasis role="keywordtype">char</emphasis>&#32;*);&#32;i++)&#32;{
4368 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::fprintf(stderr,&#32;<emphasis role="stringliteral">&quot;*)&#32;%s\n&quot;</emphasis>,&#32;latestFeatures[i]);
4369 &#32;&#32;&#32;&#32;}
4370 &#32;&#32;&#32;&#32;std::fprintf(stderr,&#32;<emphasis role="stringliteral">&quot;\n&quot;</emphasis>);
4371 
4372 &#32;&#32;&#32;&#32;std::fprintf(stderr,&#32;<emphasis role="stringliteral">&quot;Program&#32;must&#32;be&#32;run&#32;with&#32;the&#32;following&#32;arguments:&#32;\n&quot;</emphasis>);
4373 &#32;&#32;&#32;&#32;std::fprintf(stderr,&#32;<emphasis role="stringliteral">&quot;&#32;&#32;&#32;&#32;[--testset&#32;testset]&#32;[--group&#32;group]&#32;&lt;input-file&gt;&#32;&lt;output-file&gt;&#32;&lt;answer-file&gt;&#32;[&lt;report-file&gt;&#32;[&lt;-appes&gt;]]\n\n&quot;</emphasis>);
4374 
4375 &#32;&#32;&#32;&#32;__testlib_exitCode&#32;=&#32;FAIL_EXIT_CODE;
4376 &#32;&#32;&#32;&#32;std::exit(FAIL_EXIT_CODE);
4377 }
4378 
4379 <emphasis role="keyword">static</emphasis>&#32;<emphasis role="keywordtype">void</emphasis>&#32;__testlib_ensuresPreconditions()&#32;{
4380 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;testlib&#32;assumes:&#32;sizeof(int)&#32;=&#32;4.</emphasis>
4381 &#32;&#32;&#32;&#32;__TESTLIB_STATIC_ASSERT(<emphasis role="keyword">sizeof</emphasis>(<emphasis role="keywordtype">int</emphasis>)&#32;==&#32;4);
4382 
4383 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;testlib&#32;assumes:&#32;INT_MAX&#32;==&#32;2147483647.</emphasis>
4384 &#32;&#32;&#32;&#32;__TESTLIB_STATIC_ASSERT(INT_MAX&#32;==&#32;2147483647);
4385 
4386 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;testlib&#32;assumes:&#32;sizeof(long&#32;long)&#32;=&#32;8.</emphasis>
4387 &#32;&#32;&#32;&#32;__TESTLIB_STATIC_ASSERT(<emphasis role="keyword">sizeof</emphasis>(<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>)&#32;==&#32;8);
4388 
4389 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;testlib&#32;assumes:&#32;sizeof(double)&#32;=&#32;8.</emphasis>
4390 &#32;&#32;&#32;&#32;__TESTLIB_STATIC_ASSERT(<emphasis role="keyword">sizeof</emphasis>(<emphasis role="keywordtype">double</emphasis>)&#32;==&#32;8);
4391 
4392 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;testlib&#32;assumes:&#32;no&#32;-ffast-math.</emphasis>
4393 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!__testlib_isNaN(+__testlib_nan()))
4394 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_fail,&#32;<emphasis role="stringliteral">&quot;Function&#32;__testlib_isNaN&#32;is&#32;not&#32;working&#32;correctly:&#32;possible&#32;reason&#32;is&#32;&apos;-ffast-math&apos;&quot;</emphasis>);
4395 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!__testlib_isNaN(-__testlib_nan()))
4396 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_fail,&#32;<emphasis role="stringliteral">&quot;Function&#32;__testlib_isNaN&#32;is&#32;not&#32;working&#32;correctly:&#32;possible&#32;reason&#32;is&#32;&apos;-ffast-math&apos;&quot;</emphasis>);
4397 }
4398 
4399 std::string&#32;__testlib_testset;
4400 
4401 std::string&#32;getTestset()&#32;{
4402 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__testlib_testset;
4403 }
4404 
4405 std::string&#32;__testlib_group;
4406 
4407 std::string&#32;getGroup()&#32;{
4408 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__testlib_group;
4409 }
4410 
4411 <emphasis role="keyword">static</emphasis>&#32;<emphasis role="keywordtype">void</emphasis>&#32;__testlib_set_testset_and_group(<emphasis role="keywordtype">int</emphasis>&#32;argc,&#32;<emphasis role="keywordtype">char</emphasis>*&#32;argv[])&#32;{
4412 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">int</emphasis>&#32;i&#32;=&#32;1;&#32;i&#32;&lt;&#32;argc;&#32;i++)&#32;{
4413 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!strcmp(<emphasis role="stringliteral">&quot;--testset&quot;</emphasis>,&#32;argv[i]))&#32;{
4414 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(i&#32;+&#32;1&#32;&lt;&#32;argc&#32;&amp;&amp;&#32;strlen(argv[i&#32;+&#32;1])&#32;&gt;&#32;0)
4415 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_testset&#32;=&#32;argv[++i];
4416 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
4417 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_fail,&#32;std::string(<emphasis role="stringliteral">&quot;Expected&#32;non-empty&#32;testset&#32;after&#32;--testset&#32;command&#32;line&#32;parameter&quot;</emphasis>));
4418 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!strcmp(<emphasis role="stringliteral">&quot;--group&quot;</emphasis>,&#32;argv[i]))&#32;{
4419 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(i&#32;+&#32;1&#32;&lt;&#32;argc)
4420 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_group&#32;=&#32;argv[++i];
4421 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
4422 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_fail,&#32;std::string(<emphasis role="stringliteral">&quot;Expected&#32;group&#32;after&#32;--group&#32;command&#32;line&#32;parameter&quot;</emphasis>));
4423 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
4424 &#32;&#32;&#32;&#32;}
4425 }
4426 
4427 <emphasis role="keywordtype">void</emphasis>&#32;registerGen(<emphasis role="keywordtype">int</emphasis>&#32;argc,&#32;<emphasis role="keywordtype">char</emphasis>&#32;*argv[],&#32;<emphasis role="keywordtype">int</emphasis>&#32;randomGeneratorVersion)&#32;{
4428 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(randomGeneratorVersion&#32;&lt;&#32;0&#32;||&#32;randomGeneratorVersion&#32;&gt;&#32;1)
4429 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quitf(_fail,&#32;<emphasis role="stringliteral">&quot;Random&#32;generator&#32;version&#32;is&#32;expected&#32;to&#32;be&#32;0&#32;or&#32;1.&quot;</emphasis>);
4430 &#32;&#32;&#32;&#32;random_t::version&#32;=&#32;randomGeneratorVersion;
4431 
4432 &#32;&#32;&#32;&#32;__testlib_ensuresPreconditions();
4433 &#32;&#32;&#32;&#32;TestlibFinalizeGuard::registered&#32;=&#32;<emphasis role="keyword">true</emphasis>;
4434 
4435 &#32;&#32;&#32;&#32;testlibMode&#32;=&#32;_generator;
4436 &#32;&#32;&#32;&#32;__testlib_set_binary(stdin);
4437 &#32;&#32;&#32;&#32;rnd.setSeed(argc,&#32;argv);
4438 
4439 <emphasis role="preprocessor">#if&#32;__cplusplus&#32;&gt;&#32;199711L&#32;||&#32;defined(_MSC_VER)</emphasis>
4440 &#32;&#32;&#32;&#32;prepareOpts(argc,&#32;argv);
4441 <emphasis role="preprocessor">#endif</emphasis>
4442 }
4443 
4444 <emphasis role="preprocessor">#ifdef&#32;USE_RND_AS_BEFORE_087</emphasis>
4445 <emphasis role="keywordtype">void</emphasis>&#32;registerGen(<emphasis role="keywordtype">int</emphasis>&#32;argc,&#32;<emphasis role="keywordtype">char</emphasis>*&#32;argv[])
4446 {
4447 &#32;&#32;&#32;&#32;registerGen(argc,&#32;argv,&#32;0);
4448 }
4449 <emphasis role="preprocessor">#else</emphasis>
4450 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
4451 <emphasis role="preprocessor">#if&#32;(__GNUC__&#32;&gt;&#32;4)&#32;||&#32;((__GNUC__&#32;==&#32;4)&#32;&amp;&amp;&#32;(__GNUC_MINOR__&#32;&gt;&#32;4))</emphasis>
4452 __attribute__&#32;((deprecated(<emphasis role="stringliteral">&quot;Use&#32;registerGen(argc,&#32;argv,&#32;0)&#32;or&#32;registerGen(argc,&#32;argv,&#32;1).&quot;</emphasis>
4453 <emphasis role="stringliteral">&quot;&#32;The&#32;third&#32;parameter&#32;stands&#32;for&#32;the&#32;random&#32;generator&#32;version.&quot;</emphasis>
4454 <emphasis role="stringliteral">&quot;&#32;If&#32;you&#32;are&#32;trying&#32;to&#32;compile&#32;old&#32;generator&#32;use&#32;macro&#32;-DUSE_RND_AS_BEFORE_087&#32;or&#32;registerGen(argc,&#32;argv,&#32;0).&quot;</emphasis>
4455 <emphasis role="stringliteral">&quot;&#32;Version&#32;1&#32;has&#32;been&#32;released&#32;on&#32;Spring,&#32;2013.&#32;Use&#32;it&#32;to&#32;write&#32;new&#32;generators.&quot;</emphasis>)))
4456 <emphasis role="preprocessor">#else</emphasis>
4457 __attribute__&#32;((deprecated))
4458 <emphasis role="preprocessor">#endif</emphasis>
4459 <emphasis role="preprocessor">#endif</emphasis>
4460 <emphasis role="preprocessor">#ifdef&#32;_MSC_VER</emphasis>
4461 __declspec(deprecated(<emphasis role="stringliteral">&quot;Use&#32;registerGen(argc,&#32;argv,&#32;0)&#32;or&#32;registerGen(argc,&#32;argv,&#32;1).&quot;</emphasis>
4462 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;&#32;The&#32;third&#32;parameter&#32;stands&#32;for&#32;the&#32;random&#32;generator&#32;version.&quot;</emphasis>
4463 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;&#32;If&#32;you&#32;are&#32;trying&#32;to&#32;compile&#32;old&#32;generator&#32;use&#32;macro&#32;-DUSE_RND_AS_BEFORE_087&#32;or&#32;registerGen(argc,&#32;argv,&#32;0).&quot;</emphasis>
4464 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;&#32;Version&#32;1&#32;has&#32;been&#32;released&#32;on&#32;Spring,&#32;2013.&#32;Use&#32;it&#32;to&#32;write&#32;new&#32;generators.&quot;</emphasis>))
4465 <emphasis role="preprocessor">#endif</emphasis>
4466 <emphasis role="keywordtype">void</emphasis>&#32;registerGen(<emphasis role="keywordtype">int</emphasis>&#32;argc,&#32;<emphasis role="keywordtype">char</emphasis>&#32;*argv[])&#32;{
4467 &#32;&#32;&#32;&#32;std::fprintf(stderr,&#32;<emphasis role="stringliteral">&quot;Use&#32;registerGen(argc,&#32;argv,&#32;0)&#32;or&#32;registerGen(argc,&#32;argv,&#32;1).&quot;</emphasis>
4468 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;&#32;The&#32;third&#32;parameter&#32;stands&#32;for&#32;the&#32;random&#32;generator&#32;version.&quot;</emphasis>
4469 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;&#32;If&#32;you&#32;are&#32;trying&#32;to&#32;compile&#32;old&#32;generator&#32;use&#32;macro&#32;-DUSE_RND_AS_BEFORE_087&#32;or&#32;registerGen(argc,&#32;argv,&#32;0).&quot;</emphasis>
4470 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;&#32;Version&#32;1&#32;has&#32;been&#32;released&#32;on&#32;Spring,&#32;2013.&#32;Use&#32;it&#32;to&#32;write&#32;new&#32;generators.\n\n&quot;</emphasis>);
4471 &#32;&#32;&#32;&#32;registerGen(argc,&#32;argv,&#32;0);
4472 }
4473 <emphasis role="preprocessor">#endif</emphasis>
4474 
4475 <emphasis role="keywordtype">void</emphasis>&#32;setAppesModeEncoding(std::string&#32;appesModeEncoding)&#32;{
4476 &#32;&#32;&#32;&#32;<emphasis role="keyword">static</emphasis>&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>*&#32;<emphasis role="keyword">const</emphasis>&#32;ENCODINGS[]&#32;=&#32;{<emphasis role="stringliteral">&quot;ascii&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;utf-7&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;utf-8&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;utf-16&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;utf-16le&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;utf-16be&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;utf-32&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;utf-32le&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;utf-32be&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;iso-8859-1&quot;</emphasis>,&#32;
4477 <emphasis role="stringliteral">&quot;iso-8859-2&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;iso-8859-3&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;iso-8859-4&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;iso-8859-5&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;iso-8859-6&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;iso-8859-7&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;iso-8859-8&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;iso-8859-9&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;iso-8859-10&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;iso-8859-11&quot;</emphasis>,&#32;
4478 <emphasis role="stringliteral">&quot;iso-8859-13&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;iso-8859-14&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;iso-8859-15&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;iso-8859-16&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;windows-1250&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;windows-1251&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;windows-1252&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;windows-1253&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;windows-1254&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;windows-1255&quot;</emphasis>,&#32;
4479 <emphasis role="stringliteral">&quot;windows-1256&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;windows-1257&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;windows-1258&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;gb2312&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;gbk&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;gb18030&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;big5&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;shift-jis&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;euc-jp&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;euc-kr&quot;</emphasis>,&#32;
4480 <emphasis role="stringliteral">&quot;euc-cn&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;euc-tw&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;koi8-r&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;koi8-u&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;tis-620&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;ibm437&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;ibm850&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;ibm852&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;ibm855&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;ibm857&quot;</emphasis>,&#32;
4481 <emphasis role="stringliteral">&quot;ibm860&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;ibm861&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;ibm862&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;ibm863&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;ibm865&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;ibm866&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;ibm869&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;macroman&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;maccentraleurope&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;maciceland&quot;</emphasis>,&#32;
4482 <emphasis role="stringliteral">&quot;maccroatian&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;macromania&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;maccyrillic&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;macukraine&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;macgreek&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;macturkish&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;machebrew&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;macarabic&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;macthai&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;hz-gb-2312&quot;</emphasis>,&#32;
4483 <emphasis role="stringliteral">&quot;iso-2022-jp&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;iso-2022-kr&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;iso-2022-cn&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;armscii-8&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;tscii&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;iscii&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;viscii&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;geostd8&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;cp949&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;cp874&quot;</emphasis>,&#32;
4484 <emphasis role="stringliteral">&quot;cp1006&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;cp775&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;cp858&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;cp737&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;cp853&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;cp856&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;cp922&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;cp1046&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;cp1125&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;cp1131&quot;</emphasis>,&#32;
4485 <emphasis role="stringliteral">&quot;ptcp154&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;koi8-t&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;koi8-ru&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;mulelao-1&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;cp1133&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;iso-ir-166&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;tcvn&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;iso-ir-14&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;iso-ir-87&quot;</emphasis>,&#32;<emphasis role="stringliteral">&quot;iso-ir-159&quot;</emphasis>};
4486 &#32;&#32;&#32;&#32;
4487 &#32;&#32;&#32;&#32;appesModeEncoding&#32;=&#32;lowerCase(appesModeEncoding);
4488 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;valid&#32;=&#32;<emphasis role="keyword">false</emphasis>;
4489 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">size_t</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;<emphasis role="keyword">sizeof</emphasis>(ENCODINGS)&#32;/&#32;<emphasis role="keyword">sizeof</emphasis>(ENCODINGS[0]);&#32;i++)
4490 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(appesModeEncoding&#32;==&#32;ENCODINGS[i])&#32;{
4491 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;valid&#32;=&#32;<emphasis role="keyword">true</emphasis>;
4492 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">break</emphasis>;
4493 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
4494 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!valid)
4495 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_fail,&#32;<emphasis role="stringliteral">&quot;Unexpected&#32;encoding&#32;for&#32;setAppesModeEncoding(encoding)&quot;</emphasis>);
4496 &#32;&#32;&#32;&#32;::appesModeEncoding&#32;=&#32;appesModeEncoding;
4497 }
4498 
4499 <emphasis role="keywordtype">void</emphasis>&#32;registerInteraction(<emphasis role="keywordtype">int</emphasis>&#32;argc,&#32;<emphasis role="keywordtype">char</emphasis>&#32;*argv[])&#32;{
4500 &#32;&#32;&#32;&#32;__testlib_ensuresPreconditions();
4501 &#32;&#32;&#32;&#32;__testlib_set_testset_and_group(argc,&#32;argv);
4502 &#32;&#32;&#32;&#32;TestlibFinalizeGuard::registered&#32;=&#32;<emphasis role="keyword">true</emphasis>;
4503 
4504 &#32;&#32;&#32;&#32;testlibMode&#32;=&#32;_interactor;
4505 &#32;&#32;&#32;&#32;__testlib_set_binary(stdin);
4506 
4507 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(argc&#32;&gt;&#32;1&#32;&amp;&amp;&#32;!strcmp(<emphasis role="stringliteral">&quot;--help&quot;</emphasis>,&#32;argv[1]))
4508 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_help();
4509 
4510 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(argc&#32;&lt;&#32;3&#32;||&#32;argc&#32;&gt;&#32;6)&#32;{
4511 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_fail,&#32;std::string(<emphasis role="stringliteral">&quot;Program&#32;must&#32;be&#32;run&#32;with&#32;the&#32;following&#32;arguments:&#32;&quot;</emphasis>)&#32;+
4512 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::string(<emphasis role="stringliteral">&quot;&lt;input-file&gt;&#32;&lt;output-file&gt;&#32;[&lt;answer-file&gt;&#32;[&lt;report-file&gt;&#32;[&lt;-appes&gt;]]]&quot;</emphasis>)&#32;+
4513 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;\nUse&#32;\&quot;--help\&quot;&#32;to&#32;get&#32;help&#32;information&quot;</emphasis>);
4514 &#32;&#32;&#32;&#32;}
4515 
4516 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(argc&#32;&lt;=&#32;4)&#32;{
4517 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;resultName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>;
4518 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;appesMode&#32;=&#32;<emphasis role="keyword">false</emphasis>;
4519 &#32;&#32;&#32;&#32;}
4520 
4521 <emphasis role="preprocessor">#ifndef&#32;EJUDGE</emphasis>
4522 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(argc&#32;==&#32;5)&#32;{
4523 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;resultName&#32;=&#32;argv[4];
4524 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;appesMode&#32;=&#32;<emphasis role="keyword">false</emphasis>;
4525 &#32;&#32;&#32;&#32;}
4526 
4527 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(argc&#32;==&#32;6)&#32;{
4528 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(strcmp(<emphasis role="stringliteral">&quot;-APPES&quot;</emphasis>,&#32;argv[5])&#32;&amp;&amp;&#32;strcmp(<emphasis role="stringliteral">&quot;-appes&quot;</emphasis>,&#32;argv[5]))&#32;{
4529 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_fail,&#32;std::string(<emphasis role="stringliteral">&quot;Program&#32;must&#32;be&#32;run&#32;with&#32;the&#32;following&#32;arguments:&#32;&quot;</emphasis>)&#32;+
4530 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;&lt;input-file&gt;&#32;&lt;output-file&gt;&#32;&lt;answer-file&gt;&#32;[&lt;report-file&gt;&#32;[&lt;-appes&gt;]]&quot;</emphasis>);
4531 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
4532 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;resultName&#32;=&#32;argv[4];
4533 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;appesMode&#32;=&#32;<emphasis role="keyword">true</emphasis>;
4534 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
4535 &#32;&#32;&#32;&#32;}
4536 <emphasis role="preprocessor">#endif</emphasis>
4537 
4538 &#32;&#32;&#32;&#32;inf.init(argv[1],&#32;_input);
4539 
4540 &#32;&#32;&#32;&#32;tout.open(argv[2],&#32;std::ios_base::out);
4541 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(tout.fail()&#32;||&#32;!tout.is_open())
4542 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_fail,&#32;std::string(<emphasis role="stringliteral">&quot;Can&#32;not&#32;write&#32;to&#32;the&#32;test-output-file&#32;&apos;&quot;</emphasis>)&#32;+&#32;argv[2]&#32;+&#32;std::string(<emphasis role="stringliteral">&quot;&apos;&quot;</emphasis>));
4543 
4544 &#32;&#32;&#32;&#32;ouf.init(stdin,&#32;_output);
4545 
4546 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(argc&#32;&gt;=&#32;4)
4547 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;ans.init(argv[3],&#32;_answer);
4548 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
4549 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;ans.name&#32;=&#32;<emphasis role="stringliteral">&quot;unopened&#32;answer&#32;stream&quot;</emphasis>;
4550 }
4551 
4552 <emphasis role="keywordtype">void</emphasis>&#32;registerValidation()&#32;{
4553 &#32;&#32;&#32;&#32;__testlib_ensuresPreconditions();
4554 &#32;&#32;&#32;&#32;TestlibFinalizeGuard::registered&#32;=&#32;<emphasis role="keyword">true</emphasis>;
4555 
4556 &#32;&#32;&#32;&#32;testlibMode&#32;=&#32;_validator;
4557 
4558 &#32;&#32;&#32;&#32;__testlib_set_binary(stdin);
4559 &#32;&#32;&#32;&#32;__testlib_set_binary(stdout);
4560 &#32;&#32;&#32;&#32;__testlib_set_binary(stderr);
4561 
4562 &#32;&#32;&#32;&#32;inf.init(stdin,&#32;_input);
4563 &#32;&#32;&#32;&#32;inf.strict&#32;=&#32;<emphasis role="keyword">true</emphasis>;
4564 }
4565 
4566 <emphasis role="keywordtype">void</emphasis>&#32;registerValidation(<emphasis role="keywordtype">int</emphasis>&#32;argc,&#32;<emphasis role="keywordtype">char</emphasis>&#32;*argv[])&#32;{
4567 &#32;&#32;&#32;&#32;registerValidation();
4568 &#32;&#32;&#32;&#32;__testlib_set_testset_and_group(argc,&#32;argv);
4569 
4570 &#32;&#32;&#32;&#32;validator.initialize();
4571 &#32;&#32;&#32;&#32;TestlibFinalizeGuard::registered&#32;=&#32;<emphasis role="keyword">true</emphasis>;
4572 
4573 &#32;&#32;&#32;&#32;std::string&#32;comment&#32;=&#32;<emphasis role="stringliteral">&quot;Validator&#32;must&#32;be&#32;run&#32;with&#32;the&#32;following&#32;arguments:&quot;</emphasis>
4574 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;&#32;[--testset&#32;testset]&quot;</emphasis>
4575 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;&#32;[--group&#32;group]&quot;</emphasis>
4576 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;&#32;[--testOverviewLogFileName&#32;fileName]&quot;</emphasis>
4577 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;&#32;[--testMarkupFileName&#32;fileName]&quot;</emphasis>
4578 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;&#32;[--testCase&#32;testCase]&quot;</emphasis>
4579 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;&#32;[--testCaseFileName&#32;fileName]&quot;</emphasis>
4580 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;;
4581 
4582 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">int</emphasis>&#32;i&#32;=&#32;1;&#32;i&#32;&lt;&#32;argc;&#32;i++)&#32;{
4583 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!strcmp(<emphasis role="stringliteral">&quot;--testset&quot;</emphasis>,&#32;argv[i]))&#32;{
4584 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(i&#32;+&#32;1&#32;&lt;&#32;argc&#32;&amp;&amp;&#32;strlen(argv[i&#32;+&#32;1])&#32;&gt;&#32;0)
4585 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;validator.setTestset(argv[++i]);
4586 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
4587 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_fail,&#32;comment);
4588 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
4589 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!strcmp(<emphasis role="stringliteral">&quot;--group&quot;</emphasis>,&#32;argv[i]))&#32;{
4590 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(i&#32;+&#32;1&#32;&lt;&#32;argc)
4591 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;validator.setGroup(argv[++i]);
4592 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
4593 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_fail,&#32;comment);
4594 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
4595 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!strcmp(<emphasis role="stringliteral">&quot;--testOverviewLogFileName&quot;</emphasis>,&#32;argv[i]))&#32;{
4596 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(i&#32;+&#32;1&#32;&lt;&#32;argc)
4597 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;validator.setTestOverviewLogFileName(argv[++i]);
4598 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
4599 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_fail,&#32;comment);
4600 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
4601 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!strcmp(<emphasis role="stringliteral">&quot;--testMarkupFileName&quot;</emphasis>,&#32;argv[i]))&#32;{
4602 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(i&#32;+&#32;1&#32;&lt;&#32;argc)
4603 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;validator.setTestMarkupFileName(argv[++i]);
4604 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
4605 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_fail,&#32;comment);
4606 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
4607 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!strcmp(<emphasis role="stringliteral">&quot;--testCase&quot;</emphasis>,&#32;argv[i]))&#32;{
4608 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(i&#32;+&#32;1&#32;&lt;&#32;argc)&#32;{
4609 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;testCase&#32;=&#32;stringToLongLong(inf,&#32;argv[++i]);
4610 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(testCase&#32;&lt;&#32;1&#32;||&#32;testCase&#32;&gt;=&#32;__TESTLIB_MAX_TEST_CASE)
4611 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_fail,&#32;format(<emphasis role="stringliteral">&quot;Argument&#32;testCase&#32;should&#32;be&#32;between&#32;1&#32;and&#32;%d,&#32;but&#32;&quot;</emphasis>,&#32;__TESTLIB_MAX_TEST_CASE)
4612 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;+&#32;toString(testCase)&#32;+&#32;<emphasis role="stringliteral">&quot;&#32;found&quot;</emphasis>);
4613 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;validator.setTestCase(<emphasis role="keywordtype">int</emphasis>(testCase));
4614 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>
4615 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_fail,&#32;comment);
4616 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
4617 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!strcmp(<emphasis role="stringliteral">&quot;--testCaseFileName&quot;</emphasis>,&#32;argv[i]))&#32;{
4618 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(i&#32;+&#32;1&#32;&lt;&#32;argc)&#32;{
4619 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;validator.setTestCaseFileName(argv[++i]);
4620 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>
4621 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_fail,&#32;comment);
4622 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
4623 &#32;&#32;&#32;&#32;}
4624 }
4625 
4626 <emphasis role="keywordtype">void</emphasis>&#32;addFeature(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;feature)&#32;{
4627 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(testlibMode&#32;!=&#32;_validator)
4628 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_fail,&#32;<emphasis role="stringliteral">&quot;Features&#32;are&#32;supported&#32;in&#32;validators&#32;only.&quot;</emphasis>);
4629 &#32;&#32;&#32;&#32;validator.addFeature(feature);
4630 }
4631 
4632 <emphasis role="keywordtype">void</emphasis>&#32;feature(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;feature)&#32;{
4633 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(testlibMode&#32;!=&#32;_validator)
4634 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_fail,&#32;<emphasis role="stringliteral">&quot;Features&#32;are&#32;supported&#32;in&#32;validators&#32;only.&quot;</emphasis>);
4635 &#32;&#32;&#32;&#32;validator.feature(feature);
4636 }
4637 
4638 <emphasis role="keyword">class&#32;</emphasis><link linkend="_class_checker">Checker</link>&#32;{
4639 <emphasis role="keyword">private</emphasis>:
4640 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;_initialized;
4641 &#32;&#32;&#32;&#32;std::string&#32;_testset;
4642 &#32;&#32;&#32;&#32;std::string&#32;_group;
4643 
4644 <emphasis role="keyword">public</emphasis>:
4645 &#32;&#32;&#32;&#32;<link linkend="_class_checker">Checker</link>()&#32;:&#32;_initialized(<emphasis role="keyword">false</emphasis>),&#32;_testset(<emphasis role="stringliteral">&quot;tests&quot;</emphasis>),&#32;_group()&#32;{
4646 &#32;&#32;&#32;&#32;}
4647 
4648 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;initialize()&#32;{
4649 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_initialized&#32;=&#32;<emphasis role="keyword">true</emphasis>;
4650 &#32;&#32;&#32;&#32;}
4651 
4652 &#32;&#32;&#32;&#32;std::string&#32;testset()<emphasis role="keyword">&#32;const&#32;</emphasis>{
4653 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!_initialized)
4654 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;Checker&#32;should&#32;be&#32;initialized&#32;with&#32;registerTestlibCmd(argc,&#32;argv)&#32;instead&#32;of&#32;registerTestlibCmd()&#32;to&#32;support&#32;checker.testset()&quot;</emphasis>);
4655 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;_testset;
4656 &#32;&#32;&#32;&#32;}
4657 
4658 &#32;&#32;&#32;&#32;std::string&#32;group()<emphasis role="keyword">&#32;const&#32;</emphasis>{
4659 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!_initialized)
4660 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;Checker&#32;should&#32;be&#32;initialized&#32;with&#32;registerTestlibCmd(argc,&#32;argv)&#32;instead&#32;of&#32;registerTestlibCmd()&#32;to&#32;support&#32;checker.group()&quot;</emphasis>);
4661 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;_group;
4662 &#32;&#32;&#32;&#32;}
4663 
4664 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;setTestset(<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*<emphasis role="keyword">const</emphasis>&#32;testset)&#32;{
4665 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_testset&#32;=&#32;testset;
4666 &#32;&#32;&#32;&#32;}
4667 
4668 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;setGroup(<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*<emphasis role="keyword">const</emphasis>&#32;group)&#32;{
4669 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_group&#32;=&#32;group;
4670 &#32;&#32;&#32;&#32;}
4671 }&#32;checker;
4672 
4673 <emphasis role="keywordtype">void</emphasis>&#32;registerTestlibCmd(<emphasis role="keywordtype">int</emphasis>&#32;argc,&#32;<emphasis role="keywordtype">char</emphasis>&#32;*argv[])&#32;{
4674 &#32;&#32;&#32;&#32;__testlib_ensuresPreconditions();
4675 &#32;&#32;&#32;&#32;__testlib_set_testset_and_group(argc,&#32;argv);
4676 &#32;&#32;&#32;&#32;TestlibFinalizeGuard::registered&#32;=&#32;<emphasis role="keyword">true</emphasis>;
4677 
4678 &#32;&#32;&#32;&#32;testlibMode&#32;=&#32;_checker;
4679 &#32;&#32;&#32;&#32;__testlib_set_binary(stdin);
4680 
4681 &#32;&#32;&#32;&#32;std::vector&lt;std::string&gt;&#32;args(1,&#32;argv[0]);
4682 &#32;&#32;&#32;&#32;checker.initialize();
4683 
4684 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">int</emphasis>&#32;i&#32;=&#32;1;&#32;i&#32;&lt;&#32;argc;&#32;i++)&#32;{
4685 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!strcmp(<emphasis role="stringliteral">&quot;--testset&quot;</emphasis>,&#32;argv[i]))&#32;{
4686 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(i&#32;+&#32;1&#32;&lt;&#32;argc&#32;&amp;&amp;&#32;strlen(argv[i&#32;+&#32;1])&#32;&gt;&#32;0)
4687 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;checker.setTestset(argv[++i]);
4688 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
4689 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_fail,&#32;std::string(<emphasis role="stringliteral">&quot;Expected&#32;testset&#32;after&#32;--testset&#32;command&#32;line&#32;parameter&quot;</emphasis>));
4690 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!strcmp(<emphasis role="stringliteral">&quot;--group&quot;</emphasis>,&#32;argv[i]))&#32;{
4691 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(i&#32;+&#32;1&#32;&lt;&#32;argc)
4692 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;checker.setGroup(argv[++i]);
4693 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
4694 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_fail,&#32;std::string(<emphasis role="stringliteral">&quot;Expected&#32;group&#32;after&#32;--group&#32;command&#32;line&#32;parameter&quot;</emphasis>));
4695 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>
4696 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;args.push_back(argv[i]);
4697 &#32;&#32;&#32;&#32;}
4698 
4699 &#32;&#32;&#32;&#32;argc&#32;=&#32;int(args.size());
4700 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(argc&#32;&gt;&#32;1&#32;&amp;&amp;&#32;<emphasis role="stringliteral">&quot;--help&quot;</emphasis>&#32;==&#32;args[1])
4701 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_help();
4702 
4703 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(argc&#32;&lt;&#32;4&#32;||&#32;argc&#32;&gt;&#32;6)&#32;{
4704 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_fail,&#32;std::string(<emphasis role="stringliteral">&quot;Program&#32;must&#32;be&#32;run&#32;with&#32;the&#32;following&#32;arguments:&#32;&quot;</emphasis>)&#32;+
4705 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::string(<emphasis role="stringliteral">&quot;[--testset&#32;testset]&#32;[--group&#32;group]&#32;&lt;input-file&gt;&#32;&lt;output-file&gt;&#32;&lt;answer-file&gt;&#32;[&lt;report-file&gt;&#32;[&lt;-appes&gt;]]&quot;</emphasis>)&#32;+
4706 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;\nUse&#32;\&quot;--help\&quot;&#32;to&#32;get&#32;help&#32;information&quot;</emphasis>);
4707 &#32;&#32;&#32;&#32;}
4708 
4709 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(argc&#32;==&#32;4)&#32;{
4710 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;resultName&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>;
4711 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;appesMode&#32;=&#32;<emphasis role="keyword">false</emphasis>;
4712 &#32;&#32;&#32;&#32;}
4713 
4714 <emphasis role="preprocessor">#ifndef&#32;EJUDGE</emphasis>
4715 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(argc&#32;==&#32;5)&#32;{
4716 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;resultName&#32;=&#32;args[4];
4717 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;appesMode&#32;=&#32;<emphasis role="keyword">false</emphasis>;
4718 &#32;&#32;&#32;&#32;}
4719 
4720 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(argc&#32;==&#32;6)&#32;{
4721 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(<emphasis role="stringliteral">&quot;-APPES&quot;</emphasis>&#32;!=&#32;args[5]&#32;&amp;&amp;&#32;<emphasis role="stringliteral">&quot;-appes&quot;</emphasis>&#32;!=&#32;args[5])&#32;{
4722 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_fail,&#32;std::string(<emphasis role="stringliteral">&quot;Program&#32;must&#32;be&#32;run&#32;with&#32;the&#32;following&#32;arguments:&#32;&quot;</emphasis>)&#32;+
4723 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;&lt;input-file&gt;&#32;&lt;output-file&gt;&#32;&lt;answer-file&gt;&#32;[&lt;report-file&gt;&#32;[&lt;-appes&gt;]]&quot;</emphasis>);
4724 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
4725 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;resultName&#32;=&#32;args[4];
4726 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;appesMode&#32;=&#32;<emphasis role="keyword">true</emphasis>;
4727 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
4728 &#32;&#32;&#32;&#32;}
4729 <emphasis role="preprocessor">#endif</emphasis>
4730 
4731 &#32;&#32;&#32;&#32;inf.init(args[1],&#32;_input);
4732 &#32;&#32;&#32;&#32;ouf.init(args[2],&#32;_output);
4733 &#32;&#32;&#32;&#32;ouf.skipBom();
4734 &#32;&#32;&#32;&#32;ans.init(args[3],&#32;_answer);
4735 }
4736 
4737 <emphasis role="keywordtype">void</emphasis>&#32;registerTestlib(<emphasis role="keywordtype">int</emphasis>&#32;argc,&#32;...)&#32;{
4738 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(argc&#32;&lt;&#32;3&#32;||&#32;argc&#32;&gt;&#32;5)
4739 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_fail,&#32;std::string(<emphasis role="stringliteral">&quot;Program&#32;must&#32;be&#32;run&#32;with&#32;the&#32;following&#32;arguments:&#32;&quot;</emphasis>)&#32;+
4740 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;&lt;input-file&gt;&#32;&lt;output-file&gt;&#32;&lt;answer-file&gt;&#32;[&lt;report-file&gt;&#32;[&lt;-appes&gt;]]&quot;</emphasis>);
4741 
4742 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">char</emphasis>&#32;**argv&#32;=&#32;<emphasis role="keyword">new</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*[argc&#32;+&#32;1];
4743 
4744 &#32;&#32;&#32;&#32;va_list&#32;ap;
4745 &#32;&#32;&#32;&#32;va_start(ap,&#32;argc);
4746 &#32;&#32;&#32;&#32;argv[0]&#32;=&#32;NULL;
4747 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">int</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;argc;&#32;i++)&#32;{
4748 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;argv[i&#32;+&#32;1]&#32;=&#32;va_arg(ap,&#32;<emphasis role="keywordtype">char</emphasis>*);
4749 &#32;&#32;&#32;&#32;}
4750 &#32;&#32;&#32;&#32;va_end(ap);
4751 
4752 &#32;&#32;&#32;&#32;registerTestlibCmd(argc&#32;+&#32;1,&#32;argv);
4753 &#32;&#32;&#32;&#32;<emphasis role="keyword">delete</emphasis>[]&#32;argv;
4754 }
4755 
4756 <emphasis role="keyword">static</emphasis>&#32;<emphasis role="keyword">inline</emphasis>&#32;<emphasis role="keywordtype">void</emphasis>&#32;__testlib_ensure(<emphasis role="keywordtype">bool</emphasis>&#32;cond,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;msg)&#32;{
4757 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!cond)
4758 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_fail,&#32;msg.c_str());
4759 }
4760 
4761 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
4762 __attribute__((unused))
4763 <emphasis role="preprocessor">#endif</emphasis>
4764 <emphasis role="keyword">static</emphasis>&#32;<emphasis role="keyword">inline</emphasis>&#32;<emphasis role="keywordtype">void</emphasis>&#32;__testlib_ensure(<emphasis role="keywordtype">bool</emphasis>&#32;cond,&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*msg)&#32;{
4765 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!cond)
4766 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;quit(_fail,&#32;msg);
4767 }
4768 
4769 <emphasis role="preprocessor">#define&#32;ensure(cond)&#32;__testlib_ensure(cond,&#32;&quot;Condition&#32;failed:&#32;\&quot;&quot;&#32;#cond&#32;&quot;\&quot;&quot;)</emphasis>
4770 <emphasis role="preprocessor">#define&#32;STRINGIZE_DETAIL(x)&#32;#x</emphasis>
4771 <emphasis role="preprocessor">#define&#32;STRINGIZE(x)&#32;STRINGIZE_DETAIL(x)</emphasis>
4772 <emphasis role="preprocessor">#define&#32;ensure_ext(cond)&#32;__testlib_ensure(cond,&#32;&quot;Line&#32;&quot;&#32;STRINGIZE(__LINE__)&#32;&quot;:&#32;Condition&#32;failed:&#32;\&quot;&quot;&#32;#cond&#32;&quot;\&quot;&quot;)</emphasis>
4773 
4774 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
4775 __attribute__&#32;((format&#32;(printf,&#32;2,&#32;3)))
4776 <emphasis role="preprocessor">#endif</emphasis>
4777 <emphasis role="keyword">inline</emphasis>&#32;<emphasis role="keywordtype">void</emphasis>&#32;ensuref(<emphasis role="keywordtype">bool</emphasis>&#32;cond,&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*format,&#32;...)&#32;{
4778 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!cond)&#32;{
4779 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;FMT_TO_RESULT(format,&#32;format,&#32;message);
4780 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_ensure(cond,&#32;message);
4781 &#32;&#32;&#32;&#32;}
4782 }
4783 
4784 NORETURN&#32;<emphasis role="keyword">static</emphasis>&#32;<emphasis role="keywordtype">void</emphasis>&#32;__testlib_fail(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;message)&#32;{
4785 &#32;&#32;&#32;&#32;quitf(_fail,&#32;<emphasis role="stringliteral">&quot;%s&quot;</emphasis>,&#32;message.c_str());
4786 }
4787 
4788 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
4789 __attribute__&#32;((format&#32;(printf,&#32;1,&#32;2)))
4790 <emphasis role="preprocessor">#endif</emphasis>
4791 <emphasis role="keywordtype">void</emphasis>&#32;setName(<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*format,&#32;...)&#32;{
4792 &#32;&#32;&#32;&#32;FMT_TO_RESULT(format,&#32;format,&#32;name);
4793 &#32;&#32;&#32;&#32;checkerName&#32;=&#32;name;
4794 }
4795 
4796 <emphasis role="comment">/*</emphasis>
4797 <emphasis role="comment">&#32;*&#32;Do&#32;not&#32;use&#32;random_shuffle,&#32;because&#32;it&#32;will&#32;produce&#32;different&#32;result</emphasis>
4798 <emphasis role="comment">&#32;*&#32;for&#32;different&#32;C++&#32;compilers.</emphasis>
4799 <emphasis role="comment">&#32;*</emphasis>
4800 <emphasis role="comment">&#32;*&#32;This&#32;implementation&#32;uses&#32;testlib&#32;random_t&#32;to&#32;produce&#32;random&#32;numbers,&#32;so</emphasis>
4801 <emphasis role="comment">&#32;*&#32;it&#32;is&#32;stable.</emphasis>
4802 <emphasis role="comment">&#32;*/</emphasis>
4803 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_RandomAccessIter&gt;
4804 <emphasis role="keywordtype">void</emphasis>&#32;shuffle(_RandomAccessIter&#32;__first,&#32;_RandomAccessIter&#32;__last)&#32;{
4805 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__first&#32;==&#32;__last)&#32;<emphasis role="keywordflow">return</emphasis>;
4806 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(_RandomAccessIter&#32;__i&#32;=&#32;__first&#32;+&#32;1;&#32;__i&#32;!=&#32;__last;&#32;++__i)
4807 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::iter_swap(__i,&#32;__first&#32;+&#32;rnd.next(<emphasis role="keywordtype">int</emphasis>(__i&#32;-&#32;__first)&#32;+&#32;1));
4808 }
4809 
4810 
4811 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_RandomAccessIter&gt;
4812 <emphasis role="preprocessor">#if&#32;defined(__GNUC__)&#32;&amp;&amp;&#32;!defined(__clang__)</emphasis>
4813 __attribute__&#32;((error(<emphasis role="stringliteral">&quot;Don&apos;t&#32;use&#32;random_shuffle(),&#32;use&#32;shuffle()&#32;instead&quot;</emphasis>)))
4814 <emphasis role="preprocessor">#endif</emphasis>
4815 <emphasis role="keywordtype">void</emphasis>&#32;random_shuffle(_RandomAccessIter,&#32;_RandomAccessIter)&#32;{
4816 &#32;&#32;&#32;&#32;quitf(_fail,&#32;<emphasis role="stringliteral">&quot;Don&apos;t&#32;use&#32;random_shuffle(),&#32;use&#32;shuffle()&#32;instead&quot;</emphasis>);
4817 }
4818 
4819 <emphasis role="preprocessor">#ifdef&#32;__GLIBC__</emphasis>
4820 <emphasis role="preprocessor">#&#32;&#32;define&#32;RAND_THROW_STATEMENT&#32;throw()</emphasis>
4821 <emphasis role="preprocessor">#else</emphasis>
4822 <emphasis role="preprocessor">#&#32;&#32;define&#32;RAND_THROW_STATEMENT</emphasis>
4823 <emphasis role="preprocessor">#endif</emphasis>
4824 
4825 <emphasis role="preprocessor">#if&#32;defined(__GNUC__)&#32;&amp;&amp;&#32;!defined(__clang__)</emphasis>
4826 
4827 __attribute__&#32;((error(<emphasis role="stringliteral">&quot;Don&apos;t&#32;use&#32;rand(),&#32;use&#32;rnd.next()&#32;instead&quot;</emphasis>)))
4828 <emphasis role="preprocessor">#endif</emphasis>
4829 <emphasis role="preprocessor">#ifdef&#32;_MSC_VER</emphasis>
4830 <emphasis role="preprocessor">#&#32;&#32;&#32;pragma&#32;warning(&#32;disable&#32;:&#32;4273&#32;)</emphasis>
4831 <emphasis role="preprocessor">#endif</emphasis>
4832 <emphasis role="keywordtype">int</emphasis>&#32;rand()&#32;RAND_THROW_STATEMENT
4833 {
4834 &#32;&#32;&#32;&#32;quitf(_fail,&#32;<emphasis role="stringliteral">&quot;Don&apos;t&#32;use&#32;rand(),&#32;use&#32;rnd.next()&#32;instead&quot;</emphasis>);
4835 
4836 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;This&#32;line&#32;never&#32;runs.&#32;*/</emphasis>
4837 &#32;&#32;&#32;&#32;<emphasis role="comment">//throw&#32;&quot;Don&apos;t&#32;use&#32;rand(),&#32;use&#32;rnd.next()&#32;instead&quot;;</emphasis>
4838 }
4839 
4840 <emphasis role="preprocessor">#if&#32;defined(__GNUC__)&#32;&amp;&amp;&#32;!defined(__clang__)</emphasis>
4841 
4842 __attribute__&#32;((error(<emphasis role="stringliteral">&quot;Don&apos;t&#32;use&#32;srand(),&#32;you&#32;should&#32;use&#32;&quot;</emphasis>
4843 <emphasis role="stringliteral">&quot;&apos;registerGen(argc,&#32;argv,&#32;1);&apos;&#32;to&#32;initialize&#32;generator&#32;seed&#32;&quot;</emphasis>
4844 <emphasis role="stringliteral">&quot;by&#32;hash&#32;code&#32;of&#32;the&#32;command&#32;line&#32;params.&#32;The&#32;third&#32;parameter&#32;&quot;</emphasis>
4845 <emphasis role="stringliteral">&quot;is&#32;randomGeneratorVersion&#32;(currently&#32;the&#32;latest&#32;is&#32;1).&quot;</emphasis>)))
4846 <emphasis role="preprocessor">#endif</emphasis>
4847 <emphasis role="preprocessor">#ifdef&#32;_MSC_VER</emphasis>
4848 <emphasis role="preprocessor">#&#32;&#32;&#32;pragma&#32;warning(&#32;disable&#32;:&#32;4273&#32;)</emphasis>
4849 <emphasis role="preprocessor">#endif</emphasis>
4850 <emphasis role="keywordtype">void</emphasis>&#32;srand(<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">int</emphasis>&#32;seed)&#32;RAND_THROW_STATEMENT
4851 {
4852 &#32;&#32;&#32;&#32;quitf(_fail,&#32;<emphasis role="stringliteral">&quot;Don&apos;t&#32;use&#32;srand(),&#32;you&#32;should&#32;use&#32;&quot;</emphasis>
4853 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;&apos;registerGen(argc,&#32;argv,&#32;1);&apos;&#32;to&#32;initialize&#32;generator&#32;seed&#32;&quot;</emphasis>
4854 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;by&#32;hash&#32;code&#32;of&#32;the&#32;command&#32;line&#32;params.&#32;The&#32;third&#32;parameter&#32;&quot;</emphasis>
4855 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;is&#32;randomGeneratorVersion&#32;(currently&#32;the&#32;latest&#32;is&#32;1)&#32;[ignored&#32;seed=%u].&quot;</emphasis>,&#32;seed);
4856 }
4857 
4858 <emphasis role="keywordtype">void</emphasis>&#32;startTest(<emphasis role="keywordtype">int</emphasis>&#32;test)&#32;{
4859 &#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;testFileName&#32;=&#32;vtos(test);
4860 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(NULL&#32;==&#32;freopen(testFileName.c_str(),&#32;<emphasis role="stringliteral">&quot;wt&quot;</emphasis>,&#32;stdout))
4861 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;Unable&#32;to&#32;write&#32;file&#32;&apos;&quot;</emphasis>&#32;+&#32;testFileName&#32;+&#32;<emphasis role="stringliteral">&quot;&apos;&quot;</emphasis>);
4862 }
4863 
4864 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
4865 __attribute__((<emphasis role="keyword">const</emphasis>))
4866 <emphasis role="preprocessor">#endif</emphasis>
4867 <emphasis role="keyword">inline</emphasis>&#32;std::string&#32;compress(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;s)&#32;{
4868 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__testlib_part(s);
4869 }
4870 
4871 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
4872 __attribute__((<emphasis role="keyword">const</emphasis>))
4873 <emphasis role="preprocessor">#endif</emphasis>
4874 <emphasis role="keyword">inline</emphasis>&#32;std::string&#32;englishEnding(<emphasis role="keywordtype">int</emphasis>&#32;x)&#32;{
4875 &#32;&#32;&#32;&#32;x&#32;%=&#32;100;
4876 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(x&#32;/&#32;10&#32;==&#32;1)
4877 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="stringliteral">&quot;th&quot;</emphasis>;
4878 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(x&#32;%&#32;10&#32;==&#32;1)
4879 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="stringliteral">&quot;st&quot;</emphasis>;
4880 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(x&#32;%&#32;10&#32;==&#32;2)
4881 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="stringliteral">&quot;nd&quot;</emphasis>;
4882 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(x&#32;%&#32;10&#32;==&#32;3)
4883 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="stringliteral">&quot;rd&quot;</emphasis>;
4884 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="stringliteral">&quot;th&quot;</emphasis>;
4885 }
4886 
4887 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_ForwardIterator,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Separator&gt;
4888 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
4889 __attribute__((<emphasis role="keyword">const</emphasis>))
4890 <emphasis role="preprocessor">#endif</emphasis>
4891 std::string&#32;join(_ForwardIterator&#32;first,&#32;_ForwardIterator&#32;last,&#32;_Separator&#32;separator)&#32;{
4892 &#32;&#32;&#32;&#32;std::stringstream&#32;ss;
4893 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;repeated&#32;=&#32;<emphasis role="keyword">false</emphasis>;
4894 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(_ForwardIterator&#32;i&#32;=&#32;first;&#32;i&#32;!=&#32;last;&#32;i++)&#32;{
4895 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(repeated)
4896 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;ss&#32;&lt;&lt;&#32;separator;
4897 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
4898 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;repeated&#32;=&#32;<emphasis role="keyword">true</emphasis>;
4899 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;ss&#32;&lt;&lt;&#32;*i;
4900 &#32;&#32;&#32;&#32;}
4901 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;ss.str();
4902 }
4903 
4904 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_ForwardIterator&gt;
4905 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
4906 __attribute__((<emphasis role="keyword">const</emphasis>))
4907 <emphasis role="preprocessor">#endif</emphasis>
4908 std::string&#32;join(_ForwardIterator&#32;first,&#32;_ForwardIterator&#32;last)&#32;{
4909 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;join(first,&#32;last,&#32;<emphasis role="charliteral">&apos;&#32;&apos;</emphasis>);
4910 }
4911 
4912 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Collection,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Separator&gt;
4913 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
4914 __attribute__((<emphasis role="keyword">const</emphasis>))
4915 <emphasis role="preprocessor">#endif</emphasis>
4916 std::string&#32;join(<emphasis role="keyword">const</emphasis>&#32;_Collection&#32;&amp;collection,&#32;_Separator&#32;separator)&#32;{
4917 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;join(collection.begin(),&#32;collection.end(),&#32;separator);
4918 }
4919 
4920 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Collection&gt;
4921 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
4922 __attribute__((<emphasis role="keyword">const</emphasis>))
4923 <emphasis role="preprocessor">#endif</emphasis>
4924 std::string&#32;join(<emphasis role="keyword">const</emphasis>&#32;_Collection&#32;&amp;collection)&#32;{
4925 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;join(collection,&#32;<emphasis role="charliteral">&apos;&#32;&apos;</emphasis>);
4926 }
4927 
4932 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
4933 __attribute__((<emphasis role="keyword">const</emphasis>))
4934 <emphasis role="preprocessor">#endif</emphasis>
4935 std::vector&lt;std::string&gt;&#32;split(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;s,&#32;<emphasis role="keywordtype">char</emphasis>&#32;separator)&#32;{
4936 &#32;&#32;&#32;&#32;std::vector&lt;std::string&gt;&#32;result;
4937 &#32;&#32;&#32;&#32;std::string&#32;item;
4938 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">size_t</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;s.length();&#32;i++)
4939 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(s[i]&#32;==&#32;separator)&#32;{
4940 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result.push_back(item);
4941 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;item&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>;
4942 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>
4943 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;item&#32;+=&#32;s[i];
4944 &#32;&#32;&#32;&#32;result.push_back(item);
4945 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;result;
4946 }
4947 
4952 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
4953 __attribute__((<emphasis role="keyword">const</emphasis>))
4954 <emphasis role="preprocessor">#endif</emphasis>
4955 std::vector&lt;std::string&gt;&#32;split(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;s,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;separators)&#32;{
4956 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(separators.empty())
4957 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;std::vector&lt;std::string&gt;(1,&#32;s);
4958 
4959 &#32;&#32;&#32;&#32;std::vector&lt;bool&gt;&#32;isSeparator(256);
4960 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">size_t</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;separators.size();&#32;i++)
4961 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;isSeparator[(<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>)&#32;(separators[i])]&#32;=&#32;<emphasis role="keyword">true</emphasis>;
4962 
4963 &#32;&#32;&#32;&#32;std::vector&lt;std::string&gt;&#32;result;
4964 &#32;&#32;&#32;&#32;std::string&#32;item;
4965 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">size_t</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;s.length();&#32;i++)
4966 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(isSeparator[(<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>)&#32;(s[i])])&#32;{
4967 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result.push_back(item);
4968 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;item&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>;
4969 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>
4970 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;item&#32;+=&#32;s[i];
4971 &#32;&#32;&#32;&#32;result.push_back(item);
4972 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;result;
4973 }
4974 
4978 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
4979 __attribute__((<emphasis role="keyword">const</emphasis>))
4980 <emphasis role="preprocessor">#endif</emphasis>
4981 std::vector&lt;std::string&gt;&#32;tokenize(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;s,&#32;<emphasis role="keywordtype">char</emphasis>&#32;separator)&#32;{
4982 &#32;&#32;&#32;&#32;std::vector&lt;std::string&gt;&#32;result;
4983 &#32;&#32;&#32;&#32;std::string&#32;item;
4984 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">size_t</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;s.length();&#32;i++)
4985 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(s[i]&#32;==&#32;separator)&#32;{
4986 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!item.empty())
4987 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result.push_back(item);
4988 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;item&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>;
4989 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>
4990 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;item&#32;+=&#32;s[i];
4991 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!item.empty())
4992 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result.push_back(item);
4993 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;result;
4994 }
4995 
4999 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
5000 __attribute__((<emphasis role="keyword">const</emphasis>))
5001 <emphasis role="preprocessor">#endif</emphasis>
5002 std::vector&lt;std::string&gt;&#32;tokenize(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;s,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;separators)&#32;{
5003 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(separators.empty())
5004 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;std::vector&lt;std::string&gt;(1,&#32;s);
5005 
5006 &#32;&#32;&#32;&#32;std::vector&lt;bool&gt;&#32;isSeparator(256);
5007 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">size_t</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;separators.size();&#32;i++)
5008 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;isSeparator[(<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>)&#32;(separators[i])]&#32;=&#32;<emphasis role="keyword">true</emphasis>;
5009 
5010 &#32;&#32;&#32;&#32;std::vector&lt;std::string&gt;&#32;result;
5011 &#32;&#32;&#32;&#32;std::string&#32;item;
5012 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">size_t</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;s.length();&#32;i++)
5013 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(isSeparator[(<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>)&#32;(s[i])])&#32;{
5014 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!item.empty())
5015 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result.push_back(item);
5016 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;item&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>;
5017 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>
5018 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;item&#32;+=&#32;s[i];
5019 
5020 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!item.empty())
5021 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result.push_back(item);
5022 
5023 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;result;
5024 }
5025 
5026 NORETURN&#32;<emphasis role="keywordtype">void</emphasis>&#32;__testlib_expectedButFound(TResult&#32;result,&#32;std::string&#32;expected,&#32;std::string&#32;found,&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*prepend)&#32;{
5027 &#32;&#32;&#32;&#32;std::string&#32;message;
5028 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(strlen(prepend)&#32;!=&#32;0)
5029 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;message&#32;=&#32;format(<emphasis role="stringliteral">&quot;%s:&#32;expected&#32;&apos;%s&apos;,&#32;but&#32;found&#32;&apos;%s&apos;&quot;</emphasis>,
5030 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;compress(prepend).c_str(),&#32;compress(expected).c_str(),&#32;compress(found).c_str());
5031 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
5032 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;message&#32;=&#32;format(<emphasis role="stringliteral">&quot;expected&#32;&apos;%s&apos;,&#32;but&#32;found&#32;&apos;%s&apos;&quot;</emphasis>,
5033 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;compress(expected).c_str(),&#32;compress(found).c_str());
5034 &#32;&#32;&#32;&#32;quit(result,&#32;message);
5035 }
5036 
5037 NORETURN&#32;<emphasis role="keywordtype">void</emphasis>&#32;__testlib_expectedButFound(TResult&#32;result,&#32;<emphasis role="keywordtype">double</emphasis>&#32;expected,&#32;<emphasis role="keywordtype">double</emphasis>&#32;found,&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*prepend)&#32;{
5038 &#32;&#32;&#32;&#32;std::string&#32;expectedString&#32;=&#32;removeDoubleTrailingZeroes(format(<emphasis role="stringliteral">&quot;%.12f&quot;</emphasis>,&#32;expected));
5039 &#32;&#32;&#32;&#32;std::string&#32;foundString&#32;=&#32;removeDoubleTrailingZeroes(format(<emphasis role="stringliteral">&quot;%.12f&quot;</emphasis>,&#32;found));
5040 &#32;&#32;&#32;&#32;__testlib_expectedButFound(result,&#32;expectedString,&#32;foundString,&#32;prepend);
5041 }
5042 
5043 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Tp&gt;
5044 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
5045 __attribute__&#32;((format&#32;(printf,&#32;4,&#32;5)))
5046 <emphasis role="preprocessor">#endif</emphasis>
5047 NORETURN&#32;<emphasis role="keywordtype">void</emphasis>&#32;expectedButFound(TResult&#32;result,&#32;_Tp&#32;expected,&#32;_Tp&#32;found,&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*prependFormat&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>,&#32;...)&#32;{
5048 &#32;&#32;&#32;&#32;FMT_TO_RESULT(prependFormat,&#32;prependFormat,&#32;prepend);
5049 &#32;&#32;&#32;&#32;std::string&#32;expectedString&#32;=&#32;vtos(expected);
5050 &#32;&#32;&#32;&#32;std::string&#32;foundString&#32;=&#32;vtos(found);
5051 &#32;&#32;&#32;&#32;__testlib_expectedButFound(result,&#32;expectedString,&#32;foundString,&#32;prepend.c_str());
5052 }
5053 
5054 <emphasis role="keyword">template</emphasis>&lt;&gt;
5055 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
5056 __attribute__&#32;((format&#32;(printf,&#32;4,&#32;5)))
5057 <emphasis role="preprocessor">#endif</emphasis>
5058 NORETURN&#32;<emphasis role="keywordtype">void</emphasis>
5059 expectedButFound&lt;std::string&gt;(TResult&#32;result,&#32;std::string&#32;expected,&#32;std::string&#32;found,&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*prependFormat,&#32;...)&#32;{
5060 &#32;&#32;&#32;&#32;FMT_TO_RESULT(prependFormat,&#32;prependFormat,&#32;prepend);
5061 &#32;&#32;&#32;&#32;__testlib_expectedButFound(result,&#32;expected,&#32;found,&#32;prepend.c_str());
5062 }
5063 
5064 <emphasis role="keyword">template</emphasis>&lt;&gt;
5065 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
5066 __attribute__&#32;((format&#32;(printf,&#32;4,&#32;5)))
5067 <emphasis role="preprocessor">#endif</emphasis>
5068 NORETURN&#32;<emphasis role="keywordtype">void</emphasis>&#32;expectedButFound&lt;double&gt;(TResult&#32;result,&#32;<emphasis role="keywordtype">double</emphasis>&#32;expected,&#32;<emphasis role="keywordtype">double</emphasis>&#32;found,&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*prependFormat,&#32;...)&#32;{
5069 &#32;&#32;&#32;&#32;FMT_TO_RESULT(prependFormat,&#32;prependFormat,&#32;prepend);
5070 &#32;&#32;&#32;&#32;std::string&#32;expectedString&#32;=&#32;removeDoubleTrailingZeroes(format(<emphasis role="stringliteral">&quot;%.12f&quot;</emphasis>,&#32;expected));
5071 &#32;&#32;&#32;&#32;std::string&#32;foundString&#32;=&#32;removeDoubleTrailingZeroes(format(<emphasis role="stringliteral">&quot;%.12f&quot;</emphasis>,&#32;found));
5072 &#32;&#32;&#32;&#32;__testlib_expectedButFound(result,&#32;expectedString,&#32;foundString,&#32;prepend.c_str());
5073 }
5074 
5075 <emphasis role="keyword">template</emphasis>&lt;&gt;
5076 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
5077 __attribute__&#32;((format&#32;(printf,&#32;4,&#32;5)))
5078 <emphasis role="preprocessor">#endif</emphasis>
5079 NORETURN&#32;<emphasis role="keywordtype">void</emphasis>
5080 expectedButFound&lt;const&#32;char&#32;*&gt;(TResult&#32;result,&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*expected,&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*found,&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*prependFormat,
5081 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;...)&#32;{
5082 &#32;&#32;&#32;&#32;FMT_TO_RESULT(prependFormat,&#32;prependFormat,&#32;prepend);
5083 &#32;&#32;&#32;&#32;__testlib_expectedButFound(result,&#32;std::string(expected),&#32;std::string(found),&#32;prepend.c_str());
5084 }
5085 
5086 <emphasis role="keyword">template</emphasis>&lt;&gt;
5087 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
5088 __attribute__&#32;((format&#32;(printf,&#32;4,&#32;5)))
5089 <emphasis role="preprocessor">#endif</emphasis>
5090 NORETURN&#32;<emphasis role="keywordtype">void</emphasis>&#32;expectedButFound&lt;float&gt;(TResult&#32;result,&#32;<emphasis role="keywordtype">float</emphasis>&#32;expected,&#32;<emphasis role="keywordtype">float</emphasis>&#32;found,&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*prependFormat,&#32;...)&#32;{
5091 &#32;&#32;&#32;&#32;FMT_TO_RESULT(prependFormat,&#32;prependFormat,&#32;prepend);
5092 &#32;&#32;&#32;&#32;__testlib_expectedButFound(result,&#32;<emphasis role="keywordtype">double</emphasis>(expected),&#32;<emphasis role="keywordtype">double</emphasis>(found),&#32;prepend.c_str());
5093 }
5094 
5095 <emphasis role="keyword">template</emphasis>&lt;&gt;
5096 <emphasis role="preprocessor">#ifdef&#32;__GNUC__</emphasis>
5097 __attribute__&#32;((format&#32;(printf,&#32;4,&#32;5)))
5098 <emphasis role="preprocessor">#endif</emphasis>
5099 NORETURN&#32;<emphasis role="keywordtype">void</emphasis>
5100 expectedButFound&lt;long&#32;double&gt;(TResult&#32;result,&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">double</emphasis>&#32;expected,&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">double</emphasis>&#32;found,&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*prependFormat,&#32;...)&#32;{
5101 &#32;&#32;&#32;&#32;FMT_TO_RESULT(prependFormat,&#32;prependFormat,&#32;prepend);
5102 &#32;&#32;&#32;&#32;__testlib_expectedButFound(result,&#32;<emphasis role="keywordtype">double</emphasis>(expected),&#32;<emphasis role="keywordtype">double</emphasis>(found),&#32;prepend.c_str());
5103 }
5104 
5105 <emphasis role="preprocessor">#if&#32;__cplusplus&#32;&gt;&#32;199711L&#32;||&#32;defined(_MSC_VER)</emphasis>
5106 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Tp&gt;
5107 <emphasis role="keyword">struct&#32;</emphasis>is_iterable&#32;{
5108 &#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;U&gt;
5109 &#32;&#32;&#32;&#32;<emphasis role="keyword">static</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;test(<emphasis role="keyword">typename</emphasis>&#32;U::iterator&#32;*x);
5110 
5111 &#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;U&gt;
5112 &#32;&#32;&#32;&#32;<emphasis role="keyword">static</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;test(U&#32;*x);
5113 
5114 &#32;&#32;&#32;&#32;<emphasis role="keyword">static</emphasis>&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">bool</emphasis>&#32;value&#32;=&#32;<emphasis role="keyword">sizeof</emphasis>(test&lt;_Tp&gt;(0))&#32;==&#32;1;
5115 };
5116 
5117 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keywordtype">bool</emphasis>&#32;B,&#32;<emphasis role="keyword">class</emphasis>&#32;_Tp&#32;=&#32;<emphasis role="keywordtype">void</emphasis>&gt;
5118 <emphasis role="keyword">struct&#32;</emphasis>__testlib_enable_if&#32;{
5119 };
5120 
5121 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">class</emphasis>&#32;_Tp&gt;
5122 <emphasis role="keyword">struct&#32;</emphasis>__testlib_enable_if&lt;true,&#32;_Tp&gt;&#32;{
5123 &#32;&#32;&#32;&#32;<emphasis role="keyword">typedef</emphasis>&#32;_Tp&#32;type;
5124 };
5125 
5126 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Tp&gt;
5127 <emphasis role="keyword">typename</emphasis>&#32;__testlib_enable_if&lt;!is_iterable&lt;_Tp&gt;::value,&#32;<emphasis role="keywordtype">void</emphasis>&gt;::type&#32;__testlib_print_one(<emphasis role="keyword">const</emphasis>&#32;_Tp&#32;&amp;t)&#32;{
5128 &#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;t;
5129 }
5130 
5131 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Tp&gt;
5132 <emphasis role="keyword">typename</emphasis>&#32;__testlib_enable_if&lt;is_iterable&lt;_Tp&gt;::value,&#32;<emphasis role="keywordtype">void</emphasis>&gt;::type&#32;__testlib_print_one(<emphasis role="keyword">const</emphasis>&#32;_Tp&#32;&amp;t)&#32;{
5133 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;first&#32;=&#32;<emphasis role="keyword">true</emphasis>;
5134 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keyword">typename</emphasis>&#32;_Tp::const_iterator&#32;i&#32;=&#32;t.begin();&#32;i&#32;!=&#32;t.end();&#32;i++)&#32;{
5135 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(first)
5136 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;first&#32;=&#32;<emphasis role="keyword">false</emphasis>;
5137 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
5138 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;<emphasis role="stringliteral">&quot;&#32;&quot;</emphasis>;
5139 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;*i;
5140 &#32;&#32;&#32;&#32;}
5141 }
5142 
5143 <emphasis role="keyword">template</emphasis>&lt;&gt;
5144 <emphasis role="keyword">typename</emphasis>&#32;__testlib_enable_if&lt;is_iterable&lt;std::string&gt;::value,&#32;<emphasis role="keywordtype">void</emphasis>&gt;::type
5145 __testlib_print_one&lt;std::string&gt;(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;t)&#32;{
5146 &#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;t;
5147 }
5148 
5149 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;A,&#32;<emphasis role="keyword">typename</emphasis>&#32;B&gt;
5150 <emphasis role="keywordtype">void</emphasis>&#32;__println_range(A&#32;begin,&#32;B&#32;end)&#32;{
5151 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;first&#32;=&#32;<emphasis role="keyword">true</emphasis>;
5152 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(B&#32;i&#32;=&#32;B(begin);&#32;i&#32;!=&#32;end;&#32;i++)&#32;{
5153 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(first)
5154 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;first&#32;=&#32;<emphasis role="keyword">false</emphasis>;
5155 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
5156 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;<emphasis role="stringliteral">&quot;&#32;&quot;</emphasis>;
5157 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_print_one(*i);
5158 &#32;&#32;&#32;&#32;}
5159 &#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;std::endl;
5160 }
5161 
5162 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">class</emphasis>&#32;_Tp,&#32;<emphasis role="keyword">class</emphasis>&#32;Enable&#32;=&#32;<emphasis role="keywordtype">void</emphasis>&gt;
5163 <emphasis role="keyword">struct&#32;</emphasis>is_iterator&#32;{
5164 &#32;&#32;&#32;&#32;<emphasis role="keyword">static</emphasis>&#32;_Tp&#32;makeT();
5165 
5166 &#32;&#32;&#32;&#32;<emphasis role="keyword">typedef</emphasis>&#32;<emphasis role="keywordtype">void</emphasis>&#32;*twoptrs[2];
5167 
5168 &#32;&#32;&#32;&#32;<emphasis role="keyword">static</emphasis>&#32;twoptrs&#32;&amp;test(...);
5169 
5170 &#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">class</emphasis>&#32;R&gt;
5171 &#32;&#32;&#32;&#32;<emphasis role="keyword">static</emphasis>&#32;<emphasis role="keyword">typename</emphasis>&#32;R::iterator_category&#32;*test(R);
5172 
5173 &#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">class</emphasis>&#32;R&gt;
5174 &#32;&#32;&#32;&#32;<emphasis role="keyword">static</emphasis>&#32;<emphasis role="keywordtype">void</emphasis>&#32;*test(R&#32;*);
5175 
5176 &#32;&#32;&#32;&#32;<emphasis role="keyword">static</emphasis>&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">bool</emphasis>&#32;value&#32;=&#32;<emphasis role="keyword">sizeof</emphasis>(test(makeT()))&#32;==&#32;<emphasis role="keyword">sizeof</emphasis>(<emphasis role="keywordtype">void</emphasis>&#32;*);
5177 };
5178 
5179 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">class</emphasis>&#32;_Tp&gt;
5180 <emphasis role="keyword">struct&#32;</emphasis>is_iterator&lt;_Tp,&#32;typename&#32;__testlib_enable_if&lt;std::is_array&lt;_Tp&gt;::value&gt;::type&gt;&#32;{
5181 &#32;&#32;&#32;&#32;<emphasis role="keyword">static</emphasis>&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">bool</emphasis>&#32;value&#32;=&#32;<emphasis role="keyword">false</emphasis>;
5182 };
5183 
5184 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;A,&#32;<emphasis role="keyword">typename</emphasis>&#32;B&gt;
5185 <emphasis role="keyword">typename</emphasis>&#32;__testlib_enable_if&lt;!is_iterator&lt;B&gt;::value,&#32;<emphasis role="keywordtype">void</emphasis>&gt;::type&#32;println(<emphasis role="keyword">const</emphasis>&#32;A&#32;&amp;a,&#32;<emphasis role="keyword">const</emphasis>&#32;B&#32;&amp;b)&#32;{
5186 &#32;&#32;&#32;&#32;__testlib_print_one(a);
5187 &#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;<emphasis role="stringliteral">&quot;&#32;&quot;</emphasis>;
5188 &#32;&#32;&#32;&#32;__testlib_print_one(b);
5189 &#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;std::endl;
5190 }
5191 
5192 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;A,&#32;<emphasis role="keyword">typename</emphasis>&#32;B&gt;
5193 <emphasis role="keyword">typename</emphasis>&#32;__testlib_enable_if&lt;is_iterator&lt;B&gt;::value,&#32;<emphasis role="keywordtype">void</emphasis>&gt;::type&#32;println(<emphasis role="keyword">const</emphasis>&#32;A&#32;&amp;a,&#32;<emphasis role="keyword">const</emphasis>&#32;B&#32;&amp;b)&#32;{
5194 &#32;&#32;&#32;&#32;__println_range(a,&#32;b);
5195 }
5196 
5197 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;A&gt;
5198 <emphasis role="keywordtype">void</emphasis>&#32;println(<emphasis role="keyword">const</emphasis>&#32;A&#32;*a,&#32;<emphasis role="keyword">const</emphasis>&#32;A&#32;*b)&#32;{
5199 &#32;&#32;&#32;&#32;__println_range(a,&#32;b);
5200 }
5201 
5202 <emphasis role="keyword">template</emphasis>&lt;&gt;
5203 <emphasis role="keywordtype">void</emphasis>&#32;println&lt;char&gt;(<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*a,&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*b)&#32;{
5204 &#32;&#32;&#32;&#32;__testlib_print_one(a);
5205 &#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;<emphasis role="stringliteral">&quot;&#32;&quot;</emphasis>;
5206 &#32;&#32;&#32;&#32;__testlib_print_one(b);
5207 &#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;std::endl;
5208 }
5209 
5210 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Tp&gt;
5211 <emphasis role="keywordtype">void</emphasis>&#32;println(<emphasis role="keyword">const</emphasis>&#32;_Tp&#32;&amp;x)&#32;{
5212 &#32;&#32;&#32;&#32;__testlib_print_one(x);
5213 &#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;std::endl;
5214 }
5215 
5216 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;A,&#32;<emphasis role="keyword">typename</emphasis>&#32;B,&#32;<emphasis role="keyword">typename</emphasis>&#32;C&gt;
5217 <emphasis role="keywordtype">void</emphasis>&#32;println(<emphasis role="keyword">const</emphasis>&#32;A&#32;&amp;a,&#32;<emphasis role="keyword">const</emphasis>&#32;B&#32;&amp;b,&#32;<emphasis role="keyword">const</emphasis>&#32;C&#32;&amp;c)&#32;{
5218 &#32;&#32;&#32;&#32;__testlib_print_one(a);
5219 &#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;<emphasis role="stringliteral">&quot;&#32;&quot;</emphasis>;
5220 &#32;&#32;&#32;&#32;__testlib_print_one(b);
5221 &#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;<emphasis role="stringliteral">&quot;&#32;&quot;</emphasis>;
5222 &#32;&#32;&#32;&#32;__testlib_print_one(c);
5223 &#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;std::endl;
5224 }
5225 
5226 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;A,&#32;<emphasis role="keyword">typename</emphasis>&#32;B,&#32;<emphasis role="keyword">typename</emphasis>&#32;C,&#32;<emphasis role="keyword">typename</emphasis>&#32;D&gt;
5227 <emphasis role="keywordtype">void</emphasis>&#32;println(<emphasis role="keyword">const</emphasis>&#32;A&#32;&amp;a,&#32;<emphasis role="keyword">const</emphasis>&#32;B&#32;&amp;b,&#32;<emphasis role="keyword">const</emphasis>&#32;C&#32;&amp;c,&#32;<emphasis role="keyword">const</emphasis>&#32;D&#32;&amp;d)&#32;{
5228 &#32;&#32;&#32;&#32;__testlib_print_one(a);
5229 &#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;<emphasis role="stringliteral">&quot;&#32;&quot;</emphasis>;
5230 &#32;&#32;&#32;&#32;__testlib_print_one(b);
5231 &#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;<emphasis role="stringliteral">&quot;&#32;&quot;</emphasis>;
5232 &#32;&#32;&#32;&#32;__testlib_print_one(c);
5233 &#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;<emphasis role="stringliteral">&quot;&#32;&quot;</emphasis>;
5234 &#32;&#32;&#32;&#32;__testlib_print_one(d);
5235 &#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;std::endl;
5236 }
5237 
5238 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;A,&#32;<emphasis role="keyword">typename</emphasis>&#32;B,&#32;<emphasis role="keyword">typename</emphasis>&#32;C,&#32;<emphasis role="keyword">typename</emphasis>&#32;D,&#32;<emphasis role="keyword">typename</emphasis>&#32;E&gt;
5239 <emphasis role="keywordtype">void</emphasis>&#32;println(<emphasis role="keyword">const</emphasis>&#32;A&#32;&amp;a,&#32;<emphasis role="keyword">const</emphasis>&#32;B&#32;&amp;b,&#32;<emphasis role="keyword">const</emphasis>&#32;C&#32;&amp;c,&#32;<emphasis role="keyword">const</emphasis>&#32;D&#32;&amp;d,&#32;<emphasis role="keyword">const</emphasis>&#32;E&#32;&amp;e)&#32;{
5240 &#32;&#32;&#32;&#32;__testlib_print_one(a);
5241 &#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;<emphasis role="stringliteral">&quot;&#32;&quot;</emphasis>;
5242 &#32;&#32;&#32;&#32;__testlib_print_one(b);
5243 &#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;<emphasis role="stringliteral">&quot;&#32;&quot;</emphasis>;
5244 &#32;&#32;&#32;&#32;__testlib_print_one(c);
5245 &#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;<emphasis role="stringliteral">&quot;&#32;&quot;</emphasis>;
5246 &#32;&#32;&#32;&#32;__testlib_print_one(d);
5247 &#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;<emphasis role="stringliteral">&quot;&#32;&quot;</emphasis>;
5248 &#32;&#32;&#32;&#32;__testlib_print_one(e);
5249 &#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;std::endl;
5250 }
5251 
5252 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;A,&#32;<emphasis role="keyword">typename</emphasis>&#32;B,&#32;<emphasis role="keyword">typename</emphasis>&#32;C,&#32;<emphasis role="keyword">typename</emphasis>&#32;D,&#32;<emphasis role="keyword">typename</emphasis>&#32;E,&#32;<emphasis role="keyword">typename</emphasis>&#32;F&gt;
5253 <emphasis role="keywordtype">void</emphasis>&#32;println(<emphasis role="keyword">const</emphasis>&#32;A&#32;&amp;a,&#32;<emphasis role="keyword">const</emphasis>&#32;B&#32;&amp;b,&#32;<emphasis role="keyword">const</emphasis>&#32;C&#32;&amp;c,&#32;<emphasis role="keyword">const</emphasis>&#32;D&#32;&amp;d,&#32;<emphasis role="keyword">const</emphasis>&#32;E&#32;&amp;e,&#32;<emphasis role="keyword">const</emphasis>&#32;F&#32;&amp;f)&#32;{
5254 &#32;&#32;&#32;&#32;__testlib_print_one(a);
5255 &#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;<emphasis role="stringliteral">&quot;&#32;&quot;</emphasis>;
5256 &#32;&#32;&#32;&#32;__testlib_print_one(b);
5257 &#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;<emphasis role="stringliteral">&quot;&#32;&quot;</emphasis>;
5258 &#32;&#32;&#32;&#32;__testlib_print_one(c);
5259 &#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;<emphasis role="stringliteral">&quot;&#32;&quot;</emphasis>;
5260 &#32;&#32;&#32;&#32;__testlib_print_one(d);
5261 &#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;<emphasis role="stringliteral">&quot;&#32;&quot;</emphasis>;
5262 &#32;&#32;&#32;&#32;__testlib_print_one(e);
5263 &#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;<emphasis role="stringliteral">&quot;&#32;&quot;</emphasis>;
5264 &#32;&#32;&#32;&#32;__testlib_print_one(f);
5265 &#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;std::endl;
5266 }
5267 
5268 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;A,&#32;<emphasis role="keyword">typename</emphasis>&#32;B,&#32;<emphasis role="keyword">typename</emphasis>&#32;C,&#32;<emphasis role="keyword">typename</emphasis>&#32;D,&#32;<emphasis role="keyword">typename</emphasis>&#32;E,&#32;<emphasis role="keyword">typename</emphasis>&#32;F,&#32;<emphasis role="keyword">typename</emphasis>&#32;G&gt;
5269 <emphasis role="keywordtype">void</emphasis>&#32;println(<emphasis role="keyword">const</emphasis>&#32;A&#32;&amp;a,&#32;<emphasis role="keyword">const</emphasis>&#32;B&#32;&amp;b,&#32;<emphasis role="keyword">const</emphasis>&#32;C&#32;&amp;c,&#32;<emphasis role="keyword">const</emphasis>&#32;D&#32;&amp;d,&#32;<emphasis role="keyword">const</emphasis>&#32;E&#32;&amp;e,&#32;<emphasis role="keyword">const</emphasis>&#32;F&#32;&amp;f,&#32;<emphasis role="keyword">const</emphasis>&#32;G&#32;&amp;g)&#32;{
5270 &#32;&#32;&#32;&#32;__testlib_print_one(a);
5271 &#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;<emphasis role="stringliteral">&quot;&#32;&quot;</emphasis>;
5272 &#32;&#32;&#32;&#32;__testlib_print_one(b);
5273 &#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;<emphasis role="stringliteral">&quot;&#32;&quot;</emphasis>;
5274 &#32;&#32;&#32;&#32;__testlib_print_one(c);
5275 &#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;<emphasis role="stringliteral">&quot;&#32;&quot;</emphasis>;
5276 &#32;&#32;&#32;&#32;__testlib_print_one(d);
5277 &#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;<emphasis role="stringliteral">&quot;&#32;&quot;</emphasis>;
5278 &#32;&#32;&#32;&#32;__testlib_print_one(e);
5279 &#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;<emphasis role="stringliteral">&quot;&#32;&quot;</emphasis>;
5280 &#32;&#32;&#32;&#32;__testlib_print_one(f);
5281 &#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;<emphasis role="stringliteral">&quot;&#32;&quot;</emphasis>;
5282 &#32;&#32;&#32;&#32;__testlib_print_one(g);
5283 &#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;std::endl;
5284 }
5285 
5286 <emphasis role="comment">/*&#32;opts&#32;*/</emphasis>
5287 
5292 <emphasis role="keyword">struct&#32;</emphasis>TestlibOpt&#32;{
5293 &#32;&#32;&#32;&#32;std::string&#32;value;
5294 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;used;
5295 
5296 &#32;&#32;&#32;&#32;TestlibOpt()&#32;:&#32;value(),&#32;used(false)&#32;{}
5297 };
5298 
5312 <emphasis role="keywordtype">size_t</emphasis>&#32;getOptType(<emphasis role="keywordtype">char</emphasis>&#32;*s)&#32;{
5313 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!s&#32;||&#32;strlen(s)&#32;&lt;=&#32;1)
5314 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;0;
5315 
5316 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(s[0]&#32;==&#32;<emphasis role="charliteral">&apos;-&apos;</emphasis>)&#32;{
5317 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(isalpha(s[1]))
5318 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;1;
5319 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="keywordflow">if</emphasis>&#32;(s[1]&#32;==&#32;<emphasis role="charliteral">&apos;-&apos;</emphasis>)
5320 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;isalpha(s[2])&#32;?&#32;2&#32;:&#32;0;
5321 &#32;&#32;&#32;&#32;}
5322 
5323 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;0;
5324 }
5325 
5355 <emphasis role="keywordtype">size_t</emphasis>&#32;parseOpt(<emphasis role="keywordtype">size_t</emphasis>&#32;argc,&#32;<emphasis role="keywordtype">char</emphasis>&#32;*argv[],&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;index,&#32;std::map&lt;std::string,&#32;TestlibOpt&gt;&#32;&amp;opts)&#32;{
5356 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(index&#32;&gt;=&#32;argc)
5357 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;0;
5358 
5359 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;type&#32;=&#32;getOptType(argv[index]),&#32;inc&#32;=&#32;1;
5360 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(type&#32;&gt;&#32;0)&#32;{
5361 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::string&#32;key(argv[index]&#32;+&#32;type),&#32;val;
5362 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;sep&#32;=&#32;key.find(<emphasis role="charliteral">&apos;=&apos;</emphasis>);
5363 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(sep&#32;!=&#32;std::string::npos)&#32;{
5364 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;val&#32;=&#32;key.substr(sep&#32;+&#32;1);
5365 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;key&#32;=&#32;key.substr(0,&#32;sep);
5366 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
5367 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(index&#32;+&#32;1&#32;&lt;&#32;argc&#32;&amp;&amp;&#32;getOptType(argv[index&#32;+&#32;1])&#32;==&#32;0)&#32;{
5368 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;val&#32;=&#32;argv[index&#32;+&#32;1];
5369 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;inc&#32;=&#32;2;
5370 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
5371 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(key.length()&#32;&gt;&#32;1&#32;&amp;&amp;&#32;isdigit(key[1]))&#32;{
5372 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;val&#32;=&#32;key.substr(1);
5373 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;key&#32;=&#32;key.substr(0,&#32;1);
5374 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
5375 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;val&#32;=&#32;<emphasis role="stringliteral">&quot;true&quot;</emphasis>;
5376 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
5377 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
5378 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
5379 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;opts[key].value&#32;=&#32;val;
5380 &#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
5381 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;inc;
5382 &#32;&#32;&#32;&#32;}
5383 
5384 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;inc;
5385 }
5386 
5390 std::vector&lt;std::string&gt;&#32;__testlib_argv;
5391 
5395 std::map&lt;std::string,&#32;TestlibOpt&gt;&#32;__testlib_opts;
5396 
5404 <emphasis role="keywordtype">bool</emphasis>&#32;__testlib_ensureNoUnusedOptsFlag&#32;=&#32;<emphasis role="keyword">false</emphasis>;
5405 
5410 <emphasis role="keywordtype">bool</emphasis>&#32;__testlib_ensureNoUnusedOptsSuppressed&#32;=&#32;<emphasis role="keyword">false</emphasis>;
5411 
5416 <emphasis role="keywordtype">void</emphasis>&#32;prepareOpts(<emphasis role="keywordtype">int</emphasis>&#32;argc,&#32;<emphasis role="keywordtype">char</emphasis>&#32;*argv[])&#32;{
5417 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(argc&#32;&lt;=&#32;0)
5418 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;Opts:&#32;expected&#32;argc&gt;=0&#32;but&#32;found&#32;&quot;</emphasis>&#32;+&#32;toString(argc));
5419 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;n&#32;=&#32;<emphasis role="keyword">static_cast&lt;</emphasis><emphasis role="keywordtype">size_t</emphasis><emphasis role="keyword">&gt;</emphasis>(argc);&#32;<emphasis role="comment">//&#32;NOLINT(hicpp-use-auto,modernize-use-auto)</emphasis>
5420 &#32;&#32;&#32;&#32;__testlib_opts&#32;=&#32;std::map&lt;std::string,&#32;TestlibOpt&gt;();
5421 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">size_t</emphasis>&#32;index&#32;=&#32;1;&#32;index&#32;&lt;&#32;n;&#32;index&#32;+=&#32;parseOpt(n,&#32;argv,&#32;index,&#32;__testlib_opts));
5422 &#32;&#32;&#32;&#32;__testlib_argv&#32;=&#32;std::vector&lt;std::string&gt;(n);
5423 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">size_t</emphasis>&#32;index&#32;=&#32;0;&#32;index&#32;&lt;&#32;n;&#32;index++)
5424 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_argv[index]&#32;=&#32;argv[index];
5425 }
5426 
5431 std::string&#32;__testlib_indexToArgv(<emphasis role="keywordtype">int</emphasis>&#32;index)&#32;{
5432 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(index&#32;&lt;&#32;0&#32;||&#32;index&#32;&gt;=&#32;<emphasis role="keywordtype">int</emphasis>(__testlib_argv.size()))
5433 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;Opts:&#32;index&#32;&apos;&quot;</emphasis>&#32;+&#32;toString(index)&#32;+&#32;<emphasis role="stringliteral">&quot;&apos;&#32;is&#32;out&#32;of&#32;range&#32;[0,&quot;</emphasis>
5434 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;+&#32;toString(__testlib_argv.size())&#32;+&#32;<emphasis role="stringliteral">&quot;)&quot;</emphasis>);
5435 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__testlib_argv[size_t(index)];
5436 }
5437 
5442 std::string&#32;__testlib_keyToOpts(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;key)&#32;{
5443 &#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;it&#32;=&#32;__testlib_opts.find(key);
5444 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(it&#32;==&#32;__testlib_opts.end())
5445 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;Opts:&#32;unknown&#32;key&#32;&apos;&quot;</emphasis>&#32;+&#32;compress(key)&#32;+&#32;<emphasis role="stringliteral">&quot;&apos;&quot;</emphasis>);
5446 &#32;&#32;&#32;&#32;it-&gt;second.used&#32;=&#32;<emphasis role="keyword">true</emphasis>;
5447 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;it-&gt;second.value;
5448 }
5449 
5450 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Tp&gt;
5451 _Tp&#32;optValueToIntegral(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;s,&#32;<emphasis role="keywordtype">bool</emphasis>&#32;nonnegative);
5452 
5453 <emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">double</emphasis>&#32;optValueToLongDouble(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;s);
5454 
5455 std::string&#32;parseExponentialOptValue(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;s)&#32;{
5456 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;pos&#32;=&#32;std::string::npos;
5457 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">size_t</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;s.length();&#32;i++)
5458 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(s[i]&#32;==&#32;<emphasis role="charliteral">&apos;e&apos;</emphasis>&#32;||&#32;s[i]&#32;==&#32;<emphasis role="charliteral">&apos;E&apos;</emphasis>)&#32;{
5459 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(pos&#32;!=&#32;std::string::npos)
5460 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;Opts:&#32;expected&#32;typical&#32;exponential&#32;notation&#32;but&#32;&apos;&quot;</emphasis>&#32;+&#32;compress(s)&#32;+&#32;<emphasis role="stringliteral">&quot;&apos;&#32;found&quot;</emphasis>);
5461 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;pos&#32;=&#32;i;
5462 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
5463 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(pos&#32;==&#32;std::string::npos)
5464 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;s;
5465 &#32;&#32;&#32;&#32;std::string&#32;e&#32;=&#32;s.substr(pos&#32;+&#32;1);
5466 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!e.empty()&#32;&amp;&amp;&#32;e[0]&#32;==&#32;<emphasis role="charliteral">&apos;+&apos;</emphasis>)
5467 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;e&#32;=&#32;e.substr(1);
5468 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(e.empty())
5469 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;Opts:&#32;expected&#32;typical&#32;exponential&#32;notation&#32;but&#32;&apos;&quot;</emphasis>&#32;+&#32;compress(s)&#32;+&#32;<emphasis role="stringliteral">&quot;&apos;&#32;found&quot;</emphasis>);
5470 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(e.length()&#32;&gt;&#32;20)
5471 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;Opts:&#32;expected&#32;typical&#32;exponential&#32;notation&#32;but&#32;&apos;&quot;</emphasis>&#32;+&#32;compress(s)&#32;+&#32;<emphasis role="stringliteral">&quot;&apos;&#32;found&quot;</emphasis>);
5472 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;ne&#32;=&#32;optValueToIntegral&lt;int&gt;(e,&#32;<emphasis role="keyword">false</emphasis>);
5473 &#32;&#32;&#32;&#32;std::string&#32;num&#32;=&#32;s.substr(0,&#32;pos);
5474 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(num.length()&#32;&gt;&#32;20)
5475 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;Opts:&#32;expected&#32;typical&#32;exponential&#32;notation&#32;but&#32;&apos;&quot;</emphasis>&#32;+&#32;compress(s)&#32;+&#32;<emphasis role="stringliteral">&quot;&apos;&#32;found&quot;</emphasis>);
5476 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!num.empty()&#32;&amp;&amp;&#32;num[0]&#32;==&#32;<emphasis role="charliteral">&apos;+&apos;</emphasis>)
5477 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;num&#32;=&#32;num.substr(1);
5478 &#32;&#32;&#32;&#32;optValueToLongDouble(num);
5479 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;minus&#32;=&#32;<emphasis role="keyword">false</emphasis>;
5480 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(num[0]&#32;==&#32;<emphasis role="charliteral">&apos;-&apos;</emphasis>)&#32;{
5481 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;minus&#32;=&#32;<emphasis role="keyword">true</emphasis>;
5482 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;num&#32;=&#32;num.substr(1);
5483 &#32;&#32;&#32;&#32;}
5484 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">int</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;+ne;&#32;i++)&#32;{
5485 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;sep&#32;=&#32;num.find(<emphasis role="charliteral">&apos;.&apos;</emphasis>);
5486 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(sep&#32;==&#32;std::string::npos)
5487 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;num&#32;+=&#32;<emphasis role="charliteral">&apos;0&apos;</emphasis>;
5488 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
5489 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(sep&#32;+&#32;1&#32;==&#32;num.length())
5490 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;num[sep]&#32;=&#32;<emphasis role="charliteral">&apos;0&apos;</emphasis>;
5491 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
5492 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::swap(num[sep],&#32;num[sep&#32;+&#32;1]);
5493 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
5494 &#32;&#32;&#32;&#32;}
5495 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">int</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;-ne;&#32;i++)&#32;{
5496 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;sep&#32;=&#32;num.find(<emphasis role="charliteral">&apos;.&apos;</emphasis>);
5497 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(sep&#32;==&#32;std::string::npos)
5498 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;num.insert(num.begin()&#32;+&#32;<emphasis role="keywordtype">int</emphasis>(num.length())&#32;-&#32;1,&#32;<emphasis role="charliteral">&apos;.&apos;</emphasis>);
5499 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
5500 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(sep&#32;==&#32;0)
5501 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;num.insert(num.begin()&#32;+&#32;1,&#32;<emphasis role="charliteral">&apos;0&apos;</emphasis>);
5502 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
5503 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::swap(num[sep&#32;-&#32;1],&#32;num[sep]);
5504 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
5505 &#32;&#32;&#32;&#32;}
5506 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">while</emphasis>&#32;(!num.empty()&#32;&amp;&amp;&#32;num[0]&#32;==&#32;<emphasis role="charliteral">&apos;0&apos;</emphasis>)
5507 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;num&#32;=&#32;num.substr(1);
5508 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">while</emphasis>&#32;(num.find(<emphasis role="charliteral">&apos;.&apos;</emphasis>)&#32;!=&#32;std::string::npos&#32;&amp;&amp;&#32;num.back()&#32;==&#32;<emphasis role="charliteral">&apos;0&apos;</emphasis>)
5509 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;num&#32;=&#32;num.substr(0,&#32;num.length()&#32;-&#32;1);
5510 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!num.empty()&#32;&amp;&amp;&#32;num.back()&#32;==&#32;<emphasis role="charliteral">&apos;.&apos;</emphasis>)
5511 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;num&#32;=&#32;num.substr(0,&#32;num.length()&#32;-&#32;1);
5512 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;((!num.empty()&#32;&amp;&amp;&#32;num[0]&#32;==&#32;<emphasis role="charliteral">&apos;.&apos;</emphasis>)&#32;||&#32;num.empty())
5513 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;num.insert(num.begin(),&#32;<emphasis role="charliteral">&apos;0&apos;</emphasis>);
5514 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;(minus&#32;?&#32;<emphasis role="stringliteral">&quot;-&quot;</emphasis>&#32;:&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>)&#32;+&#32;num;
5515 }
5516 
5517 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Tp&gt;
5518 _Tp&#32;optValueToIntegral(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;s_,&#32;<emphasis role="keywordtype">bool</emphasis>&#32;nonnegative)&#32;{
5519 &#32;&#32;&#32;&#32;std::string&#32;s(parseExponentialOptValue(s_));
5520 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(s.empty())
5521 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;Opts:&#32;expected&#32;integer&#32;but&#32;&apos;&quot;</emphasis>&#32;+&#32;compress(s_)&#32;+&#32;<emphasis role="stringliteral">&quot;&apos;&#32;found&quot;</emphasis>);
5522 &#32;&#32;&#32;&#32;_Tp&#32;value&#32;=&#32;0;
5523 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">double</emphasis>&#32;about&#32;=&#32;0.0;
5524 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">signed</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;sign&#32;=&#32;+1;
5525 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;pos&#32;=&#32;0;
5526 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(s[pos]&#32;==&#32;<emphasis role="charliteral">&apos;-&apos;</emphasis>)&#32;{
5527 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(nonnegative)
5528 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;Opts:&#32;expected&#32;non-negative&#32;integer&#32;but&#32;&apos;&quot;</emphasis>&#32;+&#32;compress(s_)&#32;+&#32;<emphasis role="stringliteral">&quot;&apos;&#32;found&quot;</emphasis>);
5529 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;sign&#32;=&#32;-1;
5530 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;pos++;
5531 &#32;&#32;&#32;&#32;}
5532 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">size_t</emphasis>&#32;i&#32;=&#32;pos;&#32;i&#32;&lt;&#32;s.length();&#32;i++)&#32;{
5533 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(s[i]&#32;&lt;&#32;<emphasis role="charliteral">&apos;0&apos;</emphasis>&#32;||&#32;s[i]&#32;&gt;&#32;<emphasis role="charliteral">&apos;9&apos;</emphasis>)
5534 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;Opts:&#32;expected&#32;integer&#32;but&#32;&apos;&quot;</emphasis>&#32;+&#32;compress(s_)&#32;+&#32;<emphasis role="stringliteral">&quot;&apos;&#32;found&quot;</emphasis>);
5535 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;value&#32;=&#32;_Tp(value&#32;*&#32;10&#32;+&#32;s[i]&#32;-&#32;<emphasis role="charliteral">&apos;0&apos;</emphasis>);
5536 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;about&#32;=&#32;about&#32;*&#32;10&#32;+&#32;s[i]&#32;-&#32;<emphasis role="charliteral">&apos;0&apos;</emphasis>;
5537 &#32;&#32;&#32;&#32;}
5538 &#32;&#32;&#32;&#32;value&#32;*=&#32;sign;
5539 &#32;&#32;&#32;&#32;about&#32;*=&#32;sign;
5540 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(fabsl(value&#32;-&#32;about)&#32;&gt;&#32;0.1)
5541 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;Opts:&#32;integer&#32;overflow:&#32;expected&#32;integer&#32;but&#32;&apos;&quot;</emphasis>&#32;+&#32;compress(s_)&#32;+&#32;<emphasis role="stringliteral">&quot;&apos;&#32;found&quot;</emphasis>);
5542 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;value;
5543 }
5544 
5545 <emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">double</emphasis>&#32;optValueToLongDouble(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;s_)&#32;{
5546 &#32;&#32;&#32;&#32;std::string&#32;s(parseExponentialOptValue(s_));
5547 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(s.empty())
5548 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;Opts:&#32;expected&#32;float&#32;number&#32;but&#32;&apos;&quot;</emphasis>&#32;+&#32;compress(s_)&#32;+&#32;<emphasis role="stringliteral">&quot;&apos;&#32;found&quot;</emphasis>);
5549 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">double</emphasis>&#32;value&#32;=&#32;0.0;
5550 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">signed</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;sign&#32;=&#32;+1;
5551 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;pos&#32;=&#32;0;
5552 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(s[pos]&#32;==&#32;<emphasis role="charliteral">&apos;-&apos;</emphasis>)&#32;{
5553 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;sign&#32;=&#32;-1;
5554 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;pos++;
5555 &#32;&#32;&#32;&#32;}
5556 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;period&#32;=&#32;<emphasis role="keyword">false</emphasis>;
5557 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">double</emphasis>&#32;mul&#32;=&#32;1.0;
5558 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">size_t</emphasis>&#32;i&#32;=&#32;pos;&#32;i&#32;&lt;&#32;s.length();&#32;i++)&#32;{
5559 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(s[i]&#32;==&#32;<emphasis role="charliteral">&apos;.&apos;</emphasis>)&#32;{
5560 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(period)
5561 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;Opts:&#32;expected&#32;float&#32;number&#32;but&#32;&apos;&quot;</emphasis>&#32;+&#32;compress(s_)&#32;+&#32;<emphasis role="stringliteral">&quot;&apos;&#32;found&quot;</emphasis>);
5562 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
5563 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;period&#32;=&#32;<emphasis role="keyword">true</emphasis>;
5564 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">continue</emphasis>;
5565 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
5566 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
5567 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(period)
5568 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;mul&#32;*=&#32;10.0;
5569 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(s[i]&#32;&lt;&#32;<emphasis role="charliteral">&apos;0&apos;</emphasis>&#32;||&#32;s[i]&#32;&gt;&#32;<emphasis role="charliteral">&apos;9&apos;</emphasis>)
5570 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;Opts:&#32;expected&#32;float&#32;number&#32;but&#32;&apos;&quot;</emphasis>&#32;+&#32;compress(s_)&#32;+&#32;<emphasis role="stringliteral">&quot;&apos;&#32;found&quot;</emphasis>);
5571 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(period)
5572 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;value&#32;+=&#32;(s[i]&#32;-&#32;<emphasis role="charliteral">&apos;0&apos;</emphasis>)&#32;/&#32;mul;
5573 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
5574 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;value&#32;=&#32;value&#32;*&#32;10&#32;+&#32;s[i]&#32;-&#32;<emphasis role="charliteral">&apos;0&apos;</emphasis>;
5575 &#32;&#32;&#32;&#32;}
5576 &#32;&#32;&#32;&#32;value&#32;*=&#32;sign;
5577 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;value;
5578 }
5579 
5587 <emphasis role="keywordtype">bool</emphasis>&#32;has_opt(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;key)&#32;{
5588 &#32;&#32;&#32;&#32;__testlib_ensureNoUnusedOptsFlag&#32;=&#32;<emphasis role="keyword">true</emphasis>;
5589 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__testlib_opts.count(key)&#32;!=&#32;0;
5590 }
5591 
5592 <emphasis role="comment">/*&#32;About&#32;the&#32;following&#32;part&#32;for&#32;opt&#32;with&#32;2&#32;and&#32;3&#32;arguments.</emphasis>
5593 <emphasis role="comment">&#32;*&#32;</emphasis>
5594 <emphasis role="comment">&#32;*&#32;To&#32;parse&#32;the&#32;argv/opts&#32;correctly&#32;for&#32;a&#32;give&#32;type&#32;(integer,&#32;floating&#32;point&#32;or</emphasis>
5595 <emphasis role="comment">&#32;*&#32;string),&#32;some&#32;meta&#32;programming&#32;must&#32;be&#32;done&#32;to&#32;determine&#32;the&#32;type&#32;of</emphasis>
5596 <emphasis role="comment">&#32;*&#32;the&#32;type,&#32;and&#32;use&#32;the&#32;correct&#32;parsing&#32;function&#32;accordingly.</emphasis>
5597 <emphasis role="comment">&#32;*&#32;</emphasis>
5598 <emphasis role="comment">&#32;*&#32;The&#32;pseudo&#32;algorithm&#32;for&#32;determining&#32;the&#32;type&#32;of&#32;T&#32;and&#32;parse&#32;it&#32;accordingly</emphasis>
5599 <emphasis role="comment">&#32;*&#32;is&#32;as&#32;follows:</emphasis>
5600 <emphasis role="comment">&#32;*&#32;</emphasis>
5601 <emphasis role="comment">&#32;*&#32;if&#32;(T&#32;is&#32;integral&#32;type)&#32;{</emphasis>
5602 <emphasis role="comment">&#32;*&#32;&#32;&#32;if&#32;(T&#32;is&#32;unsigned)&#32;{</emphasis>
5603 <emphasis role="comment">&#32;*&#32;&#32;&#32;&#32;&#32;parse&#32;the&#32;argv/opt&#32;as&#32;an&#32;**unsigned&#32;integer**&#32;of&#32;type&#32;T.</emphasis>
5604 <emphasis role="comment">&#32;*&#32;&#32;&#32;}&#32;else&#32;{</emphasis>
5605 <emphasis role="comment">&#32;*&#32;&#32;&#32;&#32;&#32;parse&#32;the&#32;argv/opt&#32;as&#32;an&#32;**signed&#32;integer**&#32;of&#32;type&#32;T.</emphasis>
5606 <emphasis role="comment">&#32;*&#32;}&#32;else&#32;{</emphasis>
5607 <emphasis role="comment">&#32;*&#32;&#32;&#32;if&#32;(T&#32;is&#32;floating&#32;point&#32;type)&#32;{</emphasis>
5608 <emphasis role="comment">&#32;*&#32;&#32;&#32;&#32;&#32;parse&#32;the&#32;argv/opt&#32;as&#32;an&#32;**floating&#32;point**&#32;of&#32;type&#32;T.</emphasis>
5609 <emphasis role="comment">&#32;*&#32;&#32;&#32;}&#32;else&#32;{</emphasis>
5610 <emphasis role="comment">&#32;*&#32;&#32;&#32;&#32;&#32;//&#32;T&#32;should&#32;be&#32;std::string</emphasis>
5611 <emphasis role="comment">&#32;*&#32;&#32;&#32;&#32;&#32;just&#32;the&#32;raw&#32;content&#32;of&#32;the&#32;argv/opts.</emphasis>
5612 <emphasis role="comment">&#32;*&#32;&#32;&#32;}</emphasis>
5613 <emphasis role="comment">&#32;*&#32;}</emphasis>
5614 <emphasis role="comment">&#32;*&#32;</emphasis>
5615 <emphasis role="comment">&#32;*&#32;To&#32;help&#32;with&#32;meta&#32;programming,&#32;some&#32;`opt`&#32;function&#32;with&#32;2&#32;or&#32;3&#32;arguments&#32;are</emphasis>
5616 <emphasis role="comment">&#32;*&#32;defined.</emphasis>
5617 <emphasis role="comment">&#32;*&#32;</emphasis>
5618 <emphasis role="comment">&#32;*&#32;Opt&#32;with&#32;3&#32;arguments:&#32;&#32;&#32;&#32;T&#32;opt(true/false&#32;is_integral,&#32;true/false&#32;is_unsigned,&#32;index/key)</emphasis>
5619 <emphasis role="comment">&#32;*&#32;</emphasis>
5620 <emphasis role="comment">&#32;*&#32;&#32;&#32;+&#32;The&#32;first&#32;argument&#32;is&#32;for&#32;determining&#32;whether&#32;the&#32;type&#32;T&#32;is&#32;an&#32;integral</emphasis>
5621 <emphasis role="comment">&#32;*&#32;&#32;&#32;type.&#32;That&#32;is,&#32;the&#32;result&#32;of&#32;std::is_integral&lt;T&gt;()&#32;should&#32;be&#32;passed&#32;to</emphasis>
5622 <emphasis role="comment">&#32;*&#32;&#32;&#32;this&#32;argument.&#32;When&#32;false,&#32;the&#32;type&#32;_should_&#32;be&#32;either&#32;floating&#32;point&#32;or&#32;a</emphasis>
5623 <emphasis role="comment">&#32;*&#32;&#32;&#32;std::string.</emphasis>
5624 <emphasis role="comment">&#32;*&#32;&#32;&#32;</emphasis>
5625 <emphasis role="comment">&#32;*&#32;&#32;&#32;+&#32;The&#32;second&#32;argument&#32;is&#32;for&#32;determining&#32;whether&#32;the&#32;signedness&#32;of&#32;the&#32;type</emphasis>
5626 <emphasis role="comment">&#32;*&#32;&#32;&#32;T&#32;(if&#32;it&#32;is&#32;unsigned&#32;or&#32;signed).&#32;That&#32;is,&#32;the&#32;result&#32;of</emphasis>
5627 <emphasis role="comment">&#32;*&#32;&#32;&#32;std::is_unsigned&lt;T&gt;()&#32;should&#32;be&#32;passed&#32;to&#32;this&#32;argument.&#32;This&#32;argument&#32;can</emphasis>
5628 <emphasis role="comment">&#32;*&#32;&#32;&#32;be&#32;ignored&#32;if&#32;the&#32;first&#32;one&#32;is&#32;false,&#32;because&#32;it&#32;only&#32;applies&#32;to&#32;integer.</emphasis>
5629 <emphasis role="comment">&#32;*</emphasis>
5630 <emphasis role="comment">&#32;*&#32;Opt&#32;with&#32;2&#32;arguments:&#32;&#32;&#32;&#32;T&#32;opt(true/false&#32;is_floating_point,&#32;index/key)</emphasis>
5631 <emphasis role="comment">&#32;*&#32;&#32;&#32;+&#32;The&#32;first&#32;argument&#32;is&#32;for&#32;determining&#32;whether&#32;the&#32;type&#32;T&#32;is&#32;a&#32;floating</emphasis>
5632 <emphasis role="comment">&#32;*&#32;&#32;&#32;point&#32;type.&#32;That&#32;is,&#32;the&#32;result&#32;of&#32;std::is_floating_point&lt;T&gt;()&#32;should&#32;be</emphasis>
5633 <emphasis role="comment">&#32;*&#32;&#32;&#32;passed&#32;to&#32;this&#32;argument.&#32;When&#32;false,&#32;the&#32;type&#32;_should_&#32;be&#32;a&#32;std::string.</emphasis>
5634 <emphasis role="comment">&#32;*/</emphasis>
5635 
5636 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Tp&gt;
5637 _Tp&#32;opt(std::false_type&#32;is_floating_point,&#32;<emphasis role="keywordtype">int</emphasis>&#32;index);
5638 
5639 <emphasis role="keyword">template</emphasis>&lt;&gt;
5640 std::string&#32;opt(std::false_type&#32;<emphasis role="comment">/*is_floating_point*/</emphasis>,&#32;<emphasis role="keywordtype">int</emphasis>&#32;index)&#32;{
5641 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__testlib_indexToArgv(index);
5642 }
5643 
5644 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Tp&gt;
5645 _Tp&#32;opt(std::true_type&#32;<emphasis role="comment">/*is_floating_point*/</emphasis>,&#32;<emphasis role="keywordtype">int</emphasis>&#32;index)&#32;{
5646 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;_Tp(optValueToLongDouble(__testlib_indexToArgv(index)));
5647 }
5648 
5649 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Tp,&#32;<emphasis role="keyword">typename</emphasis>&#32;U&gt;
5650 _Tp&#32;opt(std::false_type&#32;<emphasis role="comment">/*is_integral*/</emphasis>,&#32;U&#32;<emphasis role="comment">/*is_unsigned*/</emphasis>,&#32;<emphasis role="keywordtype">int</emphasis>&#32;index)&#32;{
5651 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;opt&lt;_Tp&gt;(std::is_floating_point&lt;_Tp&gt;(),&#32;index);
5652 }
5653 
5654 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Tp&gt;
5655 _Tp&#32;opt(std::true_type&#32;<emphasis role="comment">/*is_integral*/</emphasis>,&#32;std::false_type&#32;<emphasis role="comment">/*is_unsigned*/</emphasis>,&#32;<emphasis role="keywordtype">int</emphasis>&#32;index)&#32;{
5656 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;optValueToIntegral&lt;_Tp&gt;(__testlib_indexToArgv(index),&#32;<emphasis role="keyword">false</emphasis>);
5657 }
5658 
5659 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Tp&gt;
5660 _Tp&#32;opt(std::true_type&#32;<emphasis role="comment">/*is_integral*/</emphasis>,&#32;std::true_type&#32;<emphasis role="comment">/*is_unsigned*/</emphasis>,&#32;<emphasis role="keywordtype">int</emphasis>&#32;index)&#32;{
5661 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;optValueToIntegral&lt;_Tp&gt;(__testlib_indexToArgv(index),&#32;<emphasis role="keyword">true</emphasis>);
5662 }
5663 
5664 <emphasis role="keyword">template</emphasis>&lt;&gt;
5665 <emphasis role="keywordtype">bool</emphasis>&#32;opt(std::true_type&#32;<emphasis role="comment">/*is_integral*/</emphasis>,&#32;std::true_type&#32;<emphasis role="comment">/*is_unsigned*/</emphasis>,&#32;<emphasis role="keywordtype">int</emphasis>&#32;index)&#32;{
5666 &#32;&#32;&#32;&#32;std::string&#32;value&#32;=&#32;__testlib_indexToArgv(index);
5667 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(value&#32;==&#32;<emphasis role="stringliteral">&quot;true&quot;</emphasis>&#32;||&#32;value&#32;==&#32;<emphasis role="stringliteral">&quot;1&quot;</emphasis>)
5668 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">true</emphasis>;
5669 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(value&#32;==&#32;<emphasis role="stringliteral">&quot;false&quot;</emphasis>&#32;||&#32;value&#32;==&#32;<emphasis role="stringliteral">&quot;0&quot;</emphasis>)
5670 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
5671 &#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;Opts:&#32;opt&#32;by&#32;index&#32;&apos;&quot;</emphasis>&#32;+&#32;toString(index)&#32;+&#32;<emphasis role="stringliteral">&quot;&apos;:&#32;expected&#32;bool&#32;true/false&#32;or&#32;0/1&#32;but&#32;&apos;&quot;</emphasis>
5672 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;+&#32;compress(value)&#32;+&#32;<emphasis role="stringliteral">&quot;&apos;&#32;found&quot;</emphasis>);
5673 }
5674 
5678 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Tp&gt;
5679 _Tp&#32;opt(<emphasis role="keywordtype">int</emphasis>&#32;index)&#32;{
5680 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;opt&lt;_Tp&gt;(std::is_integral&lt;_Tp&gt;(),&#32;std::is_unsigned&lt;_Tp&gt;(),&#32;index);
5681 }
5682 
5686 std::string&#32;opt(<emphasis role="keywordtype">int</emphasis>&#32;index)&#32;{
5687 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;opt&lt;std::string&gt;(index);
5688 }
5689 
5694 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Tp&gt;
5695 _Tp&#32;opt(<emphasis role="keywordtype">int</emphasis>&#32;index,&#32;<emphasis role="keyword">const</emphasis>&#32;_Tp&#32;&amp;default_value)&#32;{
5696 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(index&#32;&gt;=&#32;<emphasis role="keywordtype">int</emphasis>(__testlib_argv.size()))&#32;{
5697 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;default_value;
5698 &#32;&#32;&#32;&#32;}
5699 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;opt&lt;_Tp&gt;(index);
5700 }
5701 
5706 std::string&#32;opt(<emphasis role="keywordtype">int</emphasis>&#32;index,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;default_value)&#32;{
5707 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;opt&lt;std::string&gt;(index,&#32;default_value);
5708 }
5709 
5710 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Tp&gt;
5711 _Tp&#32;opt(std::false_type&#32;is_floating_point,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;key);
5712 
5713 <emphasis role="keyword">template</emphasis>&lt;&gt;
5714 std::string&#32;opt(std::false_type&#32;<emphasis role="comment">/*is_floating_point*/</emphasis>,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;key)&#32;{
5715 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__testlib_keyToOpts(key);
5716 }
5717 
5718 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Tp&gt;
5719 _Tp&#32;opt(std::true_type&#32;<emphasis role="comment">/*is_integral*/</emphasis>,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;key)&#32;{
5720 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;_Tp(optValueToLongDouble(__testlib_keyToOpts(key)));
5721 }
5722 
5723 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Tp,&#32;<emphasis role="keyword">typename</emphasis>&#32;U&gt;
5724 _Tp&#32;opt(std::false_type&#32;<emphasis role="comment">/*is_integral*/</emphasis>,&#32;U,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;key)&#32;{
5725 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;opt&lt;_Tp&gt;(std::is_floating_point&lt;_Tp&gt;(),&#32;key);
5726 }
5727 
5728 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Tp&gt;
5729 _Tp&#32;opt(std::true_type&#32;<emphasis role="comment">/*is_integral*/</emphasis>,&#32;std::false_type&#32;<emphasis role="comment">/*is_unsigned*/</emphasis>,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;key)&#32;{
5730 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;optValueToIntegral&lt;_Tp&gt;(__testlib_keyToOpts(key),&#32;<emphasis role="keyword">false</emphasis>);
5731 }
5732 
5733 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Tp&gt;
5734 _Tp&#32;opt(std::true_type&#32;<emphasis role="comment">/*is_integral*/</emphasis>,&#32;std::true_type&#32;<emphasis role="comment">/*is_unsigned*/</emphasis>,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;key)&#32;{
5735 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;optValueToIntegral&lt;_Tp&gt;(__testlib_keyToOpts(key),&#32;<emphasis role="keyword">true</emphasis>);
5736 }
5737 
5738 <emphasis role="keyword">template</emphasis>&lt;&gt;
5739 <emphasis role="keywordtype">bool</emphasis>&#32;opt(std::true_type&#32;<emphasis role="comment">/*is_integral*/</emphasis>,&#32;std::true_type&#32;<emphasis role="comment">/*is_unsigned*/</emphasis>,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;key)&#32;{
5740 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!has_opt(key))
5741 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
5742 &#32;&#32;&#32;&#32;std::string&#32;value&#32;=&#32;__testlib_keyToOpts(key);
5743 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(value&#32;==&#32;<emphasis role="stringliteral">&quot;true&quot;</emphasis>&#32;||&#32;value&#32;==&#32;<emphasis role="stringliteral">&quot;1&quot;</emphasis>)
5744 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">true</emphasis>;
5745 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(value&#32;==&#32;<emphasis role="stringliteral">&quot;false&quot;</emphasis>&#32;||&#32;value&#32;==&#32;<emphasis role="stringliteral">&quot;0&quot;</emphasis>)
5746 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
5747 &#32;&#32;&#32;&#32;__testlib_fail(<emphasis role="stringliteral">&quot;Opts:&#32;key&#32;&apos;&quot;</emphasis>&#32;+&#32;compress(key)&#32;+&#32;<emphasis role="stringliteral">&quot;&apos;:&#32;expected&#32;bool&#32;true/false&#32;or&#32;0/1&#32;but&#32;&apos;&quot;</emphasis>
5748 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;+&#32;compress(value)&#32;+&#32;<emphasis role="stringliteral">&quot;&apos;&#32;found&quot;</emphasis>);
5749 }
5750 
5754 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Tp&gt;
5755 _Tp&#32;opt(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;key)&#32;{
5756 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;opt&lt;_Tp&gt;(std::is_integral&lt;_Tp&gt;(),&#32;std::is_unsigned&lt;_Tp&gt;(),&#32;key);
5757 }
5758 
5762 std::string&#32;opt(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;key)&#32;{
5763 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;opt&lt;std::string&gt;(key);
5764 }
5765 
5766 <emphasis role="comment">/*&#32;Scorer&#32;started.&#32;*/</emphasis>
5767 
5768 <emphasis role="keyword">enum</emphasis>&#32;TestResultVerdict&#32;{
5769 &#32;&#32;&#32;&#32;SKIPPED,
5770 &#32;&#32;&#32;&#32;OK,
5771 &#32;&#32;&#32;&#32;WRONG_ANSWER,
5772 &#32;&#32;&#32;&#32;RUNTIME_ERROR,
5773 &#32;&#32;&#32;&#32;TIME_LIMIT_EXCEEDED,
5774 &#32;&#32;&#32;&#32;IDLENESS_LIMIT_EXCEEDED,
5775 &#32;&#32;&#32;&#32;MEMORY_LIMIT_EXCEEDED,
5776 &#32;&#32;&#32;&#32;COMPILATION_ERROR,
5777 &#32;&#32;&#32;&#32;CRASHED,
5778 &#32;&#32;&#32;&#32;FAILED
5779 };
5780 
5781 std::string&#32;serializeVerdict(TestResultVerdict&#32;verdict)&#32;{
5782 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">switch</emphasis>&#32;(verdict)&#32;{
5783 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">case</emphasis>&#32;SKIPPED:&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="stringliteral">&quot;SKIPPED&quot;</emphasis>;
5784 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">case</emphasis>&#32;OK:&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="stringliteral">&quot;OK&quot;</emphasis>;
5785 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">case</emphasis>&#32;WRONG_ANSWER:&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="stringliteral">&quot;WRONG_ANSWER&quot;</emphasis>;
5786 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">case</emphasis>&#32;RUNTIME_ERROR:&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="stringliteral">&quot;RUNTIME_ERROR&quot;</emphasis>;
5787 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">case</emphasis>&#32;TIME_LIMIT_EXCEEDED:&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="stringliteral">&quot;TIME_LIMIT_EXCEEDED&quot;</emphasis>;
5788 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">case</emphasis>&#32;IDLENESS_LIMIT_EXCEEDED:&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="stringliteral">&quot;IDLENESS_LIMIT_EXCEEDED&quot;</emphasis>;
5789 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">case</emphasis>&#32;MEMORY_LIMIT_EXCEEDED:&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="stringliteral">&quot;MEMORY_LIMIT_EXCEEDED&quot;</emphasis>;
5790 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">case</emphasis>&#32;COMPILATION_ERROR:&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="stringliteral">&quot;COMPILATION_ERROR&quot;</emphasis>;
5791 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">case</emphasis>&#32;CRASHED:&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="stringliteral">&quot;CRASHED&quot;</emphasis>;
5792 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">case</emphasis>&#32;FAILED:&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="stringliteral">&quot;FAILED&quot;</emphasis>;
5793 &#32;&#32;&#32;&#32;}
5794 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">throw</emphasis>&#32;<emphasis role="stringliteral">&quot;Unexpected&#32;verdict&quot;</emphasis>;
5795 }
5796 
5797 TestResultVerdict&#32;deserializeTestResultVerdict(std::string&#32;s)&#32;{
5798 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(s&#32;==&#32;<emphasis role="stringliteral">&quot;SKIPPED&quot;</emphasis>)
5799 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;SKIPPED;
5800 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="keywordflow">if</emphasis>&#32;(s&#32;==&#32;<emphasis role="stringliteral">&quot;OK&quot;</emphasis>)
5801 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;OK;
5802 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="keywordflow">if</emphasis>&#32;(s&#32;==&#32;<emphasis role="stringliteral">&quot;WRONG_ANSWER&quot;</emphasis>)
5803 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;WRONG_ANSWER;
5804 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="keywordflow">if</emphasis>&#32;(s&#32;==&#32;<emphasis role="stringliteral">&quot;RUNTIME_ERROR&quot;</emphasis>)
5805 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;RUNTIME_ERROR;
5806 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="keywordflow">if</emphasis>&#32;(s&#32;==&#32;<emphasis role="stringliteral">&quot;TIME_LIMIT_EXCEEDED&quot;</emphasis>)
5807 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;TIME_LIMIT_EXCEEDED;
5808 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="keywordflow">if</emphasis>&#32;(s&#32;==&#32;<emphasis role="stringliteral">&quot;IDLENESS_LIMIT_EXCEEDED&quot;</emphasis>)
5809 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;IDLENESS_LIMIT_EXCEEDED;
5810 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="keywordflow">if</emphasis>&#32;(s&#32;==&#32;<emphasis role="stringliteral">&quot;MEMORY_LIMIT_EXCEEDED&quot;</emphasis>)
5811 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;MEMORY_LIMIT_EXCEEDED;
5812 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="keywordflow">if</emphasis>&#32;(s&#32;==&#32;<emphasis role="stringliteral">&quot;COMPILATION_ERROR&quot;</emphasis>)
5813 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;COMPILATION_ERROR;
5814 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="keywordflow">if</emphasis>&#32;(s&#32;==&#32;<emphasis role="stringliteral">&quot;CRASHED&quot;</emphasis>)
5815 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;CRASHED;
5816 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="keywordflow">if</emphasis>&#32;(s&#32;==&#32;<emphasis role="stringliteral">&quot;FAILED&quot;</emphasis>)
5817 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;FAILED;
5818 &#32;&#32;&#32;&#32;ensuref(<emphasis role="keyword">false</emphasis>,&#32;<emphasis role="stringliteral">&quot;Unexpected&#32;serialized&#32;TestResultVerdict&quot;</emphasis>);
5819 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;No&#32;return&#32;actually.</emphasis>
5820 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;FAILED;
5821 }
5822 
5823 <emphasis role="keyword">struct&#32;</emphasis>TestResult&#32;{
5824 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;testIndex;
5825 &#32;&#32;&#32;&#32;std::string&#32;testset;
5826 &#32;&#32;&#32;&#32;std::string&#32;group;
5827 &#32;&#32;&#32;&#32;TestResultVerdict&#32;verdict;
5828 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">double</emphasis>&#32;points;
5829 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;timeConsumed;
5830 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">long</emphasis>&#32;<emphasis role="keywordtype">long</emphasis>&#32;memoryConsumed;
5831 &#32;&#32;&#32;&#32;std::string&#32;input;
5832 &#32;&#32;&#32;&#32;std::string&#32;output;
5833 &#32;&#32;&#32;&#32;std::string&#32;answer;
5834 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;exitCode;
5835 &#32;&#32;&#32;&#32;std::string&#32;checkerComment;
5836 };
5837 
5838 std::string&#32;serializePoints(<emphasis role="keywordtype">double</emphasis>&#32;points)&#32;{
5839 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(std::isnan(points))
5840 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>;
5841 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
5842 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">char</emphasis>&#32;c[64];
5843 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;snprintf(c,&#32;64,&#32;<emphasis role="stringliteral">&quot;%.03lf&quot;</emphasis>,&#32;points);
5844 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;c;
5845 &#32;&#32;&#32;&#32;}
5846 }
5847 
5848 <emphasis role="keywordtype">double</emphasis>&#32;deserializePoints(std::string&#32;s)&#32;{
5849 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(s.empty())
5850 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;std::numeric_limits&lt;double&gt;::quiet_NaN();
5851 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
5852 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">double</emphasis>&#32;result;
5853 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;ensuref(sscanf(s.c_str(),&#32;<emphasis role="stringliteral">&quot;%lf&quot;</emphasis>,&#32;&amp;result)&#32;==&#32;1,&#32;<emphasis role="stringliteral">&quot;Invalid&#32;serialized&#32;points&quot;</emphasis>);
5854 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;result;
5855 &#32;&#32;&#32;&#32;}&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
5856 }
5857 
5858 std::string&#32;escapeTestResultString(std::string&#32;s)&#32;{
5859 &#32;&#32;&#32;&#32;std::string&#32;result;
5860 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">size_t</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;s.length();&#32;i++)&#32;{
5861 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(s[i]&#32;==&#32;<emphasis role="charliteral">&apos;\r&apos;</emphasis>)
5862 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">continue</emphasis>;
5863 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(s[i]&#32;==&#32;<emphasis role="charliteral">&apos;\n&apos;</emphasis>)&#32;{
5864 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result&#32;+=&#32;<emphasis role="stringliteral">&quot;\\n&quot;</emphasis>;
5865 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">continue</emphasis>;
5866 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
5867 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(s[i]&#32;==&#32;<emphasis role="charliteral">&apos;\\&apos;</emphasis>&#32;||&#32;s[i]&#32;==&#32;<emphasis role="charliteral">&apos;;&apos;</emphasis>)
5868 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result&#32;+=&#32;<emphasis role="charliteral">&apos;\\&apos;</emphasis>;
5869 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result&#32;+=&#32;s[i];
5870 &#32;&#32;&#32;&#32;}
5871 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;result;
5872 }
5873 
5874 std::string&#32;unescapeTestResultString(std::string&#32;s)&#32;{
5875 &#32;&#32;&#32;&#32;std::string&#32;result;
5876 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">size_t</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;s.length();&#32;i++)&#32;{
5877 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(s[i]&#32;==&#32;<emphasis role="charliteral">&apos;\\&apos;</emphasis>&#32;&amp;&amp;&#32;i&#32;+&#32;1&#32;&lt;&#32;s.length())&#32;{
5878 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(s[i&#32;+&#32;1]&#32;==&#32;<emphasis role="charliteral">&apos;n&apos;</emphasis>)&#32;{
5879 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result&#32;+=&#32;<emphasis role="charliteral">&apos;\n&apos;</emphasis>;
5880 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;i++;
5881 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">continue</emphasis>;
5882 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="keywordflow">if</emphasis>&#32;(s[i&#32;+&#32;1]&#32;==&#32;<emphasis role="charliteral">&apos;;&apos;</emphasis>&#32;||&#32;s[i&#32;+&#32;1]&#32;==&#32;<emphasis role="charliteral">&apos;\\&apos;</emphasis>)&#32;{
5883 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result&#32;+=&#32;s[i&#32;+&#32;1];
5884 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;i++;
5885 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">continue</emphasis>;
5886 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
5887 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
5888 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result&#32;+=&#32;s[i];
5889 &#32;&#32;&#32;&#32;}
5890 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;result;
5891 }
5892 
5893 std::string&#32;serializeTestResult(TestResult&#32;tr)&#32;{
5894 &#32;&#32;&#32;&#32;std::string&#32;result;
5895 &#32;&#32;&#32;&#32;result&#32;+=&#32;std::to_string(tr.testIndex);
5896 &#32;&#32;&#32;&#32;result&#32;+=&#32;<emphasis role="stringliteral">&quot;;&quot;</emphasis>;
5897 &#32;&#32;&#32;&#32;result&#32;+=&#32;escapeTestResultString(tr.testset);
5898 &#32;&#32;&#32;&#32;result&#32;+=&#32;<emphasis role="stringliteral">&quot;;&quot;</emphasis>;
5899 &#32;&#32;&#32;&#32;result&#32;+=&#32;escapeTestResultString(tr.group);
5900 &#32;&#32;&#32;&#32;result&#32;+=&#32;<emphasis role="stringliteral">&quot;;&quot;</emphasis>;
5901 &#32;&#32;&#32;&#32;result&#32;+=&#32;serializeVerdict(tr.verdict);
5902 &#32;&#32;&#32;&#32;result&#32;+=&#32;<emphasis role="stringliteral">&quot;;&quot;</emphasis>;
5903 &#32;&#32;&#32;&#32;result&#32;+=&#32;serializePoints(tr.points);
5904 &#32;&#32;&#32;&#32;result&#32;+=&#32;<emphasis role="stringliteral">&quot;;&quot;</emphasis>;
5905 &#32;&#32;&#32;&#32;result&#32;+=&#32;std::to_string(tr.timeConsumed);
5906 &#32;&#32;&#32;&#32;result&#32;+=&#32;<emphasis role="stringliteral">&quot;;&quot;</emphasis>;
5907 &#32;&#32;&#32;&#32;result&#32;+=&#32;std::to_string(tr.memoryConsumed);
5908 &#32;&#32;&#32;&#32;result&#32;+=&#32;<emphasis role="stringliteral">&quot;;&quot;</emphasis>;
5909 &#32;&#32;&#32;&#32;result&#32;+=&#32;escapeTestResultString(tr.input);
5910 &#32;&#32;&#32;&#32;result&#32;+=&#32;<emphasis role="stringliteral">&quot;;&quot;</emphasis>;
5911 &#32;&#32;&#32;&#32;result&#32;+=&#32;escapeTestResultString(tr.output);
5912 &#32;&#32;&#32;&#32;result&#32;+=&#32;<emphasis role="stringliteral">&quot;;&quot;</emphasis>;
5913 &#32;&#32;&#32;&#32;result&#32;+=&#32;escapeTestResultString(tr.answer);
5914 &#32;&#32;&#32;&#32;result&#32;+=&#32;<emphasis role="stringliteral">&quot;;&quot;</emphasis>;
5915 &#32;&#32;&#32;&#32;result&#32;+=&#32;std::to_string(tr.exitCode);
5916 &#32;&#32;&#32;&#32;result&#32;+=&#32;<emphasis role="stringliteral">&quot;;&quot;</emphasis>;
5917 &#32;&#32;&#32;&#32;result&#32;+=&#32;escapeTestResultString(tr.checkerComment);
5918 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;result;
5919 }
5920 
5921 TestResult&#32;deserializeTestResult(std::string&#32;s)&#32;{
5922 &#32;&#32;&#32;&#32;std::vector&lt;std::string&gt;&#32;items;
5923 &#32;&#32;&#32;&#32;std::string&#32;t;
5924 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">size_t</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;s.length();&#32;i++)&#32;{
5925 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(s[i]&#32;==&#32;<emphasis role="charliteral">&apos;\\&apos;</emphasis>)&#32;{
5926 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;t&#32;+=&#32;s[i];
5927 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(i&#32;+&#32;1&#32;&lt;&#32;s.length())
5928 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;t&#32;+=&#32;s[i&#32;+&#32;1];
5929 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;i++;
5930 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">continue</emphasis>;
5931 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
5932 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(s[i]&#32;==&#32;<emphasis role="charliteral">&apos;;&apos;</emphasis>)&#32;{
5933 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;items.push_back(t);
5934 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;t&#32;=&#32;<emphasis role="stringliteral">&quot;&quot;</emphasis>;
5935 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>
5936 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;t&#32;+=&#32;s[i];
5937 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
5938 &#32;&#32;&#32;&#32;}
5939 &#32;&#32;&#32;&#32;items.push_back(t);
5940 
5941 &#32;&#32;&#32;&#32;ensuref(items.size()&#32;==&#32;12,&#32;<emphasis role="stringliteral">&quot;Invalid&#32;TestResult&#32;serialization:&#32;expected&#32;exactly&#32;12&#32;items&quot;</emphasis>);
5942 &#32;&#32;&#32;&#32;
5943 &#32;&#32;&#32;&#32;TestResult&#32;tr;
5944 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;pos&#32;=&#32;0;
5945 &#32;&#32;&#32;&#32;tr.testIndex&#32;=&#32;stoi(items[pos++]);
5946 &#32;&#32;&#32;&#32;tr.testset&#32;=&#32;unescapeTestResultString(items[pos++]);
5947 &#32;&#32;&#32;&#32;tr.group&#32;=&#32;unescapeTestResultString(items[pos++]);
5948 &#32;&#32;&#32;&#32;tr.verdict&#32;=&#32;deserializeTestResultVerdict(items[pos++]);
5949 &#32;&#32;&#32;&#32;tr.points&#32;=&#32;deserializePoints(items[pos++]);
5950 &#32;&#32;&#32;&#32;tr.timeConsumed&#32;=&#32;stoll(items[pos++]);
5951 &#32;&#32;&#32;&#32;tr.memoryConsumed&#32;=&#32;stoll(items[pos++]);
5952 &#32;&#32;&#32;&#32;tr.input&#32;=&#32;unescapeTestResultString(items[pos++]);
5953 &#32;&#32;&#32;&#32;tr.output&#32;=&#32;unescapeTestResultString(items[pos++]);
5954 &#32;&#32;&#32;&#32;tr.answer&#32;=&#32;unescapeTestResultString(items[pos++]);
5955 &#32;&#32;&#32;&#32;tr.exitCode&#32;=&#32;stoi(items[pos++]);
5956 &#32;&#32;&#32;&#32;tr.checkerComment&#32;=&#32;unescapeTestResultString(items[pos++]);
5957 &#32;&#32;&#32;&#32;
5958 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;tr;
5959 }
5960 
5961 std::vector&lt;TestResult&gt;&#32;readTestResults(std::string&#32;fileName)&#32;{
5962 &#32;&#32;&#32;&#32;std::ifstream&#32;stream;
5963 &#32;&#32;&#32;&#32;stream.open(fileName.c_str(),&#32;std::ios::in);
5964 &#32;&#32;&#32;&#32;ensuref(stream.is_open(),&#32;<emphasis role="stringliteral">&quot;Can&apos;t&#32;read&#32;test&#32;results&#32;file&#32;&apos;%s&apos;&quot;</emphasis>,&#32;fileName.c_str());
5965 &#32;&#32;&#32;&#32;std::vector&lt;TestResult&gt;&#32;result;
5966 &#32;&#32;&#32;&#32;std::string&#32;line;
5967 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">while</emphasis>&#32;(getline(stream,&#32;line))
5968 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!line.empty())
5969 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result.push_back(deserializeTestResult(line));
5970 &#32;&#32;&#32;&#32;stream.close();
5971 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;result;
5972 }
5973 
5974 std::function&lt;double(std::vector&lt;TestResult&gt;)&gt;&#32;__testlib_scorer;
5975 
5976 <emphasis role="keyword">struct&#32;</emphasis>TestlibScorerGuard&#32;{
5977 &#32;&#32;&#32;&#32;~TestlibScorerGuard()&#32;{
5978 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(testlibMode&#32;==&#32;_scorer)&#32;{
5979 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::vector&lt;TestResult&gt;&#32;testResults;
5980 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">while</emphasis>&#32;(!inf.eof())&#32;{
5981 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::string&#32;line&#32;=&#32;inf.readLine();
5982 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!line.empty())
5983 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;testResults.push_back(deserializeTestResult(line));
5984 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
5985 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;inf.readEof();
5986 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;printf(<emphasis role="stringliteral">&quot;%.3f\n&quot;</emphasis>,&#32;__testlib_scorer(testResults));
5987 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
5988 &#32;&#32;&#32;&#32;}
5989 }&#32;__testlib_scorer_guard;
5990 
5991 <emphasis role="keywordtype">void</emphasis>&#32;registerScorer(<emphasis role="keywordtype">int</emphasis>&#32;argc,&#32;<emphasis role="keywordtype">char</emphasis>&#32;*argv[],&#32;std::function&lt;<emphasis role="keywordtype">double</emphasis>(std::vector&lt;TestResult&gt;)&gt;&#32;scorer)&#32;{
5992 &#32;&#32;&#32;&#32;<emphasis role="comment">/*&#32;Suppress&#32;unused.&#32;*/</emphasis>
5993 &#32;&#32;&#32;&#32;(void)(argc),&#32;(void)(argv);
5994 
5995 &#32;&#32;&#32;&#32;__testlib_ensuresPreconditions();
5996 
5997 &#32;&#32;&#32;&#32;testlibMode&#32;=&#32;_scorer;
5998 &#32;&#32;&#32;&#32;__testlib_set_binary(stdin);
5999 
6000 &#32;&#32;&#32;&#32;inf.init(stdin,&#32;_input);
6001 &#32;&#32;&#32;&#32;inf.strict&#32;=&#32;<emphasis role="keyword">false</emphasis>;
6002 
6003 &#32;&#32;&#32;&#32;__testlib_scorer&#32;=&#32;scorer;
6004 }
6005 
6006 <emphasis role="comment">/*&#32;Scorer&#32;ended.&#32;*/</emphasis>
6007 
6016 <emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Tp&gt;
6017 _Tp&#32;opt(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;key,&#32;<emphasis role="keyword">const</emphasis>&#32;_Tp&#32;&amp;default_value)&#32;{
6018 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!has_opt(key))&#32;{
6019 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;default_value;
6020 &#32;&#32;&#32;&#32;}
6021 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;opt&lt;_Tp&gt;(key);
6022 }
6023 
6032 std::string&#32;opt(<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;key,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&#32;&amp;default_value)&#32;{
6033 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;opt&lt;std::string&gt;(key,&#32;default_value);
6034 }
6035 
6043 <emphasis role="keywordtype">void</emphasis>&#32;ensureNoUnusedOpts()&#32;{
6044 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">auto</emphasis>&#32;&amp;opt:&#32;__testlib_opts)&#32;{
6045 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!opt.second.used)&#32;{
6046 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__testlib_fail(format(<emphasis role="stringliteral">&quot;Opts:&#32;unused&#32;key&#32;&apos;%s&apos;&quot;</emphasis>,&#32;compress(opt.first).c_str()));
6047 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
6048 &#32;&#32;&#32;&#32;}
6049 }
6050 
6051 <emphasis role="keywordtype">void</emphasis>&#32;suppressEnsureNoUnusedOpts()&#32;{
6052 &#32;&#32;&#32;&#32;__testlib_ensureNoUnusedOptsSuppressed&#32;=&#32;<emphasis role="keyword">true</emphasis>;
6053 }
6054 
6055 <emphasis role="keywordtype">void</emphasis>&#32;TestlibFinalizeGuard::autoEnsureNoUnusedOpts()&#32;{
6056 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__testlib_ensureNoUnusedOptsFlag&#32;&amp;&amp;&#32;!__testlib_ensureNoUnusedOptsSuppressed)&#32;{
6057 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;ensureNoUnusedOpts();
6058 &#32;&#32;&#32;&#32;}
6059 }
6060 
6061 <link linkend="_struct_testlib_finalize_guard">TestlibFinalizeGuard</link>&#32;testlibFinalizeGuard;
6062 
6063 <emphasis role="preprocessor">#endif</emphasis>
6064 <emphasis role="preprocessor">#endif</emphasis>
</programlisting></section>
